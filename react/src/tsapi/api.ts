/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Fundscraper API
 * The REST api methods available for access to the fundscraper system
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration?: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AdminModule
 */
export interface AdminModule {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof AdminModule
     */
    id: number;
    /**
     * the id of the module that this is a child of
     * @type {number}
     * @memberof AdminModule
     */
    sub_id: number;
    /**
     * the human readable identifier of the module (its name)
     * @type {string}
     * @memberof AdminModule
     */
    name: string;
    /**
     * the identifier to use for seo for the module
     * @type {string}
     * @memberof AdminModule
     */
    module_seo: string;
    /**
     * a url to the icon to use to represent the module
     * @type {string}
     * @memberof AdminModule
     */
    module_icon: string;
    /**
     * unused
     * @type {number}
     * @memberof AdminModule
     */
    status: number;
    /**
     * the ordinal position of the module
     * @type {number}
     * @memberof AdminModule
     */
    sort_order: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof AdminModule
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof AdminModule
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof AdminModule
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof AdminModule
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_MODULE_ACCESS_MODULE_ID_GRANTS and described as: 
     * @type {Array<ModuleAccess>}
     * @memberof AdminModule
     */
    grants: Array<ModuleAccess>;
    /**
     * This was created from the details of the foreign key FK_MODULES_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof AdminModule
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_MODULES_SUB_ID_CHILD_MODULES and described as: 
     * @type {AdminModule}
     * @memberof AdminModule
     */
    sub: AdminModule;
    /**
     * This was created from the details of the foreign key FK_MODULES_SUB_ID_CHILD_MODULES and described as: 
     * @type {Array<AdminModule>}
     * @memberof AdminModule
     */
    child_modules: Array<AdminModule>;
}
/**
 * 
 * @export
 * @interface AdminUser
 */
export interface AdminUser {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof AdminUser
     */
    id: number;
    /**
     * the category of user this is (i&#x3D;investor, a&#x3D;admin, c&#x3D;issuer admin)
     * @type {string}
     * @memberof AdminUser
     */
    user_type: string;
    /**
     * the first name of the person who uses the account
     * @type {string}
     * @memberof AdminUser
     */
    first_name: string;
    /**
     * the last name of the person who uses the account
     * @type {string}
     * @memberof AdminUser
     */
    last_name: string;
    /**
     * the name of the file that holds the avatars picture. this is the resouce relative, not site relative.
     * @type {string}
     * @memberof AdminUser
     */
    avatar_image_file_name: string;
    /**
     * the email address that identifies the account
     * @type {string}
     * @memberof AdminUser
     */
    email: string;
    /**
     * the last point in time the user logged in
     * @type {Date}
     * @memberof AdminUser
     */
    last_login: Date;
    /**
     * the last ip that they used to access the site from
     * @type {string}
     * @memberof AdminUser
     */
    last_ip: string;
    /**
     * the name of the service that verifies the identity of the user (according to azure b2c))
     * @type {string}
     * @memberof AdminUser
     */
    identity_provider: string;
    /**
     * the identifier for the user in the b2c system
     * @type {string}
     * @memberof AdminUser
     */
    user_principle_name: string;
    /**
     * json format values that are used by applications as preferences
     * @type {string}
     * @memberof AdminUser
     */
    preferences_as_json: string;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof AdminUser
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof AdminUser
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof AdminUser
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof AdminUser
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_COBRANDED_TO_SOCIAL_PROFILE and described as: 
     * @type {UserSocialProfile}
     * @memberof AdminUser
     */
    cobranded_client_of: UserSocialProfile;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_TO_COUNTRIES and described as: 
     * @type {Country}
     * @memberof AdminUser
     */
    country: Country;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof AdminUser
     */
    last_changed_by: AllUser;
    /**
     * 
     * @type {Array<WebHook>}
     * @memberof AdminUser
     */
    changes: Array<WebHook>;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_TO_MCOUNTRIES and described as: 
     * @type {Country}
     * @memberof AdminUser
     */
    mailing_country: Country;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_TO_MPROVINCES and described as: 
     * @type {Province}
     * @memberof AdminUser
     */
    mailing_province: Province;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_TO_PROVINCE and described as: 
     * @type {Province}
     * @memberof AdminUser
     */
    province: Province;
    /**
     * This was created from the details of the foreign key FK_BACKGROUND_PROCESSS_LASTUSER_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {Array<BackgroundProcess>}
     * @memberof AdminUser
     */
    background_processs_lastuser_last_changed_by_id_changes: Array<BackgroundProcess>;
    /**
     * This was created from the details of the foreign key FK_EVENTS_TO_USER and described as: 
     * @type {Array<Event>}
     * @memberof AdminUser
     */
    events_to_user: Array<Event>;
    /**
     * This was created from the details of the foreign key FK_FFBA_ASSOCIATION_TO_USER and described as: 
     * @type {Array<FfbaAssociation>}
     * @memberof AdminUser
     */
    ffba_association_to_user: Array<FfbaAssociation>;
    /**
     * This was created from the details of the foreign key FK_IMPORTED_CONTACTS_USER_ID_CONTACTS and described as: 
     * @type {Array<ImportedContact>}
     * @memberof AdminUser
     */
    contacts: Array<ImportedContact>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_JOINT_SUBSCRIBER_TO_USER and described as: 
     * @type {Array<InvestmentOrder>}
     * @memberof AdminUser
     */
    investment_orders_joint_subscriber_to_user: Array<InvestmentOrder>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_USER_ID_ORDERS and described as: 
     * @type {Array<InvestmentOrder>}
     * @memberof AdminUser
     */
    orders: Array<InvestmentOrder>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_TRANSACTION_USER_ID_TRANSACTIONS and described as: 
     * @type {Array<InvestmentTransaction>}
     * @memberof AdminUser
     */
    transactions: Array<InvestmentTransaction>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_WATCHLIST_USER_ID_WATCHES and described as: 
     * @type {Array<InvestmentWatchlist>}
     * @memberof AdminUser
     */
    watches: Array<InvestmentWatchlist>;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_ACK_ORDERS_USER_ORDER_ACKNOWLEDGEMENTS and described as: 
     * @type {Array<OrderAcknowledgement>}
     * @memberof AdminUser
     */
    investor_ack_orders_user_order_acknowledgements: Array<OrderAcknowledgement>;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_EARNINGS_USER_D and described as: 
     * @type {Array<InvestorEarning>}
     * @memberof AdminUser
     */
    investor_earnings_user_d: Array<InvestorEarning>;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_INTENDED_TRADES_USER_ID_INTENDED_TRADES and described as: 
     * @type {Array<InvestorIntendedTrades>}
     * @memberof AdminUser
     */
    intended_trades: Array<InvestorIntendedTrades>;
    /**
     * This was created from the details of the foreign key FK_MAILS_FROM_ID_SENT_EMAILS and described as: 
     * @type {Array<Mail>}
     * @memberof AdminUser
     */
    sent_emails: Array<Mail>;
    /**
     * This was created from the details of the foreign key FK_MAILS_TO_ID_RECEIVED_EMAILS and described as: 
     * @type {Array<Mail>}
     * @memberof AdminUser
     */
    received_emails: Array<Mail>;
    /**
     * This was created from the details of the foreign key FK_MODULE_ACCESS_USER_ID_ACCESSIBLE_MODULES and described as: 
     * @type {Array<ModuleAccess>}
     * @memberof AdminUser
     */
    accessible_modules: Array<ModuleAccess>;
    /**
     * This was created from the details of the foreign key FK_PROJECT_TAX_REPORTS_USER_ID_TAX_REPORTS and described as: 
     * @type {Array<ProjectTaxReport>}
     * @memberof AdminUser
     */
    tax_reports: Array<ProjectTaxReport>;
    /**
     * This was created from the details of the foreign key FK_SUPPORT_ENGINEERS_USER_ID_OWNER_USER and described as: 
     * @type {Array<SupportEngineer>}
     * @memberof AdminUser
     */
    owner_user: Array<SupportEngineer>;
    /**
     * This was created from the details of the foreign key FK_USER_ISSUER_ASSOCIATIONS_TO_USER_ID_ISSUER_ASSOCIATIONS and described as: 
     * @type {Array<UserIssuerAssociation>}
     * @memberof AdminUser
     */
    user_issuer_associations_to_user_id_issuer_associations: Array<UserIssuerAssociation>;
    /**
     * This was created from the details of the foreign key FK_USER_RELATIONSHIP_TO_USER_1 and described as: 
     * @type {Array<UserRelationship>}
     * @memberof AdminUser
     */
    user_relationship_to_user_1: Array<UserRelationship>;
    /**
     * This was created from the details of the foreign key FK_USER_RELATIONSHIP_TO_USER_2 and described as: 
     * @type {Array<UserRelationship>}
     * @memberof AdminUser
     */
    user_relationship_to_user_2: Array<UserRelationship>;
    /**
     * This was created from the details of the foreign key FK_USERS_BANKING_DETAILS_TO_JOINT_USER and described as: 
     * @type {Array<UserBankingDetails>}
     * @memberof AdminUser
     */
    users_banking_details_to_joint_user: Array<UserBankingDetails>;
    /**
     * This was created from the details of the foreign key FK_USERS_BANKING_DETAILS_TO_USER and described as: 
     * @type {Array<UserBankingDetails>}
     * @memberof AdminUser
     */
    users_banking_details_to_user: Array<UserBankingDetails>;
    /**
     * This was created from the details of the foreign key FK_USERS_EMPLOYMENT_USER_ID_FINANCIAL_KYC and described as: 
     * @type {Array<UserFinancialKyc>}
     * @memberof AdminUser
     */
    financial_kyc: Array<UserFinancialKyc>;
    /**
     * This was created from the details of the foreign key FK_USERS_ENTITY_USER_ID_ENTITIES and described as: 
     * @type {Array<UserEntity>}
     * @memberof AdminUser
     */
    entities: Array<UserEntity>;
    /**
     * This was created from the details of the foreign key FK_USERS_INVITEE_USER_ID_INVITATIONS and described as: 
     * @type {Array<UserInvitation>}
     * @memberof AdminUser
     */
    invitations: Array<UserInvitation>;
    /**
     * This was created from the details of the foreign key FK_USERS_PDF_USER_ID_PDFS and described as: 
     * @type {Array<UserPdf>}
     * @memberof AdminUser
     */
    pdfs: Array<UserPdf>;
    /**
     * This was created from the details of the foreign key FK_USERS_QUESTIONARY_USER_ID_ANSWERS and described as: 
     * @type {Array<UserAnswer>}
     * @memberof AdminUser
     */
    answers: Array<UserAnswer>;
    /**
     * This was created from the details of the foreign key FK_USERS_REQUEST_USER_ID_REQUESTS and described as: 
     * @type {Array<UserRequest>}
     * @memberof AdminUser
     */
    requests: Array<UserRequest>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {Array<UserSocialProfile>}
     * @memberof AdminUser
     */
    users_socialprofile_last_changed_by_id_changes: Array<UserSocialProfile>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_USER_ID_PROFILES and described as: 
     * @type {Array<UserSocialProfile>}
     * @memberof AdminUser
     */
    users_socialprofile_user_id_profiles: Array<UserSocialProfile>;
    /**
     * This was created from the details of the foreign key FK_USERS_SUBSCRIBE_USER_ID_SUBSCRIPTIONS and described as: 
     * @type {Array<UserSubscription>}
     * @memberof AdminUser
     */
    subscriptions: Array<UserSubscription>;
    /**
     * This was created from the details of the foreign key FK_WEB_HOOKS_TO_USER and described as: 
     * @type {Array<WebHook>}
     * @memberof AdminUser
     */
    web_hooks_to_user: Array<WebHook>;
    /**
     * the type of function the administrator performs
     * @type {string}
     * @memberof AdminUser
     */
    role: string;
    /**
     * deprecated, do not use
     * @type {string}
     * @memberof AdminUser
     */
    username: string;
    /**
     * the token used to identify the current session
     * @type {string}
     * @memberof AdminUser
     */
    token: string;
    /**
     * the last time the session token was updated
     * @type {Date}
     * @memberof AdminUser
     */
    token_update: Date;
    /**
     * the type of administrative role performed
     * @type {number}
     * @memberof AdminUser
     */
    admin_role: number;
    /**
     * the avilability of the account for use
     * @type {number}
     * @memberof AdminUser
     */
    availability: number;
    /**
     * The name of the timezone the administrator typically connects from
     * @type {string}
     * @memberof AdminUser
     */
    timezone: string;
    /**
     * The name of the country the administrator is generally located in
     * @type {string}
     * @memberof AdminUser
     */
    location: string;
    /**
     * The name of the file that holds the image of the country flag the administrators location is in
     * @type {string}
     * @memberof AdminUser
     */
    flag: string;
}
/**
 * 
 * @export
 * @interface AllUser
 */
export interface AllUser {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof AllUser
     */
    id: number;
    /**
     * the category of user this is (i&#x3D;investor, a&#x3D;admin, c&#x3D;issuer admin)
     * @type {string}
     * @memberof AllUser
     */
    user_type: string;
    /**
     * the first name of the person who uses the account
     * @type {string}
     * @memberof AllUser
     */
    first_name: string;
    /**
     * the last name of the person who uses the account
     * @type {string}
     * @memberof AllUser
     */
    last_name: string;
    /**
     * the name of the file that holds the avatars picture. this is the resouce relative, not site relative.
     * @type {string}
     * @memberof AllUser
     */
    avatar_image_file_name: string;
    /**
     * the email address that identifies the account
     * @type {string}
     * @memberof AllUser
     */
    email: string;
    /**
     * the last point in time the user logged in
     * @type {Date}
     * @memberof AllUser
     */
    last_login: Date;
    /**
     * the last ip that they used to access the site from
     * @type {string}
     * @memberof AllUser
     */
    last_ip: string;
    /**
     * the name of the service that verifies the identity of the user (according to azure b2c))
     * @type {string}
     * @memberof AllUser
     */
    identity_provider: string;
    /**
     * the identifier for the user in the b2c system
     * @type {string}
     * @memberof AllUser
     */
    user_principle_name: string;
    /**
     * json format values that are used by applications as preferences
     * @type {string}
     * @memberof AllUser
     */
    preferences_as_json: string;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof AllUser
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof AllUser
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof AllUser
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof AllUser
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_COBRANDED_TO_SOCIAL_PROFILE and described as: 
     * @type {UserSocialProfile}
     * @memberof AllUser
     */
    cobranded_client_of: UserSocialProfile;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_TO_COUNTRIES and described as: 
     * @type {Country}
     * @memberof AllUser
     */
    country: Country;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof AllUser
     */
    last_changed_by: AllUser;
    /**
     * 
     * @type {Array<WebHook>}
     * @memberof AllUser
     */
    changes: Array<WebHook>;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_TO_MCOUNTRIES and described as: 
     * @type {Country}
     * @memberof AllUser
     */
    mailing_country: Country;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_TO_MPROVINCES and described as: 
     * @type {Province}
     * @memberof AllUser
     */
    mailing_province: Province;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_TO_PROVINCE and described as: 
     * @type {Province}
     * @memberof AllUser
     */
    province: Province;
    /**
     * This was created from the details of the foreign key FK_BACKGROUND_PROCESSS_LASTUSER_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {Array<BackgroundProcess>}
     * @memberof AllUser
     */
    background_processs_lastuser_last_changed_by_id_changes: Array<BackgroundProcess>;
    /**
     * This was created from the details of the foreign key FK_EVENTS_TO_USER and described as: 
     * @type {Array<Event>}
     * @memberof AllUser
     */
    events_to_user: Array<Event>;
    /**
     * This was created from the details of the foreign key FK_FFBA_ASSOCIATION_TO_USER and described as: 
     * @type {Array<FfbaAssociation>}
     * @memberof AllUser
     */
    ffba_association_to_user: Array<FfbaAssociation>;
    /**
     * This was created from the details of the foreign key FK_IMPORTED_CONTACTS_USER_ID_CONTACTS and described as: 
     * @type {Array<ImportedContact>}
     * @memberof AllUser
     */
    contacts: Array<ImportedContact>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_JOINT_SUBSCRIBER_TO_USER and described as: 
     * @type {Array<InvestmentOrder>}
     * @memberof AllUser
     */
    investment_orders_joint_subscriber_to_user: Array<InvestmentOrder>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_USER_ID_ORDERS and described as: 
     * @type {Array<InvestmentOrder>}
     * @memberof AllUser
     */
    orders: Array<InvestmentOrder>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_TRANSACTION_USER_ID_TRANSACTIONS and described as: 
     * @type {Array<InvestmentTransaction>}
     * @memberof AllUser
     */
    transactions: Array<InvestmentTransaction>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_WATCHLIST_USER_ID_WATCHES and described as: 
     * @type {Array<InvestmentWatchlist>}
     * @memberof AllUser
     */
    watches: Array<InvestmentWatchlist>;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_ACK_ORDERS_USER_ORDER_ACKNOWLEDGEMENTS and described as: 
     * @type {Array<OrderAcknowledgement>}
     * @memberof AllUser
     */
    investor_ack_orders_user_order_acknowledgements: Array<OrderAcknowledgement>;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_EARNINGS_USER_D and described as: 
     * @type {Array<InvestorEarning>}
     * @memberof AllUser
     */
    investor_earnings_user_d: Array<InvestorEarning>;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_INTENDED_TRADES_USER_ID_INTENDED_TRADES and described as: 
     * @type {Array<InvestorIntendedTrades>}
     * @memberof AllUser
     */
    intended_trades: Array<InvestorIntendedTrades>;
    /**
     * This was created from the details of the foreign key FK_MAILS_FROM_ID_SENT_EMAILS and described as: 
     * @type {Array<Mail>}
     * @memberof AllUser
     */
    sent_emails: Array<Mail>;
    /**
     * This was created from the details of the foreign key FK_MAILS_TO_ID_RECEIVED_EMAILS and described as: 
     * @type {Array<Mail>}
     * @memberof AllUser
     */
    received_emails: Array<Mail>;
    /**
     * This was created from the details of the foreign key FK_MODULE_ACCESS_USER_ID_ACCESSIBLE_MODULES and described as: 
     * @type {Array<ModuleAccess>}
     * @memberof AllUser
     */
    accessible_modules: Array<ModuleAccess>;
    /**
     * This was created from the details of the foreign key FK_PROJECT_TAX_REPORTS_USER_ID_TAX_REPORTS and described as: 
     * @type {Array<ProjectTaxReport>}
     * @memberof AllUser
     */
    tax_reports: Array<ProjectTaxReport>;
    /**
     * This was created from the details of the foreign key FK_SUPPORT_ENGINEERS_USER_ID_OWNER_USER and described as: 
     * @type {Array<SupportEngineer>}
     * @memberof AllUser
     */
    owner_user: Array<SupportEngineer>;
    /**
     * This was created from the details of the foreign key FK_USER_ISSUER_ASSOCIATIONS_TO_USER_ID_ISSUER_ASSOCIATIONS and described as: 
     * @type {Array<UserIssuerAssociation>}
     * @memberof AllUser
     */
    user_issuer_associations_to_user_id_issuer_associations: Array<UserIssuerAssociation>;
    /**
     * This was created from the details of the foreign key FK_USER_RELATIONSHIP_TO_USER_1 and described as: 
     * @type {Array<UserRelationship>}
     * @memberof AllUser
     */
    user_relationship_to_user_1: Array<UserRelationship>;
    /**
     * This was created from the details of the foreign key FK_USER_RELATIONSHIP_TO_USER_2 and described as: 
     * @type {Array<UserRelationship>}
     * @memberof AllUser
     */
    user_relationship_to_user_2: Array<UserRelationship>;
    /**
     * This was created from the details of the foreign key FK_USERS_BANKING_DETAILS_TO_JOINT_USER and described as: 
     * @type {Array<UserBankingDetails>}
     * @memberof AllUser
     */
    users_banking_details_to_joint_user: Array<UserBankingDetails>;
    /**
     * This was created from the details of the foreign key FK_USERS_BANKING_DETAILS_TO_USER and described as: 
     * @type {Array<UserBankingDetails>}
     * @memberof AllUser
     */
    users_banking_details_to_user: Array<UserBankingDetails>;
    /**
     * This was created from the details of the foreign key FK_USERS_EMPLOYMENT_USER_ID_FINANCIAL_KYC and described as: 
     * @type {Array<UserFinancialKyc>}
     * @memberof AllUser
     */
    financial_kyc: Array<UserFinancialKyc>;
    /**
     * This was created from the details of the foreign key FK_USERS_ENTITY_USER_ID_ENTITIES and described as: 
     * @type {Array<UserEntity>}
     * @memberof AllUser
     */
    entities: Array<UserEntity>;
    /**
     * This was created from the details of the foreign key FK_USERS_INVITEE_USER_ID_INVITATIONS and described as: 
     * @type {Array<UserInvitation>}
     * @memberof AllUser
     */
    invitations: Array<UserInvitation>;
    /**
     * This was created from the details of the foreign key FK_USERS_PDF_USER_ID_PDFS and described as: 
     * @type {Array<UserPdf>}
     * @memberof AllUser
     */
    pdfs: Array<UserPdf>;
    /**
     * This was created from the details of the foreign key FK_USERS_QUESTIONARY_USER_ID_ANSWERS and described as: 
     * @type {Array<UserAnswer>}
     * @memberof AllUser
     */
    answers: Array<UserAnswer>;
    /**
     * This was created from the details of the foreign key FK_USERS_REQUEST_USER_ID_REQUESTS and described as: 
     * @type {Array<UserRequest>}
     * @memberof AllUser
     */
    requests: Array<UserRequest>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {Array<UserSocialProfile>}
     * @memberof AllUser
     */
    users_socialprofile_last_changed_by_id_changes: Array<UserSocialProfile>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_USER_ID_PROFILES and described as: 
     * @type {Array<UserSocialProfile>}
     * @memberof AllUser
     */
    users_socialprofile_user_id_profiles: Array<UserSocialProfile>;
    /**
     * This was created from the details of the foreign key FK_USERS_SUBSCRIBE_USER_ID_SUBSCRIPTIONS and described as: 
     * @type {Array<UserSubscription>}
     * @memberof AllUser
     */
    subscriptions: Array<UserSubscription>;
    /**
     * This was created from the details of the foreign key FK_WEB_HOOKS_TO_USER and described as: 
     * @type {Array<WebHook>}
     * @memberof AllUser
     */
    web_hooks_to_user: Array<WebHook>;
}
/**
 * 
 * @export
 * @interface AllUserAnswer
 */
export interface AllUserAnswer {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {string}
     * @memberof AllUserAnswer
     */
    id: string;
    /**
     * 
     * @type {number}
     * @memberof AllUserAnswer
     */
    question_type: number;
    /**
     * the user this is for
     * @type {number}
     * @memberof AllUserAnswer
     */
    user_id: number;
    /**
     * the id of the user entity that they were acting on the behalf of when they answered it
     * @type {number}
     * @memberof AllUserAnswer
     */
    user_entity_id: number;
    /**
     * 
     * @type {number}
     * @memberof AllUserAnswer
     */
    order_id: number;
    /**
     * the id of the question that was answered
     * @type {number}
     * @memberof AllUserAnswer
     */
    question_id: number;
    /**
     * the text of the question when it was asked. assuming the original question has not change this should still match it
     * @type {string}
     * @memberof AllUserAnswer
     */
    question_text: string;
    /**
     * the response the user provided. if its a multipart response then its a collection of caret (^) separated answers
     * @type {string}
     * @memberof AllUserAnswer
     */
    answer_text: string;
    /**
     * 
     * @type {number}
     * @memberof AllUserAnswer
     */
    did_answer: number;
    /**
     * extra notes by admin for the user answer of a question
     * @type {string}
     * @memberof AllUserAnswer
     */
    notes: string;
    /**
     * identify if the answer has been confirmed
     * @type {boolean}
     * @memberof AllUserAnswer
     */
    is_confirmed: boolean;
    /**
     * the identification of what category the question is about
     * @type {number}
     * @memberof AllUserAnswer
     */
    category: number;
    /**
     * the way on the ui in which the question was answer
     * @type {number}
     * @memberof AllUserAnswer
     */
    presentation_type: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof AllUserAnswer
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof AllUserAnswer
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof AllUserAnswer
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof AllUserAnswer
     */
    updatetime: Date;
}
/**
 * 
 * @export
 * @interface BackgroundProcess
 */
export interface BackgroundProcess {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof BackgroundProcess
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof BackgroundProcess
     */
    cmd_line: string;
    /**
     * if set, the point in time the process is known to have started
     * @type {Date}
     * @memberof BackgroundProcess
     */
    started_at: Date;
    /**
     * if set, the point in time that the process is known to have finished
     * @type {Date}
     * @memberof BackgroundProcess
     */
    finished_at: Date;
    /**
     * if true, the process executed successfully
     * @type {boolean}
     * @memberof BackgroundProcess
     */
    succeeded: boolean;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof BackgroundProcess
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof BackgroundProcess
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof BackgroundProcess
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof BackgroundProcess
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_BACKGROUND_PROCESSS_LASTUSER_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof BackgroundProcess
     */
    last_changed_by: AllUser;
}
/**
 * 
 * @export
 * @interface ComputedAccount
 */
export interface ComputedAccount {
    /**
     * 
     * @type {number}
     * @memberof ComputedAccount
     */
    user_id: number;
    /**
     * 
     * @type {string}
     * @memberof ComputedAccount
     */
    account: string;
    /**
     * 
     * @type {number}
     * @memberof ComputedAccount
     */
    user_entity_id: number;
}
/**
 * 
 * @export
 * @interface ComputedAccountIncome
 */
export interface ComputedAccountIncome {
    /**
     * 
     * @type {number}
     * @memberof ComputedAccountIncome
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof ComputedAccountIncome
     */
    user_id: number;
    /**
     * 
     * @type {number}
     * @memberof ComputedAccountIncome
     */
    project_id: number;
    /**
     * 
     * @type {string}
     * @memberof ComputedAccountIncome
     */
    account: string;
    /**
     * 
     * @type {number}
     * @memberof ComputedAccountIncome
     */
    user_entity_id: number;
    /**
     * 
     * @type {number}
     * @memberof ComputedAccountIncome
     */
    entity_type: number;
    /**
     * 
     * @type {string}
     * @memberof ComputedAccountIncome
     */
    activity: string;
    /**
     * 
     * @type {string}
     * @memberof ComputedAccountIncome
     */
    activity_desc: string;
    /**
     * 
     * @type {number}
     * @memberof ComputedAccountIncome
     */
    order_id: number;
    /**
     * 
     * @type {Date}
     * @memberof ComputedAccountIncome
     */
    transaction_date: Date;
    /**
     * 
     * @type {number}
     * @memberof ComputedAccountIncome
     */
    amount: number;
}
/**
 * 
 * @export
 * @interface ComputedAccountPosition
 */
export interface ComputedAccountPosition {
    /**
     * 
     * @type {number}
     * @memberof ComputedAccountPosition
     */
    project_id: number;
    /**
     * 
     * @type {number}
     * @memberof ComputedAccountPosition
     */
    user_id: number;
    /**
     * 
     * @type {string}
     * @memberof ComputedAccountPosition
     */
    account: string;
    /**
     * 
     * @type {number}
     * @memberof ComputedAccountPosition
     */
    user_entity_id: number;
    /**
     * 
     * @type {number}
     * @memberof ComputedAccountPosition
     */
    entity_type: number;
    /**
     * 
     * @type {number}
     * @memberof ComputedAccountPosition
     */
    book_value: number;
    /**
     * 
     * @type {number}
     * @memberof ComputedAccountPosition
     */
    market_value: number;
    /**
     * 
     * @type {number}
     * @memberof ComputedAccountPosition
     */
    shares: number;
    /**
     * 
     * @type {number}
     * @memberof ComputedAccountPosition
     */
    pending_shares: number;
    /**
     * 
     * @type {Date}
     * @memberof ComputedAccountPosition
     */
    earliest_order_placed: Date;
    /**
     * 
     * @type {Date}
     * @memberof ComputedAccountPosition
     */
    earliest_funds_received: Date;
}
/**
 * 
 * @export
 * @interface ComputedAccountTotalIncome
 */
export interface ComputedAccountTotalIncome {
    /**
     * 
     * @type {number}
     * @memberof ComputedAccountTotalIncome
     */
    user_id: number;
    /**
     * 
     * @type {number}
     * @memberof ComputedAccountTotalIncome
     */
    project_id: number;
    /**
     * 
     * @type {string}
     * @memberof ComputedAccountTotalIncome
     */
    account: string;
    /**
     * 
     * @type {number}
     * @memberof ComputedAccountTotalIncome
     */
    user_entity_id: number;
    /**
     * 
     * @type {number}
     * @memberof ComputedAccountTotalIncome
     */
    entity_type: number;
    /**
     * 
     * @type {number}
     * @memberof ComputedAccountTotalIncome
     */
    balance: number;
}
/**
 * 
 * @export
 * @interface ComputedProjectIncome
 */
export interface ComputedProjectIncome {
    /**
     * 
     * @type {number}
     * @memberof ComputedProjectIncome
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof ComputedProjectIncome
     */
    project_id: number;
    /**
     * 
     * @type {string}
     * @memberof ComputedProjectIncome
     */
    activity: string;
    /**
     * 
     * @type {string}
     * @memberof ComputedProjectIncome
     */
    activity_desc: string;
    /**
     * 
     * @type {number}
     * @memberof ComputedProjectIncome
     */
    order_id: number;
    /**
     * 
     * @type {Date}
     * @memberof ComputedProjectIncome
     */
    transaction_date: Date;
    /**
     * 
     * @type {number}
     * @memberof ComputedProjectIncome
     */
    amount: number;
}
/**
 * 
 * @export
 * @interface ComputedProjectTotalIncome
 */
export interface ComputedProjectTotalIncome {
    /**
     * 
     * @type {number}
     * @memberof ComputedProjectTotalIncome
     */
    project_id: number;
    /**
     * 
     * @type {number}
     * @memberof ComputedProjectTotalIncome
     */
    balance: number;
}
/**
 * 
 * @export
 * @interface Country
 */
export interface Country {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof Country
     */
    id: number;
    /**
     * its human readable identifier
     * @type {string}
     * @memberof Country
     */
    name: string;
    /**
     * the 2 character iso code
     * @type {string}
     * @memberof Country
     */
    isocode2: string;
    /**
     * the 3 character iso code
     * @type {string}
     * @memberof Country
     */
    isocode3: string;
    /**
     * the telephone system country code prefix
     * @type {string}
     * @memberof Country
     */
    telephone_prefix: string;
    /**
     * 
     * @type {number}
     * @memberof Country
     */
    region_id: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof Country
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof Country
     */
    last_changed_by_id: number;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof Country
     */
    updatetime: Date;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof Country
     */
    createtime: Date;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_TO_COUNTRIES and described as: 
     * @type {Array<AllUser>}
     * @memberof Country
     */
    all_users_to_countries: Array<AllUser>;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_TO_MCOUNTRIES and described as: 
     * @type {Array<AllUser>}
     * @memberof Country
     */
    all_users_to_mcountries: Array<AllUser>;
    /**
     * This was created from the details of the foreign key FK_COUNTRIES_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof Country
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_PROJECTS_COUNTRY_ID_PROJECTS and described as: 
     * @type {Array<Project>}
     * @memberof Country
     */
    projects: Array<Project>;
    /**
     * This was created from the details of the foreign key FK_PROVINCES_TO_COUNTRIES and described as: 
     * @type {Array<Province>}
     * @memberof Country
     */
    provinces_to_countries: Array<Province>;
    /**
     * This was created from the details of the foreign key FK_USERS_ENTITY_COUNTRY_ID_INVESTOR_COMPANIES and described as: 
     * @type {Array<UserEntity>}
     * @memberof Country
     */
    investor_companies: Array<UserEntity>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_COUNTRY_ID and described as: 
     * @type {Array<UserSocialProfile>}
     * @memberof Country
     */
    users_socialprofile_country_id: Array<UserSocialProfile>;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof Event
     */
    id: number;
    /**
     * coded value about what kind of event has occured
     * @type {string}
     * @memberof Event
     */
    type: string;
    /**
     * the user the event relates to
     * @type {number}
     * @memberof Event
     */
    user_id: number;
    /**
     * the social profile of the organization that sponsors the project that this event releates to
     * @type {number}
     * @memberof Event
     */
    issuer_id: number;
    /**
     * the project this event relates to
     * @type {number}
     * @memberof Event
     */
    project_id: number;
    /**
     * the financial transaction that this relates to
     * @type {number}
     * @memberof Event
     */
    investment_transaction_id: number;
    /**
     * the id of the order that this relates to
     * @type {number}
     * @memberof Event
     */
    investment_order_id: number;
    /**
     * the id of the withdrawel this relates to
     * @type {number}
     * @memberof Event
     */
    investment_withdrawel_id: number;
    /**
     * the id of the earnings this relates to
     * @type {number}
     * @memberof Event
     */
    investor_earning_id: number;
    /**
     * 
     * @type {number}
     * @memberof Event
     */
    user_pdf_id: number;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    additional: string;
    /**
     * if true (1), the webhooks have been executed for this event
     * @type {boolean}
     * @memberof Event
     */
    webhooks_fired: boolean;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof Event
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof Event
     */
    last_changed_by_id: number;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof Event
     */
    updatetime: Date;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof Event
     */
    createtime: Date;
    /**
     * This was created from the details of the foreign key FK_EVENTS_TO_INVESTMENT_ORDER and described as: 
     * @type {InvestmentOrder}
     * @memberof Event
     */
    investment_order: InvestmentOrder;
    /**
     * This was created from the details of the foreign key FK_EVENTS_TO_INVESTMENT_TRANSACTION and described as: 
     * @type {InvestmentTransaction}
     * @memberof Event
     */
    investment_transaction: InvestmentTransaction;
    /**
     * This was created from the details of the foreign key FK_EVENTS_TO_INVESTMENT_WITHDRAWEL and described as: 
     * @type {InvestmentWithdrawal}
     * @memberof Event
     */
    investment_withdrawel: InvestmentWithdrawal;
    /**
     * This was created from the details of the foreign key FK_EVENTS_TO_INVESTOR_EARNINGS and described as: 
     * @type {InvestorEarning}
     * @memberof Event
     */
    investor_earning: InvestorEarning;
    /**
     * This was created from the details of the foreign key FK_EVENTS_TO_ISSUER and described as: 
     * @type {UserSocialProfile}
     * @memberof Event
     */
    issuer: UserSocialProfile;
    /**
     * This was created from the details of the foreign key FK_EVENTS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof Event
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key EVENTS_PROJECT and described as: 
     * @type {Project}
     * @memberof Event
     */
    project: Project;
    /**
     * This was created from the details of the foreign key FK_EVENTS_TO_USER and described as: 
     * @type {AllUser}
     * @memberof Event
     */
    user: AllUser;
    /**
     * This was created from the details of the foreign key FK_EVENTS_TO_USERS_PDF and described as: 
     * @type {UserPdf}
     * @memberof Event
     */
    user_pdf: UserPdf;
}
/**
 * 
 * @export
 * @interface ExemptDistributionOption
 */
export interface ExemptDistributionOption {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof ExemptDistributionOption
     */
    id: number;
    /**
     * the type of option it is
     * @type {number}
     * @memberof ExemptDistributionOption
     */
    category: number;
    /**
     * a short code denotig the option
     * @type {string}
     * @memberof ExemptDistributionOption
     */
    code: string;
    /**
     * a more verbose description of the option
     * @type {string}
     * @memberof ExemptDistributionOption
     */
    detail: string;
    /**
     * the ordinal position of the item in a list of these items
     * @type {number}
     * @memberof ExemptDistributionOption
     */
    sort_order: number;
    /**
     * if true, the item is no longer active and should not be used
     * @type {boolean}
     * @memberof ExemptDistributionOption
     */
    inactive: boolean;
    /**
     * the name of the item this row, and others, are regional variations of
     * @type {string}
     * @memberof ExemptDistributionOption
     */
    regional_variation_of: string;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof ExemptDistributionOption
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof ExemptDistributionOption
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof ExemptDistributionOption
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof ExemptDistributionOption
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_PROJECT_ROED_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof ExemptDistributionOption
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_PROJECTS_ROED_SECURITYCODE_PROJECTS and described as: 
     * @type {Array<Project>}
     * @memberof ExemptDistributionOption
     */
    projects: Array<Project>;
}
/**
 * 
 * @export
 * @interface FfbaAssociation
 */
export interface FfbaAssociation {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof FfbaAssociation
     */
    id: number;
    /**
     * the foreign ID of the user side of this relationship
     * @type {number}
     * @memberof FfbaAssociation
     */
    user_id: number;
    /**
     * the foreign ID of the project side of this relationship
     * @type {number}
     * @memberof FfbaAssociation
     */
    project_id: number;
    /**
     * the foreign ID of the entity this relationship extends through, if relevant
     * @type {number}
     * @memberof FfbaAssociation
     */
    entity_id: number;
    /**
     * if true, the user is a director at the issuer
     * @type {boolean}
     * @memberof FfbaAssociation
     */
    is_director: boolean;
    /**
     * if true, the user is an executive officer at the issuer
     * @type {boolean}
     * @memberof FfbaAssociation
     */
    is_executive_officer: boolean;
    /**
     * if true, the user is a control person at the issuer
     * @type {boolean}
     * @memberof FfbaAssociation
     */
    is_control_person: boolean;
    /**
     * if true, the user is a founder of the issuer
     * @type {boolean}
     * @memberof FfbaAssociation
     */
    is_founder: boolean;
    /**
     * if true, the user is a family member of a contact at the issuer
     * @type {boolean}
     * @memberof FfbaAssociation
     */
    is_family_member: boolean;
    /**
     * if true, the user is a close personal friend of a contact at the issuer
     * @type {boolean}
     * @memberof FfbaAssociation
     */
    is_friend: boolean;
    /**
     * if true, the user is a close business associate of a contact at the issuer
     * @type {boolean}
     * @memberof FfbaAssociation
     */
    is_associate: boolean;
    /**
     * the first name of the users contact at the issuer
     * @type {string}
     * @memberof FfbaAssociation
     */
    contact_first_name: string;
    /**
     * the last name of the users contact at the issuer
     * @type {string}
     * @memberof FfbaAssociation
     */
    contact_last_name: string;
    /**
     * the position of the users contact at the issuer
     * @type {string}
     * @memberof FfbaAssociation
     */
    contact_position: string;
    /**
     * the familial relationship the user has with their contact at the issuer
     * @type {string}
     * @memberof FfbaAssociation
     */
    contact_relationship: string;
    /**
     * the number of years the user has known their contact at the issuer
     * @type {number}
     * @memberof FfbaAssociation
     */
    contact_years_known: number;
    /**
     * the email address of the users contact at the issuer
     * @type {string}
     * @memberof FfbaAssociation
     */
    contact_email: string;
    /**
     * the phone number of the users contact at the issuer
     * @type {string}
     * @memberof FfbaAssociation
     */
    contact_phone: string;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof FfbaAssociation
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof FfbaAssociation
     */
    last_changed_by_id: number;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof FfbaAssociation
     */
    updatetime: Date;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof FfbaAssociation
     */
    createtime: Date;
    /**
     * This was created from the details of the foreign key FK_FFBA_ASSOCIATION_TO_USER_ENTITY and described as: 
     * @type {UserEntity}
     * @memberof FfbaAssociation
     */
    entity: UserEntity;
    /**
     * This was created from the details of the foreign key FK_FFBA_ASSOCIATION_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof FfbaAssociation
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_FFBA_ASSOCIATION_TO_PROJECT and described as: 
     * @type {Project}
     * @memberof FfbaAssociation
     */
    project: Project;
    /**
     * This was created from the details of the foreign key FK_FFBA_ASSOCIATION_TO_USER and described as: 
     * @type {AllUser}
     * @memberof FfbaAssociation
     */
    user: AllUser;
}
/**
 * 
 * @export
 * @interface ImportedContact
 */
export interface ImportedContact {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof ImportedContact
     */
    id: number;
    /**
     * the user that imported the contact
     * @type {number}
     * @memberof ImportedContact
     */
    user_id: number;
    /**
     * the name of the system or service that the contacts were received from
     * @type {string}
     * @memberof ImportedContact
     */
    source: string;
    /**
     * the list of contacts exactly as the source system provided them in json
     * @type {string}
     * @memberof ImportedContact
     */
    contact_as_original_json: string;
    /**
     * the imported list of contacts adjusted for local user in json format
     * @type {string}
     * @memberof ImportedContact
     */
    contact_as_json: string;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof ImportedContact
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof ImportedContact
     */
    last_changed_by_id: number;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof ImportedContact
     */
    updatetime: Date;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof ImportedContact
     */
    createtime: Date;
    /**
     * This was created from the details of the foreign key FK_IMPORTED_CONTACTS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof ImportedContact
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_IMPORTED_CONTACTS_USER_ID_CONTACTS and described as: 
     * @type {AllUser}
     * @memberof ImportedContact
     */
    user: AllUser;
}
/**
 * 
 * @export
 * @interface InvestmentOrder
 */
export interface InvestmentOrder {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof InvestmentOrder
     */
    id: number;
    /**
     * the type of entity that is making the purchase (UserBenficiary, UserCorporation, UserTrust)
     * @type {number}
     * @memberof InvestmentOrder
     */
    entity_type: number;
    /**
     * the id of the entity that is making the purchase. md5 of the pk value for one of UserBenficiary, UserCorporation, UserTrust
     * @type {string}
     * @memberof InvestmentOrder
     */
    entity_id: string;
    /**
     * the id of the entity that is making the purchase. pk value for one of UserBenficiary, UserCorporation, UserTrust
     * @type {number}
     * @memberof InvestmentOrder
     */
    user_entity_id: number;
    /**
     * the fundscraper legal identifier for the order
     * @type {string}
     * @memberof InvestmentOrder
     */
    order_no: string;
    /**
     * the listed price of the shares at the time of the order
     * @type {number}
     * @memberof InvestmentOrder
     */
    share_price: number;
    /**
     * the number of shares that were ordered
     * @type {number}
     * @memberof InvestmentOrder
     */
    number_of_shares: number;
    /**
     * the total amount of the order
     * @type {number}
     * @memberof InvestmentOrder
     */
    total_amount: number;
    /**
     * have the acknowledgements been completed?
     * @type {boolean}
     * @memberof InvestmentOrder
     */
    acknowledgements: boolean;
    /**
     * have the documents been completed with docusign
     * @type {boolean}
     * @memberof InvestmentOrder
     */
    docusign: boolean;
    /**
     * the name of the file that holds the document
     * @type {string}
     * @memberof InvestmentOrder
     */
    document_name: string;
    /**
     * the GUID Docusign uses to identify the document the user completed
     * @type {string}
     * @memberof InvestmentOrder
     */
    docusign_guid: string;
    /**
     * the SHA256 hash of the data merged into the document identified by docusign_guid
     * @type {string}
     * @memberof InvestmentOrder
     */
    docusign_merge_hash: string;
    /**
     * the state of the payment for the order
     * @type {number}
     * @memberof InvestmentOrder
     */
    payment: number;
    /**
     * the exemption that the investor qualified with at the time the order was stated
     * @type {number}
     * @memberof InvestmentOrder
     */
    roed_at_initiation: number;
    /**
     * the mechanism that will be used to provide the payment
     * @type {number}
     * @memberof InvestmentOrder
     */
    payment_mode: number;
    /**
     * the foreign ID of the payment_method used for this order
     * @type {number}
     * @memberof InvestmentOrder
     */
    payment_method_id: number;
    /**
     * the foreign ID of the investment_withdrawal associated with this order, if one exists
     * @type {number}
     * @memberof InvestmentOrder
     */
    investment_withdrawal_id: number;
    /**
     * the foreign ID of the users_banking_details to send distributions related to this order to, if one exists
     * @type {number}
     * @memberof InvestmentOrder
     */
    distributions_to_id: number;
    /**
     * the foreign ID of the users_banking_details to draw payments related to this order from, if one exists
     * @type {number}
     * @memberof InvestmentOrder
     */
    payments_from_id: number;
    /**
     * the schedule 1 it is reported on?
     * @type {number}
     * @memberof InvestmentOrder
     */
    roed_schedule1_id: number;
    /**
     * if true, the order has been confirmed
     * @type {boolean}
     * @memberof InvestmentOrder
     */
    order_confirm: boolean;
    /**
     * if true, the project has a DRIP and the user has chosen to register in it
     * @type {boolean}
     * @memberof InvestmentOrder
     */
    drip_registered: boolean;
    /**
     * if true, the project allows use of the NI 45-106 2.12 asset acquisition exemption and the user has indicated they are using it
     * @type {boolean}
     * @memberof InvestmentOrder
     */
    acquiring_with_assets: boolean;
    /**
     * can only be true if acquiring_with_assets is, indicates that the total amount of assets involved (potentially split over multiple orders) is 150K+
     * @type {boolean}
     * @memberof InvestmentOrder
     */
    total_assets_150_k: boolean;
    /**
     * true if the user indicates they are transferring funds or other assets from a different registered account to fund this purchase
     * @type {boolean}
     * @memberof InvestmentOrder
     */
    transferring_assets: boolean;
    /**
     * true if the user indicates they are transferring funds (transferring_assets) in whole, false if in part
     * @type {boolean}
     * @memberof InvestmentOrder
     */
    transfer_whole_or_part: boolean;
    /**
     * the status of creating this in hubspot. 0 &#x3D; nothing, 1 &#x3D; request sent, 2 &#x3D; completed
     * @type {number}
     * @memberof InvestmentOrder
     */
    hubspot_creation: number;
    /**
     * the id of the deal in hubspot that matches this order
     * @type {string}
     * @memberof InvestmentOrder
     */
    hubspot_dealid: string;
    /**
     * the identifier for an esrow of funds
     * @type {string}
     * @memberof InvestmentOrder
     */
    escrow_no: string;
    /**
     * the identifier of an escrow settling
     * @type {string}
     * @memberof InvestmentOrder
     */
    escrow_settled_no: string;
    /**
     * the identifier for a refund
     * @type {string}
     * @memberof InvestmentOrder
     */
    refund_no: string;
    /**
     * the verification identifier for a refund
     * @type {string}
     * @memberof InvestmentOrder
     */
    refund_settled_no: string;
    /**
     * the identification for a transfer
     * @type {string}
     * @memberof InvestmentOrder
     */
    transfer_no: string;
    /**
     * the name of the trust company associated with the project that the user has indicated they have an existing account with
     * @type {string}
     * @memberof InvestmentOrder
     */
    trust_company_name: string;
    /**
     * the number of the existing account the user has with the trust company indicated in trust_company_name
     * @type {string}
     * @memberof InvestmentOrder
     */
    trust_company_account_no: string;
    /**
     * the final price per share that the oder was processed with
     * @type {number}
     * @memberof InvestmentOrder
     */
    sale_price: number;
    /**
     * the commision rate the agent will receive
     * @type {number}
     * @memberof InvestmentOrder
     */
    agent_comm: number;
    /**
     * the current degree of completion
     * @type {number}
     * @memberof InvestmentOrder
     */
    status: number;
    /**
     * the id of the project that the security is for
     * @type {number}
     * @memberof InvestmentOrder
     */
    project_id: number;
    /**
     * the id of the organization that issued the security
     * @type {number}
     * @memberof InvestmentOrder
     */
    issuer_id: number;
    /**
     * the user that the order is for
     * @type {number}
     * @memberof InvestmentOrder
     */
    user_id: number;
    /**
     * the FFBA association relevant to this order
     * @type {number}
     * @memberof InvestmentOrder
     */
    ffba_id: number;
    /**
     * the joint subsciber associated with this order
     * @type {number}
     * @memberof InvestmentOrder
     */
    joint_subscriber_id: number;
    /**
     * the row number in the filed roed report that this order matches to
     * @type {number}
     * @memberof InvestmentOrder
     */
    filed_roed_row_match: number;
    /**
     * the date the order was placed
     * @type {Date}
     * @memberof InvestmentOrder
     */
    order_date: Date;
    /**
     * the date the documents were signed with docusign
     * @type {Date}
     * @memberof InvestmentOrder
     */
    docusign_date: Date;
    /**
     * the date an escrow was recorded
     * @type {Date}
     * @memberof InvestmentOrder
     */
    escrow_date: Date;
    /**
     * the effective date of a transfer
     * @type {Date}
     * @memberof InvestmentOrder
     */
    transfer_date: Date;
    /**
     * the date a transfer settled
     * @type {Date}
     * @memberof InvestmentOrder
     */
    transfer_settled_date: Date;
    /**
     * the date an escrow settled
     * @type {Date}
     * @memberof InvestmentOrder
     */
    escrow_settled_date: Date;
    /**
     * the date a refund was settled
     * @type {Date}
     * @memberof InvestmentOrder
     */
    refund_settled_date: Date;
    /**
     * the date a refund was recorded
     * @type {Date}
     * @memberof InvestmentOrder
     */
    refund_date: Date;
    /**
     * the date of the sale
     * @type {Date}
     * @memberof InvestmentOrder
     */
    sell_date: Date;
    /**
     * the date of the trade
     * @type {Date}
     * @memberof InvestmentOrder
     */
    trade_date: Date;
    /**
     * the date that the trade is expected to occur
     * @type {Date}
     * @memberof InvestmentOrder
     */
    estimated_trade_date: Date;
    /**
     * the id of the old order in a transfer
     * @type {number}
     * @memberof InvestmentOrder
     */
    transfer_old_id: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof InvestmentOrder
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof InvestmentOrder
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof InvestmentOrder
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof InvestmentOrder
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_EVENTS_TO_INVESTMENT_ORDER and described as: 
     * @type {Array<Event>}
     * @memberof InvestmentOrder
     */
    events_to_investment_order: Array<Event>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_DISTRIBUTIONS_TO_ID and described as: 
     * @type {UserBankingDetails}
     * @memberof InvestmentOrder
     */
    distributions_to: UserBankingDetails;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_FFBA_ID and described as: 
     * @type {FfbaAssociation}
     * @memberof InvestmentOrder
     */
    ffba: FfbaAssociation;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_INVESTMENT_WITHDRAWAL_ID and described as: 
     * @type {InvestmentWithdrawal}
     * @memberof InvestmentOrder
     */
    investment_withdrawal: InvestmentWithdrawal;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_ISSUER_ID_ORDERS and described as: 
     * @type {UserSocialProfile}
     * @memberof InvestmentOrder
     */
    issuer: UserSocialProfile;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_JOINT_SUBSCRIBER_TO_USER and described as: 
     * @type {AllUser}
     * @memberof InvestmentOrder
     */
    joint_subscriber: AllUser;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof InvestmentOrder
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_PAYMENT_METHOD_ID and described as: 
     * @type {ProjectAccount}
     * @memberof InvestmentOrder
     */
    payment_method: ProjectAccount;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_PAYMENTS_FROM_ID and described as: 
     * @type {UserBankingDetails}
     * @memberof InvestmentOrder
     */
    payments_from: UserBankingDetails;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_PROJECT_ID_ORDERS and described as: 
     * @type {Project}
     * @memberof InvestmentOrder
     */
    project: Project;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_ROED_SCHEDULE1_ID_ORDERS and described as: 
     * @type {RoedSchedule1}
     * @memberof InvestmentOrder
     */
    roed_schedule1: RoedSchedule1;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_TRANSFER_OLD_ID and described as: 
     * @type {InvestmentOrder}
     * @memberof InvestmentOrder
     */
    transfer_old: InvestmentOrder;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_USER_ENTITY_ID and described as: 
     * @type {UserEntity}
     * @memberof InvestmentOrder
     */
    user_entity: UserEntity;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_USER_ID_ORDERS and described as: 
     * @type {AllUser}
     * @memberof InvestmentOrder
     */
    user: AllUser;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_WITHDRAWAL_HEAD_TO_INVESTMENT_ORDERS and described as: 
     * @type {Array<InvestmentWithdrawal>}
     * @memberof InvestmentOrder
     */
    investment_withdrawal_head_to_investment_orders: Array<InvestmentWithdrawal>;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_ACK_ORDERS_ORDER_ID_ACKNOWLEDGEMENT_DETAILS and described as: 
     * @type {Array<OrderAcknowledgement>}
     * @memberof InvestmentOrder
     */
    acknowledgement_details: Array<OrderAcknowledgement>;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_EARNINGS_ORDER_ID_ADJUSTMENTS and described as: 
     * @type {Array<InvestorEarning>}
     * @memberof InvestmentOrder
     */
    adjustments: Array<InvestorEarning>;
    /**
     * This was created from the details of the foreign key FK_USERS_PDF_ORDER_ID_PDFS and described as: 
     * @type {Array<UserPdf>}
     * @memberof InvestmentOrder
     */
    pdfs: Array<UserPdf>;
}
/**
 * 
 * @export
 * @interface InvestmentTransaction
 */
export interface InvestmentTransaction {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof InvestmentTransaction
     */
    id: number;
    /**
     * the type of account the transaction was made against
     * @type {number}
     * @memberof InvestmentTransaction
     */
    entity_type: number;
    /**
     * md5 of the identifier of the account the transaction was against
     * @type {string}
     * @memberof InvestmentTransaction
     */
    entity_id: string;
    /**
     * the identifier of the account the transaction was against
     * @type {number}
     * @memberof InvestmentTransaction
     */
    user_entity_id: number;
    /**
     * the human identifier of the order
     * @type {string}
     * @memberof InvestmentTransaction
     */
    order_no: string;
    /**
     * the identifier of the order
     * @type {number}
     * @memberof InvestmentTransaction
     */
    order_id: number;
    /**
     * the type of activity that occured
     * @type {number}
     * @memberof InvestmentTransaction
     */
    activity: number;
    /**
     * a terse sentence describing the action
     * @type {string}
     * @memberof InvestmentTransaction
     */
    activity_desc: string;
    /**
     * the number of shares that transacted
     * @type {number}
     * @memberof InvestmentTransaction
     */
    number_of_shares: number;
    /**
     * the CAD dollar value per share
     * @type {number}
     * @memberof InvestmentTransaction
     */
    amount_per_share: number;
    /**
     * the amount credited to the account
     * @type {number}
     * @memberof InvestmentTransaction
     */
    credit: number;
    /**
     * the amount debited against the account
     * @type {number}
     * @memberof InvestmentTransaction
     */
    debit: number;
    /**
     * is the transaction still valid?
     * @type {boolean}
     * @memberof InvestmentTransaction
     */
    is_cancelled: boolean;
    /**
     * the user who is the receiptient of the transaction
     * @type {number}
     * @memberof InvestmentTransaction
     */
    user_id: number;
    /**
     * the identifier of the project that the transaction was placed against
     * @type {number}
     * @memberof InvestmentTransaction
     */
    project_id: number;
    /**
     * the date of the order
     * @type {Date}
     * @memberof InvestmentTransaction
     */
    transaction_date: Date;
    /**
     * the name of the eft file this transaction was sent in
     * @type {string}
     * @memberof InvestmentTransaction
     */
    eft_file: string;
    /**
     * the identifier of the investor_earning this transaction was created as part of, if any
     * @type {number}
     * @memberof InvestmentTransaction
     */
    investor_earning_id: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof InvestmentTransaction
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof InvestmentTransaction
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof InvestmentTransaction
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof InvestmentTransaction
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_EVENTS_TO_INVESTMENT_TRANSACTION and described as: 
     * @type {Array<Event>}
     * @memberof InvestmentTransaction
     */
    events_to_investment_transaction: Array<Event>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_TRANSACTION_INVESTOR_EARNING_ID and described as: 
     * @type {InvestorEarning}
     * @memberof InvestmentTransaction
     */
    investor_earning: InvestorEarning;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_TRANSACTION_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof InvestmentTransaction
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_TRANSACTION_ORDER_ID and described as: 
     * @type {InvestmentOrder}
     * @memberof InvestmentTransaction
     */
    order: InvestmentOrder;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_TRANSACTION_PROJECT_ID_TRANSACTIONS and described as: 
     * @type {Project}
     * @memberof InvestmentTransaction
     */
    project: Project;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_TRANSACTION_USER_ENTITY_ID and described as: 
     * @type {UserEntity}
     * @memberof InvestmentTransaction
     */
    user_entity: UserEntity;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_TRANSACTION_USER_ID_TRANSACTIONS and described as: 
     * @type {AllUser}
     * @memberof InvestmentTransaction
     */
    user: AllUser;
}
/**
 * 
 * @export
 * @interface InvestmentWatchlist
 */
export interface InvestmentWatchlist {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof InvestmentWatchlist
     */
    id: number;
    /**
     * the user that is watching
     * @type {number}
     * @memberof InvestmentWatchlist
     */
    user_id: number;
    /**
     * the id of the project that is being watched
     * @type {number}
     * @memberof InvestmentWatchlist
     */
    project_id: number;
    /**
     * true if the user has been notified of 20% being placed
     * @type {boolean}
     * @memberof InvestmentWatchlist
     */
    at20: boolean;
    /**
     * true if the user has been notified of 20% being placed
     * @type {boolean}
     * @memberof InvestmentWatchlist
     */
    at40: boolean;
    /**
     * true if the user has been notified of 40% being placed
     * @type {boolean}
     * @memberof InvestmentWatchlist
     */
    at60: boolean;
    /**
     *  true if the user has been notified of 60% being placed
     * @type {boolean}
     * @memberof InvestmentWatchlist
     */
    at80: boolean;
    /**
     * true if the user has been notified of 80% being placed
     * @type {boolean}
     * @memberof InvestmentWatchlist
     */
    at100: boolean;
    /**
     * if true, its an active watch otherwise its disabled
     * @type {boolean}
     * @memberof InvestmentWatchlist
     */
    in_active: boolean;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof InvestmentWatchlist
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof InvestmentWatchlist
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof InvestmentWatchlist
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof InvestmentWatchlist
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_WATCHLIST_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof InvestmentWatchlist
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_WATCHLIST_PROJECT_ID_WATCHES and described as: 
     * @type {Project}
     * @memberof InvestmentWatchlist
     */
    project: Project;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_WATCHLIST_USER_ID_WATCHES and described as: 
     * @type {AllUser}
     * @memberof InvestmentWatchlist
     */
    user: AllUser;
}
/**
 * 
 * @export
 * @interface InvestmentWithdrawal
 */
export interface InvestmentWithdrawal {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof InvestmentWithdrawal
     */
    id: number;
    /**
     * the id of the order for the withdrawel
     * @type {number}
     * @memberof InvestmentWithdrawal
     */
    order_id: number;
    /**
     * the amount to withdraw (may not be identical to the order amount)
     * @type {number}
     * @memberof InvestmentWithdrawal
     */
    amount: number;
    /**
     * the name of the bank
     * @type {string}
     * @memberof InvestmentWithdrawal
     */
    bank_name: string;
    /**
     * the id number of the bank
     * @type {string}
     * @memberof InvestmentWithdrawal
     */
    bank_institution_number: string;
    /**
     * the transit number of the bank
     * @type {string}
     * @memberof InvestmentWithdrawal
     */
    bank_transit: string;
    /**
     * the account number to put the funds into
     * @type {string}
     * @memberof InvestmentWithdrawal
     */
    bank_account_number: string;
    /**
     * the address of the bank to send it to
     * @type {string}
     * @memberof InvestmentWithdrawal
     */
    bank_address: string;
    /**
     * the province of the bank to send it to
     * @type {number}
     * @memberof InvestmentWithdrawal
     */
    bank_province_id: number;
    /**
     * the city of the bank to send it to
     * @type {string}
     * @memberof InvestmentWithdrawal
     */
    bank_city: string;
    /**
     * the postal code of the bank to send it to
     * @type {string}
     * @memberof InvestmentWithdrawal
     */
    bank_postal_code: string;
    /**
     * the contact telephone number of the bank to send the funds to
     * @type {string}
     * @memberof InvestmentWithdrawal
     */
    bank_telephone: string;
    /**
     * the number of times to execute the withdrawel
     * @type {number}
     * @memberof InvestmentWithdrawal
     */
    number_of_withdrawels: number;
    /**
     * unused
     * @type {number}
     * @memberof InvestmentWithdrawal
     */
    status: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof InvestmentWithdrawal
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof InvestmentWithdrawal
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof InvestmentWithdrawal
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof InvestmentWithdrawal
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_EVENTS_TO_INVESTMENT_WITHDRAWEL and described as: 
     * @type {Array<Event>}
     * @memberof InvestmentWithdrawal
     */
    events_to_investment_withdrawel: Array<Event>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_WITHDRAWAL_TO_PROVINCE and described as: 
     * @type {Province}
     * @memberof InvestmentWithdrawal
     */
    bank_province: Province;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_WITHDRAWAL_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof InvestmentWithdrawal
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_WITHDRAWAL_HEAD_TO_INVESTMENT_ORDERS and described as: 
     * @type {InvestmentOrder}
     * @memberof InvestmentWithdrawal
     */
    order: InvestmentOrder;
}
/**
 * 
 * @export
 * @interface Investor
 */
export interface Investor {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof Investor
     */
    id: number;
    /**
     * the category of user this is (i&#x3D;investor, a&#x3D;admin, c&#x3D;issuer admin)
     * @type {string}
     * @memberof Investor
     */
    user_type: string;
    /**
     * the first name of the person who uses the account
     * @type {string}
     * @memberof Investor
     */
    first_name: string;
    /**
     * the last name of the person who uses the account
     * @type {string}
     * @memberof Investor
     */
    last_name: string;
    /**
     * the name of the file that holds the avatars picture. this is the resouce relative, not site relative.
     * @type {string}
     * @memberof Investor
     */
    avatar_image_file_name: string;
    /**
     * the email address that identifies the account
     * @type {string}
     * @memberof Investor
     */
    email: string;
    /**
     * the last point in time the user logged in
     * @type {Date}
     * @memberof Investor
     */
    last_login: Date;
    /**
     * the last ip that they used to access the site from
     * @type {string}
     * @memberof Investor
     */
    last_ip: string;
    /**
     * the name of the service that verifies the identity of the user (according to azure b2c))
     * @type {string}
     * @memberof Investor
     */
    identity_provider: string;
    /**
     * the identifier for the user in the b2c system
     * @type {string}
     * @memberof Investor
     */
    user_principle_name: string;
    /**
     * json format values that are used by applications as preferences
     * @type {string}
     * @memberof Investor
     */
    preferences_as_json: string;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof Investor
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof Investor
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof Investor
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof Investor
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_COBRANDED_TO_SOCIAL_PROFILE and described as: 
     * @type {UserSocialProfile}
     * @memberof Investor
     */
    cobranded_client_of: UserSocialProfile;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_TO_COUNTRIES and described as: 
     * @type {Country}
     * @memberof Investor
     */
    country: Country;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof Investor
     */
    last_changed_by: AllUser;
    /**
     * 
     * @type {Array<WebHook>}
     * @memberof Investor
     */
    changes: Array<WebHook>;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_TO_MCOUNTRIES and described as: 
     * @type {Country}
     * @memberof Investor
     */
    mailing_country: Country;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_TO_MPROVINCES and described as: 
     * @type {Province}
     * @memberof Investor
     */
    mailing_province: Province;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_TO_PROVINCE and described as: 
     * @type {Province}
     * @memberof Investor
     */
    province: Province;
    /**
     * This was created from the details of the foreign key FK_BACKGROUND_PROCESSS_LASTUSER_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {Array<BackgroundProcess>}
     * @memberof Investor
     */
    background_processs_lastuser_last_changed_by_id_changes: Array<BackgroundProcess>;
    /**
     * This was created from the details of the foreign key FK_EVENTS_TO_USER and described as: 
     * @type {Array<Event>}
     * @memberof Investor
     */
    events_to_user: Array<Event>;
    /**
     * This was created from the details of the foreign key FK_FFBA_ASSOCIATION_TO_USER and described as: 
     * @type {Array<FfbaAssociation>}
     * @memberof Investor
     */
    ffba_association_to_user: Array<FfbaAssociation>;
    /**
     * This was created from the details of the foreign key FK_IMPORTED_CONTACTS_USER_ID_CONTACTS and described as: 
     * @type {Array<ImportedContact>}
     * @memberof Investor
     */
    contacts: Array<ImportedContact>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_JOINT_SUBSCRIBER_TO_USER and described as: 
     * @type {Array<InvestmentOrder>}
     * @memberof Investor
     */
    investment_orders_joint_subscriber_to_user: Array<InvestmentOrder>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_USER_ID_ORDERS and described as: 
     * @type {Array<InvestmentOrder>}
     * @memberof Investor
     */
    orders: Array<InvestmentOrder>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_TRANSACTION_USER_ID_TRANSACTIONS and described as: 
     * @type {Array<InvestmentTransaction>}
     * @memberof Investor
     */
    transactions: Array<InvestmentTransaction>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_WATCHLIST_USER_ID_WATCHES and described as: 
     * @type {Array<InvestmentWatchlist>}
     * @memberof Investor
     */
    watches: Array<InvestmentWatchlist>;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_ACK_ORDERS_USER_ORDER_ACKNOWLEDGEMENTS and described as: 
     * @type {Array<OrderAcknowledgement>}
     * @memberof Investor
     */
    investor_ack_orders_user_order_acknowledgements: Array<OrderAcknowledgement>;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_EARNINGS_USER_D and described as: 
     * @type {Array<InvestorEarning>}
     * @memberof Investor
     */
    investor_earnings_user_d: Array<InvestorEarning>;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_INTENDED_TRADES_USER_ID_INTENDED_TRADES and described as: 
     * @type {Array<InvestorIntendedTrades>}
     * @memberof Investor
     */
    intended_trades: Array<InvestorIntendedTrades>;
    /**
     * This was created from the details of the foreign key FK_MAILS_FROM_ID_SENT_EMAILS and described as: 
     * @type {Array<Mail>}
     * @memberof Investor
     */
    sent_emails: Array<Mail>;
    /**
     * This was created from the details of the foreign key FK_MAILS_TO_ID_RECEIVED_EMAILS and described as: 
     * @type {Array<Mail>}
     * @memberof Investor
     */
    received_emails: Array<Mail>;
    /**
     * This was created from the details of the foreign key FK_MODULE_ACCESS_USER_ID_ACCESSIBLE_MODULES and described as: 
     * @type {Array<ModuleAccess>}
     * @memberof Investor
     */
    accessible_modules: Array<ModuleAccess>;
    /**
     * This was created from the details of the foreign key FK_PROJECT_TAX_REPORTS_USER_ID_TAX_REPORTS and described as: 
     * @type {Array<ProjectTaxReport>}
     * @memberof Investor
     */
    tax_reports: Array<ProjectTaxReport>;
    /**
     * This was created from the details of the foreign key FK_SUPPORT_ENGINEERS_USER_ID_OWNER_USER and described as: 
     * @type {Array<SupportEngineer>}
     * @memberof Investor
     */
    owner_user: Array<SupportEngineer>;
    /**
     * This was created from the details of the foreign key FK_USER_ISSUER_ASSOCIATIONS_TO_USER_ID_ISSUER_ASSOCIATIONS and described as: 
     * @type {Array<UserIssuerAssociation>}
     * @memberof Investor
     */
    user_issuer_associations_to_user_id_issuer_associations: Array<UserIssuerAssociation>;
    /**
     * This was created from the details of the foreign key FK_USER_RELATIONSHIP_TO_USER_1 and described as: 
     * @type {Array<UserRelationship>}
     * @memberof Investor
     */
    user_relationship_to_user_1: Array<UserRelationship>;
    /**
     * This was created from the details of the foreign key FK_USER_RELATIONSHIP_TO_USER_2 and described as: 
     * @type {Array<UserRelationship>}
     * @memberof Investor
     */
    user_relationship_to_user_2: Array<UserRelationship>;
    /**
     * This was created from the details of the foreign key FK_USERS_BANKING_DETAILS_TO_JOINT_USER and described as: 
     * @type {Array<UserBankingDetails>}
     * @memberof Investor
     */
    users_banking_details_to_joint_user: Array<UserBankingDetails>;
    /**
     * This was created from the details of the foreign key FK_USERS_BANKING_DETAILS_TO_USER and described as: 
     * @type {Array<UserBankingDetails>}
     * @memberof Investor
     */
    users_banking_details_to_user: Array<UserBankingDetails>;
    /**
     * This was created from the details of the foreign key FK_USERS_EMPLOYMENT_USER_ID_FINANCIAL_KYC and described as: 
     * @type {Array<UserFinancialKyc>}
     * @memberof Investor
     */
    financial_kyc: Array<UserFinancialKyc>;
    /**
     * This was created from the details of the foreign key FK_USERS_ENTITY_USER_ID_ENTITIES and described as: 
     * @type {Array<UserEntity>}
     * @memberof Investor
     */
    entities: Array<UserEntity>;
    /**
     * This was created from the details of the foreign key FK_USERS_INVITEE_USER_ID_INVITATIONS and described as: 
     * @type {Array<UserInvitation>}
     * @memberof Investor
     */
    invitations: Array<UserInvitation>;
    /**
     * This was created from the details of the foreign key FK_USERS_PDF_USER_ID_PDFS and described as: 
     * @type {Array<UserPdf>}
     * @memberof Investor
     */
    pdfs: Array<UserPdf>;
    /**
     * This was created from the details of the foreign key FK_USERS_QUESTIONARY_USER_ID_ANSWERS and described as: 
     * @type {Array<UserAnswer>}
     * @memberof Investor
     */
    answers: Array<UserAnswer>;
    /**
     * This was created from the details of the foreign key FK_USERS_REQUEST_USER_ID_REQUESTS and described as: 
     * @type {Array<UserRequest>}
     * @memberof Investor
     */
    requests: Array<UserRequest>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {Array<UserSocialProfile>}
     * @memberof Investor
     */
    users_socialprofile_last_changed_by_id_changes: Array<UserSocialProfile>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_USER_ID_PROFILES and described as: 
     * @type {Array<UserSocialProfile>}
     * @memberof Investor
     */
    users_socialprofile_user_id_profiles: Array<UserSocialProfile>;
    /**
     * This was created from the details of the foreign key FK_USERS_SUBSCRIBE_USER_ID_SUBSCRIPTIONS and described as: 
     * @type {Array<UserSubscription>}
     * @memberof Investor
     */
    subscriptions: Array<UserSubscription>;
    /**
     * This was created from the details of the foreign key FK_WEB_HOOKS_TO_USER and described as: 
     * @type {Array<WebHook>}
     * @memberof Investor
     */
    web_hooks_to_user: Array<WebHook>;
    /**
     * the unique id in hubspot for the contact that has a 1:1 relationship with this user
     * @type {string}
     * @memberof Investor
     */
    hubspot_vid: string;
    /**
     * true if the user or someone at fundscraper has verified their email address
     * @type {boolean}
     * @memberof Investor
     */
    email_verified_status: boolean;
    /**
     * the identifier the user uses on linked in
     * @type {string}
     * @memberof Investor
     */
    linkedin: string;
    /**
     * the identifier the user uses on facebook
     * @type {string}
     * @memberof Investor
     */
    facebook: string;
    /**
     * the identifier the user uses for googe social (deprecated)
     * @type {string}
     * @memberof Investor
     */
    google_address: string;
    /**
     * if the user is in a multi-unit building, the number/designation of that unit
     * @type {string}
     * @memberof Investor
     */
    apt_number: string;
    /**
     * the level of investment the user is capable of
     * @type {number}
     * @memberof Investor
     */
    actual_investment_level: number;
    /**
     * the level of investment the user proposed they are capable of
     * @type {number}
     * @memberof Investor
     */
    user_proposed_investment_level: number;
    /**
     * if true, they are taking an exemption for investment
     * @type {boolean}
     * @memberof Investor
     */
    exemption: boolean;
    /**
     * is the user eligibible for an exemption to exeed the limit?
     * @type {boolean}
     * @memberof Investor
     */
    eligible_exemption: boolean;
    /**
     * if true, send the user statements
     * @type {boolean}
     * @memberof Investor
     */
    statements_flag: boolean;
    /**
     * if true, admin has confirmed user KYC is accurate
     * @type {boolean}
     * @memberof Investor
     */
    kyc_confirmed: boolean;
    /**
     * if true, admin has confirmed user Equifax is accurate
     * @type {boolean}
     * @memberof Investor
     */
    equifax_confirmed: boolean;
    /**
     * if true, admin has confirmed user identity
     * @type {boolean}
     * @memberof Investor
     */
    identity_confirmed: boolean;
    /**
     * Yes if they are a citizen of canada
     * @type {string}
     * @memberof Investor
     */
    citizen: string;
    /**
     * Yes if they are a resident of canada
     * @type {string}
     * @memberof Investor
     */
    resident: string;
    /**
     * the street address of where the user lives
     * @type {string}
     * @memberof Investor
     */
    address: string;
    /**
     * the postal identifier of where the person lives
     * @type {string}
     * @memberof Investor
     */
    zip: string;
    /**
     * the name of the city the person lives in
     * @type {string}
     * @memberof Investor
     */
    city: string;
    /**
     * the id of the province the user lives in
     * @type {number}
     * @memberof Investor
     */
    province_id: number;
    /**
     * the street address of where to send mail to for the person
     * @type {string}
     * @memberof Investor
     */
    mailing_address: string;
    /**
     * the postal identifier to send mail to
     * @type {string}
     * @memberof Investor
     */
    mailing_zip: string;
    /**
     * the name of the city to send mail to
     * @type {string}
     * @memberof Investor
     */
    mailing_city: string;
    /**
     * if the user is in a multi-unit building, the number/designation of that unit
     * @type {string}
     * @memberof Investor
     */
    mailing_apt_number: string;
    /**
     * the persons government identifier for social services
     * @type {string}
     * @memberof Investor
     */
    sin: string;
    /**
     * the telephone number to use to contact the person at
     * @type {string}
     * @memberof Investor
     */
    phone: string;
    /**
     * the telephone number to use to contact the person at their place of work
     * @type {string}
     * @memberof Investor
     */
    workphone: string;
    /**
     * the telephone number of the persons primary residence
     * @type {string}
     * @memberof Investor
     */
    homephone: string;
    /**
     * the telephone number to use to fax documents to
     * @type {string}
     * @memberof Investor
     */
    fax: string;
    /**
     * the email address the person uses for work purposes
     * @type {string}
     * @memberof Investor
     */
    workemail: string;
    /**
     * the date of birth of the person
     * @type {string}
     * @memberof Investor
     */
    dob: string;
    /**
     * general notes about investments for the user
     * @type {string}
     * @memberof Investor
     */
    notes: string;
    /**
     * if true they are relying on section 2.3 of the legislation for exempt distributions
     * @type {string}
     * @memberof Investor
     */
    section_23: string;
    /**
     * if true they are relying on section 2.9 for exempt distributions
     * @type {string}
     * @memberof Investor
     */
    section_29: string;
    /**
     * are they a &quot;registrant&quot; for exempt distributions?
     * @type {string}
     * @memberof Investor
     */
    is_registrant: string;
    /**
     * a they a securities insider?
     * @type {string}
     * @memberof Investor
     */
    is_insider: string;
    /**
     * the full legal name of the person
     * @type {string}
     * @memberof Investor
     */
    legal_person: string;
    /**
     * the human readable number assigned by FS to identify the account
     * @type {string}
     * @memberof Investor
     */
    client_number: string;
    /**
     * the identifier for the marketing system that was responsible for originating the user
     * @type {string}
     * @memberof Investor
     */
    utm_source: string;
    /**
     * additional marketing origin information
     * @type {string}
     * @memberof Investor
     */
    utm_medium: string;
    /**
     * the marketing campiagn that originated the user
     * @type {string}
     * @memberof Investor
     */
    utm_campaign: string;
    /**
     * additional marketing origin information
     * @type {string}
     * @memberof Investor
     */
    utm_content: string;
    /**
     * additional marketing origin information
     * @type {string}
     * @memberof Investor
     */
    utm_term: string;
    /**
     * the avilability of the account for use
     * @type {number}
     * @memberof Investor
     */
    status: number;
    /**
     * if true, the user is actively attempting to suspend their account
     * @type {boolean}
     * @memberof Investor
     */
    suspend_request: boolean;
    /**
     * the id of the country the user lives in
     * @type {number}
     * @memberof Investor
     */
    country_id: number;
    /**
     * the id of the country to send mail to
     * @type {number}
     * @memberof Investor
     */
    mailing_country_id: number;
    /**
     * the id of the province to send mail to 
     * @type {number}
     * @memberof Investor
     */
    mailing_province_id: number;
    /**
     * the sponsor that essentially owns this investor
     * @type {number}
     * @memberof Investor
     */
    cobranded_client_of_id: number;
    /**
     * the amount of money fundscraper owes the user
     * @type {number}
     * @memberof Investor
     */
    balance: number;
    /**
     * a url that the investor can forward to friends for sign up in order to get a referral fee
     * @type {string}
     * @memberof Investor
     */
    referral_link: string;
    /**
     * the last point in time the user altered their account
     * @type {Date}
     * @memberof Investor
     */
    last_edit: Date;
    /**
     * the point in time the user first signed up
     * @type {Date}
     * @memberof Investor
     */
    signup_date: Date;
    /**
     * the url to the site that was the &quot;referrer&quot; when the user first signed up
     * @type {string}
     * @memberof Investor
     */
    referrer_site: string;
    /**
     * a marketing specified value used to connect the marketing program or source responible for signing up the user
     * @type {string}
     * @memberof Investor
     */
    referrer_attribution: string;
}
/**
 * 
 * @export
 * @interface InvestorCobranding
 */
export interface InvestorCobranding {
    /**
     * 
     * @type {number}
     * @memberof InvestorCobranding
     */
    user_id: number;
    /**
     * 
     * @type {number}
     * @memberof InvestorCobranding
     */
    primary_cobrander_id: number;
    /**
     * 
     * @type {string}
     * @memberof InvestorCobranding
     */
    primary_cobrander_name: string;
    /**
     * 
     * @type {string}
     * @memberof InvestorCobranding
     */
    cobrander_ids: string;
}
/**
 * 
 * @export
 * @interface InvestorEarning
 */
export interface InvestorEarning {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof InvestorEarning
     */
    id: number;
    /**
     * the id of project earnings that this is one portion of
     * @type {number}
     * @memberof InvestorEarning
     */
    project_earnings_id: number;
    /**
     * the id of the user that should receive these earnings
     * @type {number}
     * @memberof InvestorEarning
     */
    user_id: number;
    /**
     * the id of the project that the income/charges relate to
     * @type {number}
     * @memberof InvestorEarning
     */
    project_id: number;
    /**
     * the id of the order that the adjustment relates to
     * @type {number}
     * @memberof InvestorEarning
     */
    order_id: number;
    /**
     * the type of account the transaction was made against
     * @type {number}
     * @memberof InvestorEarning
     */
    entity_type: number;
    /**
     * md5 of the identifier of the account the transaction was against
     * @type {string}
     * @memberof InvestorEarning
     */
    entity_id: string;
    /**
     * the identifier of the account the transaction was against
     * @type {number}
     * @memberof InvestorEarning
     */
    user_entity_id: number;
    /**
     * the type of adjustment
     * @type {number}
     * @memberof InvestorEarning
     */
    type: number;
    /**
     * predetermined textual description of the type
     * @type {string}
     * @memberof InvestorEarning
     */
    category: string;
    /**
     * additional descriptive details of the action
     * @type {string}
     * @memberof InvestorEarning
     */
    description: string;
    /**
     * the amount of the adjustment
     * @type {number}
     * @memberof InvestorEarning
     */
    amount: number;
    /**
     * the date that the amount is expected to be applied
     * @type {Date}
     * @memberof InvestorEarning
     */
    transaction_date: Date;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof InvestorEarning
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof InvestorEarning
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof InvestorEarning
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof InvestorEarning
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_EVENTS_TO_INVESTOR_EARNINGS and described as: 
     * @type {Array<Event>}
     * @memberof InvestorEarning
     */
    events_to_investor_earnings: Array<Event>;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_EARNINGS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof InvestorEarning
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_EARNINGS_ORDER_ID_ADJUSTMENTS and described as: 
     * @type {InvestmentOrder}
     * @memberof InvestorEarning
     */
    order: InvestmentOrder;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_EARNINGS_PE_ID_INVESTOR_EARNINGS and described as: 
     * @type {ProjectBalanceAdjustment}
     * @memberof InvestorEarning
     */
    project_earnings: ProjectBalanceAdjustment;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_EARNINGS_PROJECT_ID_INVESTOR_EARNINGS and described as: 
     * @type {Project}
     * @memberof InvestorEarning
     */
    project: Project;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_EARNINGS_USER_ENTITY_ID_EARNINGS and described as: 
     * @type {UserEntity}
     * @memberof InvestorEarning
     */
    user_entity: UserEntity;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_EARNINGS_USER_D and described as: 
     * @type {AllUser}
     * @memberof InvestorEarning
     */
    user: AllUser;
}
/**
 * 
 * @export
 * @interface InvestorIntendedTrades
 */
export interface InvestorIntendedTrades {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof InvestorIntendedTrades
     */
    id: number;
    /**
     * the issuer the investor is intended to trade with
     * @type {number}
     * @memberof InvestorIntendedTrades
     */
    intended_issuer_id: number;
    /**
     * the investor this is for
     * @type {number}
     * @memberof InvestorIntendedTrades
     */
    user_id: number;
    /**
     * the investor intended trade amount
     * @type {number}
     * @memberof InvestorIntendedTrades
     */
    intended_trade_amount: number;
    /**
     * the investor intended trade date
     * @type {Date}
     * @memberof InvestorIntendedTrades
     */
    intended_trade_date: Date;
    /**
     * the notes for an investor intended trade
     * @type {string}
     * @memberof InvestorIntendedTrades
     */
    notes: string;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof InvestorIntendedTrades
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof InvestorIntendedTrades
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof InvestorIntendedTrades
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof InvestorIntendedTrades
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_INTENDED_TRADES_INTENDED_ISSUER_ID_INTENDED_TRADES and described as: 
     * @type {UserSocialProfile}
     * @memberof InvestorIntendedTrades
     */
    intended_issuer: UserSocialProfile;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_INTENDED_TRADES_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof InvestorIntendedTrades
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_INTENDED_TRADES_USER_ID_INTENDED_TRADES and described as: 
     * @type {AllUser}
     * @memberof InvestorIntendedTrades
     */
    user: AllUser;
}
/**
 * 
 * @export
 * @interface InvestorSocialProfile
 */
export interface InvestorSocialProfile {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof InvestorSocialProfile
     */
    id: number;
    /**
     * the user this is for
     * @type {number}
     * @memberof InvestorSocialProfile
     */
    user_id: number;
    /**
     * the name of the project the profile is for
     * @type {string}
     * @memberof InvestorSocialProfile
     */
    name: string;
    /**
     * a url to an image to use to represent the profile
     * @type {string}
     * @memberof InvestorSocialProfile
     */
    image: string;
    /**
     * a url to the facebook presence for the profile
     * @type {string}
     * @memberof InvestorSocialProfile
     */
    facebook: string;
    /**
     * a url to the twitter feed for the profile
     * @type {string}
     * @memberof InvestorSocialProfile
     */
    twitter: string;
    /**
     * a url to the linked in presence for the profile
     * @type {string}
     * @memberof InvestorSocialProfile
     */
    linkedin: string;
    /**
     * ?
     * @type {number}
     * @memberof InvestorSocialProfile
     */
    status: number;
    /**
     * for user profiles, if true the user should receive notification
     * @type {boolean}
     * @memberof InvestorSocialProfile
     */
    notification: boolean;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof InvestorSocialProfile
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof InvestorSocialProfile
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof InvestorSocialProfile
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof InvestorSocialProfile
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_COBRANDED_TO_SOCIAL_PROFILE and described as: 
     * @type {Array<AllUser>}
     * @memberof InvestorSocialProfile
     */
    all_users_cobranded_to_social_profile: Array<AllUser>;
    /**
     * This was created from the details of the foreign key FK_EVENTS_TO_ISSUER and described as: 
     * @type {Array<Event>}
     * @memberof InvestorSocialProfile
     */
    events_to_issuer: Array<Event>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_ISSUER_ID_ORDERS and described as: 
     * @type {Array<InvestmentOrder>}
     * @memberof InvestorSocialProfile
     */
    orders: Array<InvestmentOrder>;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_INTENDED_TRADES_INTENDED_ISSUER_ID_INTENDED_TRADES and described as: 
     * @type {Array<InvestorIntendedTrades>}
     * @memberof InvestorSocialProfile
     */
    intended_trades: Array<InvestorIntendedTrades>;
    /**
     * This was created from the details of the foreign key FK_PROJECTS_ISSUER_ID_PROJECTS and described as: 
     * @type {Array<Project>}
     * @memberof InvestorSocialProfile
     */
    projects: Array<Project>;
    /**
     * This was created from the details of the foreign key FK_PROPERTY_INTEREST_INTEREST_BY_ID_INTERESTS and described as: 
     * @type {Array<ProjectInterest>}
     * @memberof InvestorSocialProfile
     */
    interests: Array<ProjectInterest>;
    /**
     * This was created from the details of the foreign key FK_PROPERTY_INTEREST_INTEREST_IN_ID_INVESTOR_INTERESTS and described as: 
     * @type {Array<ProjectInterest>}
     * @memberof InvestorSocialProfile
     */
    investor_interests: Array<ProjectInterest>;
    /**
     * This was created from the details of the foreign key FK_USER_ISSUER_ASSOCIATIONS_TO_ISSUER_ID_ASSOCIATED_USERS and described as: 
     * @type {Array<UserIssuerAssociation>}
     * @memberof InvestorSocialProfile
     */
    user_issuer_associations_to_issuer_id_associated_users: Array<UserIssuerAssociation>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIAL_LINKUP_LINK_ID_FOLLOWERS and described as: 
     * @type {Array<SocialProfileFollowing>}
     * @memberof InvestorSocialProfile
     */
    followers: Array<SocialProfileFollowing>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIAL_LINKUP_PROFILE_ID_FOLLOWING and described as: 
     * @type {Array<SocialProfileFollowing>}
     * @memberof InvestorSocialProfile
     */
    following: Array<SocialProfileFollowing>;
    /**
     * 
     * @type {Array<UserSocialPost>}
     * @memberof InvestorSocialProfile
     */
    posts: Array<UserSocialPost>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_COUNTRY_ID and described as: 
     * @type {Country}
     * @memberof InvestorSocialProfile
     */
    country: Country;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_JURISDICTION_ID_PROFILES and described as: 
     * @type {Province}
     * @memberof InvestorSocialProfile
     */
    jurisdiction: Province;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof InvestorSocialProfile
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_PROJECT_ID_PROFILES and described as: 
     * @type {Project}
     * @memberof InvestorSocialProfile
     */
    project: Project;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_PROVINCE_ID and described as: 
     * @type {Province}
     * @memberof InvestorSocialProfile
     */
    province: Province;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_STATUTE_ID_TO_PROVINCES and described as: 
     * @type {Province}
     * @memberof InvestorSocialProfile
     */
    statute: Province;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_USER_ID_PROFILES and described as: 
     * @type {AllUser}
     * @memberof InvestorSocialProfile
     */
    user: AllUser;
    /**
     * This was created from the details of the foreign key FK_WEB_HOOKS_TO_ISSUER and described as: 
     * @type {Array<WebHook>}
     * @memberof InvestorSocialProfile
     */
    web_hooks_to_issuer: Array<WebHook>;
    /**
     * ?
     * @type {number}
     * @memberof InvestorSocialProfile
     */
    profile_type: number;
    /**
     * the id of the sub-national region that the project must comply to for compliance
     * @type {number}
     * @memberof InvestorSocialProfile
     */
    statute_id: number;
    /**
     * the id of the country the project is in
     * @type {number}
     * @memberof InvestorSocialProfile
     */
    country_id: number;
    /**
     * the id of the province the project is in
     * @type {number}
     * @memberof InvestorSocialProfile
     */
    province_id: number;
    /**
     * the city the project is in
     * @type {string}
     * @memberof InvestorSocialProfile
     */
    city: string;
    /**
     * the legal address of the project
     * @type {string}
     * @memberof InvestorSocialProfile
     */
    address: string;
    /**
     * the mailing identifier for the address of the project
     * @type {string}
     * @memberof InvestorSocialProfile
     */
    zip: string;
    /**
     * the email address to use to contact the project with
     * @type {string}
     * @memberof InvestorSocialProfile
     */
    email: string;
    /**
     * the telephone number to use to reach out to contact someone at the project
     * @type {string}
     * @memberof InvestorSocialProfile
     */
    phone: string;
    /**
     * a sentence or paragraph about the history of the person/project
     * @type {string}
     * @memberof InvestorSocialProfile
     */
    biography: string;
    /**
     * a narrative about the persons (not projects) career so far
     * @type {string}
     * @memberof InvestorSocialProfile
     */
    career: string;
    /**
     * a narrative about the persons (not projects) educational background
     * @type {string}
     * @memberof InvestorSocialProfile
     */
    education: string;
    /**
     * a free form narrative of what the person prefers to work with
     * @type {string}
     * @memberof InvestorSocialProfile
     */
    preferences: string;
}
/**
 * 
 * @export
 * @interface IssuerAdmin
 */
export interface IssuerAdmin {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof IssuerAdmin
     */
    id: number;
    /**
     * the category of user this is (i&#x3D;investor, a&#x3D;admin, c&#x3D;issuer admin)
     * @type {string}
     * @memberof IssuerAdmin
     */
    user_type: string;
    /**
     * the first name of the person who uses the account
     * @type {string}
     * @memberof IssuerAdmin
     */
    first_name: string;
    /**
     * the last name of the person who uses the account
     * @type {string}
     * @memberof IssuerAdmin
     */
    last_name: string;
    /**
     * the name of the file that holds the avatars picture. this is the resouce relative, not site relative.
     * @type {string}
     * @memberof IssuerAdmin
     */
    avatar_image_file_name: string;
    /**
     * the email address that identifies the account
     * @type {string}
     * @memberof IssuerAdmin
     */
    email: string;
    /**
     * the last point in time the user logged in
     * @type {Date}
     * @memberof IssuerAdmin
     */
    last_login: Date;
    /**
     * the last ip that they used to access the site from
     * @type {string}
     * @memberof IssuerAdmin
     */
    last_ip: string;
    /**
     * the name of the service that verifies the identity of the user (according to azure b2c))
     * @type {string}
     * @memberof IssuerAdmin
     */
    identity_provider: string;
    /**
     * the identifier for the user in the b2c system
     * @type {string}
     * @memberof IssuerAdmin
     */
    user_principle_name: string;
    /**
     * json format values that are used by applications as preferences
     * @type {string}
     * @memberof IssuerAdmin
     */
    preferences_as_json: string;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof IssuerAdmin
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof IssuerAdmin
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof IssuerAdmin
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof IssuerAdmin
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_COBRANDED_TO_SOCIAL_PROFILE and described as: 
     * @type {UserSocialProfile}
     * @memberof IssuerAdmin
     */
    cobranded_client_of: UserSocialProfile;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_TO_COUNTRIES and described as: 
     * @type {Country}
     * @memberof IssuerAdmin
     */
    country: Country;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof IssuerAdmin
     */
    last_changed_by: AllUser;
    /**
     * 
     * @type {Array<WebHook>}
     * @memberof IssuerAdmin
     */
    changes: Array<WebHook>;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_TO_MCOUNTRIES and described as: 
     * @type {Country}
     * @memberof IssuerAdmin
     */
    mailing_country: Country;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_TO_MPROVINCES and described as: 
     * @type {Province}
     * @memberof IssuerAdmin
     */
    mailing_province: Province;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_TO_PROVINCE and described as: 
     * @type {Province}
     * @memberof IssuerAdmin
     */
    province: Province;
    /**
     * This was created from the details of the foreign key FK_BACKGROUND_PROCESSS_LASTUSER_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {Array<BackgroundProcess>}
     * @memberof IssuerAdmin
     */
    background_processs_lastuser_last_changed_by_id_changes: Array<BackgroundProcess>;
    /**
     * This was created from the details of the foreign key FK_EVENTS_TO_USER and described as: 
     * @type {Array<Event>}
     * @memberof IssuerAdmin
     */
    events_to_user: Array<Event>;
    /**
     * This was created from the details of the foreign key FK_FFBA_ASSOCIATION_TO_USER and described as: 
     * @type {Array<FfbaAssociation>}
     * @memberof IssuerAdmin
     */
    ffba_association_to_user: Array<FfbaAssociation>;
    /**
     * This was created from the details of the foreign key FK_IMPORTED_CONTACTS_USER_ID_CONTACTS and described as: 
     * @type {Array<ImportedContact>}
     * @memberof IssuerAdmin
     */
    contacts: Array<ImportedContact>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_JOINT_SUBSCRIBER_TO_USER and described as: 
     * @type {Array<InvestmentOrder>}
     * @memberof IssuerAdmin
     */
    investment_orders_joint_subscriber_to_user: Array<InvestmentOrder>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_USER_ID_ORDERS and described as: 
     * @type {Array<InvestmentOrder>}
     * @memberof IssuerAdmin
     */
    orders: Array<InvestmentOrder>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_TRANSACTION_USER_ID_TRANSACTIONS and described as: 
     * @type {Array<InvestmentTransaction>}
     * @memberof IssuerAdmin
     */
    transactions: Array<InvestmentTransaction>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_WATCHLIST_USER_ID_WATCHES and described as: 
     * @type {Array<InvestmentWatchlist>}
     * @memberof IssuerAdmin
     */
    watches: Array<InvestmentWatchlist>;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_ACK_ORDERS_USER_ORDER_ACKNOWLEDGEMENTS and described as: 
     * @type {Array<OrderAcknowledgement>}
     * @memberof IssuerAdmin
     */
    investor_ack_orders_user_order_acknowledgements: Array<OrderAcknowledgement>;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_EARNINGS_USER_D and described as: 
     * @type {Array<InvestorEarning>}
     * @memberof IssuerAdmin
     */
    investor_earnings_user_d: Array<InvestorEarning>;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_INTENDED_TRADES_USER_ID_INTENDED_TRADES and described as: 
     * @type {Array<InvestorIntendedTrades>}
     * @memberof IssuerAdmin
     */
    intended_trades: Array<InvestorIntendedTrades>;
    /**
     * This was created from the details of the foreign key FK_MAILS_FROM_ID_SENT_EMAILS and described as: 
     * @type {Array<Mail>}
     * @memberof IssuerAdmin
     */
    sent_emails: Array<Mail>;
    /**
     * This was created from the details of the foreign key FK_MAILS_TO_ID_RECEIVED_EMAILS and described as: 
     * @type {Array<Mail>}
     * @memberof IssuerAdmin
     */
    received_emails: Array<Mail>;
    /**
     * This was created from the details of the foreign key FK_MODULE_ACCESS_USER_ID_ACCESSIBLE_MODULES and described as: 
     * @type {Array<ModuleAccess>}
     * @memberof IssuerAdmin
     */
    accessible_modules: Array<ModuleAccess>;
    /**
     * This was created from the details of the foreign key FK_PROJECT_TAX_REPORTS_USER_ID_TAX_REPORTS and described as: 
     * @type {Array<ProjectTaxReport>}
     * @memberof IssuerAdmin
     */
    tax_reports: Array<ProjectTaxReport>;
    /**
     * This was created from the details of the foreign key FK_SUPPORT_ENGINEERS_USER_ID_OWNER_USER and described as: 
     * @type {Array<SupportEngineer>}
     * @memberof IssuerAdmin
     */
    owner_user: Array<SupportEngineer>;
    /**
     * This was created from the details of the foreign key FK_USER_ISSUER_ASSOCIATIONS_TO_USER_ID_ISSUER_ASSOCIATIONS and described as: 
     * @type {Array<UserIssuerAssociation>}
     * @memberof IssuerAdmin
     */
    user_issuer_associations_to_user_id_issuer_associations: Array<UserIssuerAssociation>;
    /**
     * This was created from the details of the foreign key FK_USER_RELATIONSHIP_TO_USER_1 and described as: 
     * @type {Array<UserRelationship>}
     * @memberof IssuerAdmin
     */
    user_relationship_to_user_1: Array<UserRelationship>;
    /**
     * This was created from the details of the foreign key FK_USER_RELATIONSHIP_TO_USER_2 and described as: 
     * @type {Array<UserRelationship>}
     * @memberof IssuerAdmin
     */
    user_relationship_to_user_2: Array<UserRelationship>;
    /**
     * This was created from the details of the foreign key FK_USERS_BANKING_DETAILS_TO_JOINT_USER and described as: 
     * @type {Array<UserBankingDetails>}
     * @memberof IssuerAdmin
     */
    users_banking_details_to_joint_user: Array<UserBankingDetails>;
    /**
     * This was created from the details of the foreign key FK_USERS_BANKING_DETAILS_TO_USER and described as: 
     * @type {Array<UserBankingDetails>}
     * @memberof IssuerAdmin
     */
    users_banking_details_to_user: Array<UserBankingDetails>;
    /**
     * This was created from the details of the foreign key FK_USERS_EMPLOYMENT_USER_ID_FINANCIAL_KYC and described as: 
     * @type {Array<UserFinancialKyc>}
     * @memberof IssuerAdmin
     */
    financial_kyc: Array<UserFinancialKyc>;
    /**
     * This was created from the details of the foreign key FK_USERS_ENTITY_USER_ID_ENTITIES and described as: 
     * @type {Array<UserEntity>}
     * @memberof IssuerAdmin
     */
    entities: Array<UserEntity>;
    /**
     * This was created from the details of the foreign key FK_USERS_INVITEE_USER_ID_INVITATIONS and described as: 
     * @type {Array<UserInvitation>}
     * @memberof IssuerAdmin
     */
    invitations: Array<UserInvitation>;
    /**
     * This was created from the details of the foreign key FK_USERS_PDF_USER_ID_PDFS and described as: 
     * @type {Array<UserPdf>}
     * @memberof IssuerAdmin
     */
    pdfs: Array<UserPdf>;
    /**
     * This was created from the details of the foreign key FK_USERS_QUESTIONARY_USER_ID_ANSWERS and described as: 
     * @type {Array<UserAnswer>}
     * @memberof IssuerAdmin
     */
    answers: Array<UserAnswer>;
    /**
     * This was created from the details of the foreign key FK_USERS_REQUEST_USER_ID_REQUESTS and described as: 
     * @type {Array<UserRequest>}
     * @memberof IssuerAdmin
     */
    requests: Array<UserRequest>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {Array<UserSocialProfile>}
     * @memberof IssuerAdmin
     */
    users_socialprofile_last_changed_by_id_changes: Array<UserSocialProfile>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_USER_ID_PROFILES and described as: 
     * @type {Array<UserSocialProfile>}
     * @memberof IssuerAdmin
     */
    users_socialprofile_user_id_profiles: Array<UserSocialProfile>;
    /**
     * This was created from the details of the foreign key FK_USERS_SUBSCRIBE_USER_ID_SUBSCRIPTIONS and described as: 
     * @type {Array<UserSubscription>}
     * @memberof IssuerAdmin
     */
    subscriptions: Array<UserSubscription>;
    /**
     * This was created from the details of the foreign key FK_WEB_HOOKS_TO_USER and described as: 
     * @type {Array<WebHook>}
     * @memberof IssuerAdmin
     */
    web_hooks_to_user: Array<WebHook>;
    /**
     * the token used to identify the current session
     * @type {string}
     * @memberof IssuerAdmin
     */
    token: string;
    /**
     * the last time the session token was updated
     * @type {Date}
     * @memberof IssuerAdmin
     */
    token_update: Date;
    /**
     * the sponsor that essentially owns this investor
     * @type {number}
     * @memberof IssuerAdmin
     */
    cobranded_client_of_id: number;
    /**
     * the avilability of the account for use
     * @type {number}
     * @memberof IssuerAdmin
     */
    status: number;
}
/**
 * 
 * @export
 * @interface Mail
 */
export interface Mail {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof Mail
     */
    id: number;
    /**
     * the id of the use it was sent to
     * @type {number}
     * @memberof Mail
     */
    to_id: number;
    /**
     * the id of the user who sent it
     * @type {number}
     * @memberof Mail
     */
    from_id: number;
    /**
     * the smtp email address it was sent to. it may not be the current email address of the to_user
     * @type {string}
     * @memberof Mail
     */
    address_sent_to: string;
    /**
     * the subject line
     * @type {string}
     * @memberof Mail
     */
    subject: string;
    /**
     * the body/text of the email
     * @type {string}
     * @memberof Mail
     */
    body: string;
    /**
     * the complete body of the email that gets sent to the smtp server
     * @type {string}
     * @memberof Mail
     */
    raw_body: string;
    /**
     * has the email been sent to the smtp server successfully yet
     * @type {boolean}
     * @memberof Mail
     */
    sent_ok: boolean;
    /**
     * the name of a file attachement that was sent with it. it is not specified where/if that file continues to exist
     * @type {string}
     * @memberof Mail
     */
    attachment: string;
    /**
     * did the sender flag it?
     * @type {boolean}
     * @memberof Mail
     */
    flag: boolean;
    /**
     * did the sender star it?
     * @type {boolean}
     * @memberof Mail
     */
    stared: boolean;
    /**
     * the current state of the email
     * @type {number}
     * @memberof Mail
     */
    status: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof Mail
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof Mail
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof Mail
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof Mail
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_MAILS_FROM_ID_SENT_EMAILS and described as: 
     * @type {AllUser}
     * @memberof Mail
     */
    from: AllUser;
    /**
     * This was created from the details of the foreign key FK_MAILS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof Mail
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_MAILS_TO_ID_RECEIVED_EMAILS and described as: 
     * @type {AllUser}
     * @memberof Mail
     */
    to: AllUser;
}
/**
 * 
 * @export
 * @interface Menu
 */
export interface Menu {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof Menu
     */
    id: number;
    /**
     * the id of the page to show the menu on
     * @type {number}
     * @memberof Menu
     */
    page_id: number;
    /**
     * the text to show as the item
     * @type {string}
     * @memberof Menu
     */
    name: string;
    /**
     * the text to use for seo for the menu item
     * @type {string}
     * @memberof Menu
     */
    name_seo: string;
    /**
     * a url to an image resource to show alongside the menu
     * @type {string}
     * @memberof Menu
     */
    image: string;
    /**
     * the primary descriptive text for the item (fly over)
     * @type {string}
     * @memberof Menu
     */
    content: string;
    /**
     * the secondary descriptive text for the item (what for???)
     * @type {string}
     * @memberof Menu
     */
    content2: string;
    /**
     * the ordinal position of this item in the page or parent menu
     * @type {number}
     * @memberof Menu
     */
    sort_order: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof Menu
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof Menu
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof Menu
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof Menu
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_MENU_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof Menu
     */
    last_changed_by: AllUser;
}
/**
 * 
 * @export
 * @interface MetricResult
 */
export interface MetricResult {
}
/**
 * 
 * @export
 * @interface MetricsRequest
 */
export interface MetricsRequest {
}
/**
 * 
 * @export
 * @interface ModelString
 */
export interface ModelString {
}
/**
 * 
 * @export
 * @interface ModuleAccess
 */
export interface ModuleAccess {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof ModuleAccess
     */
    id: number;
    /**
     * the id of the user that is given the permissions
     * @type {number}
     * @memberof ModuleAccess
     */
    user_id: number;
    /**
     * the id of the module that the permissions are granted on
     * @type {number}
     * @memberof ModuleAccess
     */
    module_id: number;
    /**
     * if true, the user can view items
     * @type {boolean}
     * @memberof ModuleAccess
     */
    can_view: boolean;
    /**
     * if true, the user can create new items
     * @type {boolean}
     * @memberof ModuleAccess
     */
    can_add: boolean;
    /**
     * if true, the user can alter existing items
     * @type {boolean}
     * @memberof ModuleAccess
     */
    can_edit: boolean;
    /**
     * if true, the user can delete items
     * @type {boolean}
     * @memberof ModuleAccess
     */
    can_delete: boolean;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof ModuleAccess
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof ModuleAccess
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof ModuleAccess
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof ModuleAccess
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_MODULE_ACCESS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof ModuleAccess
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_MODULE_ACCESS_MODULE_ID_GRANTS and described as: 
     * @type {AdminModule}
     * @memberof ModuleAccess
     */
    module: AdminModule;
    /**
     * This was created from the details of the foreign key FK_MODULE_ACCESS_USER_ID_ACCESSIBLE_MODULES and described as: 
     * @type {AllUser}
     * @memberof ModuleAccess
     */
    user: AllUser;
}
/**
 * 
 * @export
 * @interface NotableInvestorProfile
 */
export interface NotableInvestorProfile {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof NotableInvestorProfile
     */
    id: number;
    /**
     * the user this is for
     * @type {number}
     * @memberof NotableInvestorProfile
     */
    user_id: number;
    /**
     * the name of the project the profile is for
     * @type {string}
     * @memberof NotableInvestorProfile
     */
    name: string;
    /**
     * a url to an image to use to represent the profile
     * @type {string}
     * @memberof NotableInvestorProfile
     */
    image: string;
    /**
     * a url to the facebook presence for the profile
     * @type {string}
     * @memberof NotableInvestorProfile
     */
    facebook: string;
    /**
     * a url to the twitter feed for the profile
     * @type {string}
     * @memberof NotableInvestorProfile
     */
    twitter: string;
    /**
     * a url to the linked in presence for the profile
     * @type {string}
     * @memberof NotableInvestorProfile
     */
    linkedin: string;
    /**
     * ?
     * @type {number}
     * @memberof NotableInvestorProfile
     */
    status: number;
    /**
     * for user profiles, if true the user should receive notification
     * @type {boolean}
     * @memberof NotableInvestorProfile
     */
    notification: boolean;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof NotableInvestorProfile
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof NotableInvestorProfile
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof NotableInvestorProfile
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof NotableInvestorProfile
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_COBRANDED_TO_SOCIAL_PROFILE and described as: 
     * @type {Array<AllUser>}
     * @memberof NotableInvestorProfile
     */
    all_users_cobranded_to_social_profile: Array<AllUser>;
    /**
     * This was created from the details of the foreign key FK_EVENTS_TO_ISSUER and described as: 
     * @type {Array<Event>}
     * @memberof NotableInvestorProfile
     */
    events_to_issuer: Array<Event>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_ISSUER_ID_ORDERS and described as: 
     * @type {Array<InvestmentOrder>}
     * @memberof NotableInvestorProfile
     */
    orders: Array<InvestmentOrder>;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_INTENDED_TRADES_INTENDED_ISSUER_ID_INTENDED_TRADES and described as: 
     * @type {Array<InvestorIntendedTrades>}
     * @memberof NotableInvestorProfile
     */
    intended_trades: Array<InvestorIntendedTrades>;
    /**
     * This was created from the details of the foreign key FK_PROJECTS_ISSUER_ID_PROJECTS and described as: 
     * @type {Array<Project>}
     * @memberof NotableInvestorProfile
     */
    projects: Array<Project>;
    /**
     * This was created from the details of the foreign key FK_PROPERTY_INTEREST_INTEREST_BY_ID_INTERESTS and described as: 
     * @type {Array<ProjectInterest>}
     * @memberof NotableInvestorProfile
     */
    interests: Array<ProjectInterest>;
    /**
     * This was created from the details of the foreign key FK_PROPERTY_INTEREST_INTEREST_IN_ID_INVESTOR_INTERESTS and described as: 
     * @type {Array<ProjectInterest>}
     * @memberof NotableInvestorProfile
     */
    investor_interests: Array<ProjectInterest>;
    /**
     * This was created from the details of the foreign key FK_USER_ISSUER_ASSOCIATIONS_TO_ISSUER_ID_ASSOCIATED_USERS and described as: 
     * @type {Array<UserIssuerAssociation>}
     * @memberof NotableInvestorProfile
     */
    user_issuer_associations_to_issuer_id_associated_users: Array<UserIssuerAssociation>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIAL_LINKUP_LINK_ID_FOLLOWERS and described as: 
     * @type {Array<SocialProfileFollowing>}
     * @memberof NotableInvestorProfile
     */
    followers: Array<SocialProfileFollowing>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIAL_LINKUP_PROFILE_ID_FOLLOWING and described as: 
     * @type {Array<SocialProfileFollowing>}
     * @memberof NotableInvestorProfile
     */
    following: Array<SocialProfileFollowing>;
    /**
     * 
     * @type {Array<UserSocialPost>}
     * @memberof NotableInvestorProfile
     */
    posts: Array<UserSocialPost>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_COUNTRY_ID and described as: 
     * @type {Country}
     * @memberof NotableInvestorProfile
     */
    country: Country;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_JURISDICTION_ID_PROFILES and described as: 
     * @type {Province}
     * @memberof NotableInvestorProfile
     */
    jurisdiction: Province;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof NotableInvestorProfile
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_PROJECT_ID_PROFILES and described as: 
     * @type {Project}
     * @memberof NotableInvestorProfile
     */
    project: Project;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_PROVINCE_ID and described as: 
     * @type {Province}
     * @memberof NotableInvestorProfile
     */
    province: Province;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_STATUTE_ID_TO_PROVINCES and described as: 
     * @type {Province}
     * @memberof NotableInvestorProfile
     */
    statute: Province;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_USER_ID_PROFILES and described as: 
     * @type {AllUser}
     * @memberof NotableInvestorProfile
     */
    user: AllUser;
    /**
     * This was created from the details of the foreign key FK_WEB_HOOKS_TO_ISSUER and described as: 
     * @type {Array<WebHook>}
     * @memberof NotableInvestorProfile
     */
    web_hooks_to_issuer: Array<WebHook>;
    /**
     * ?
     * @type {number}
     * @memberof NotableInvestorProfile
     */
    profile_type: number;
    /**
     * the id of the sub-national region that the project must comply to for compliance
     * @type {number}
     * @memberof NotableInvestorProfile
     */
    statute_id: number;
    /**
     * the id of the country the project is in
     * @type {number}
     * @memberof NotableInvestorProfile
     */
    country_id: number;
    /**
     * the id of the province the project is in
     * @type {number}
     * @memberof NotableInvestorProfile
     */
    province_id: number;
    /**
     * the city the project is in
     * @type {string}
     * @memberof NotableInvestorProfile
     */
    city: string;
    /**
     * the legal address of the project
     * @type {string}
     * @memberof NotableInvestorProfile
     */
    address: string;
    /**
     * the mailing identifier for the address of the project
     * @type {string}
     * @memberof NotableInvestorProfile
     */
    zip: string;
    /**
     * the email address to use to contact the project with
     * @type {string}
     * @memberof NotableInvestorProfile
     */
    email: string;
    /**
     * the telephone number to use to reach out to contact someone at the project
     * @type {string}
     * @memberof NotableInvestorProfile
     */
    phone: string;
    /**
     * a sentence or paragraph about the history of the person/project
     * @type {string}
     * @memberof NotableInvestorProfile
     */
    biography: string;
    /**
     * a narrative about the persons (not projects) career so far
     * @type {string}
     * @memberof NotableInvestorProfile
     */
    career: string;
    /**
     * a narrative about the persons (not projects) educational background
     * @type {string}
     * @memberof NotableInvestorProfile
     */
    education: string;
    /**
     * a free form narrative of what the person prefers to work with
     * @type {string}
     * @memberof NotableInvestorProfile
     */
    preferences: string;
    /**
     * if true (1) they are actively investing
     * @type {number}
     * @memberof NotableInvestorProfile
     */
    investment_status: number;
}
/**
 * 
 * @export
 * @interface Number
 */
export interface Number {
}
/**
 * 
 * @export
 * @interface OrderAcknowledgement
 */
export interface OrderAcknowledgement {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof OrderAcknowledgement
     */
    id: number;
    /**
     * the user that made the acknowledgement
     * @type {number}
     * @memberof OrderAcknowledgement
     */
    user_id: number;
    /**
     * the id of order that was acknowledged
     * @type {number}
     * @memberof OrderAcknowledgement
     */
    order_id: number;
    /**
     * the id of the question that was asked
     * @type {number}
     * @memberof OrderAcknowledgement
     */
    acknowledgement_order: number;
    /**
     * the text of the question that was asked.
     * @type {string}
     * @memberof OrderAcknowledgement
     */
    question_text: string;
    /**
     * the decoded value of the text
     * @type {string}
     * @memberof OrderAcknowledgement
     */
    answer: string;
    /**
     * the text answered
     * @type {string}
     * @memberof OrderAcknowledgement
     */
    answer_text: string;
    /**
     * 
     * @type {string}
     * @memberof OrderAcknowledgement
     */
    additional_answer: string;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof OrderAcknowledgement
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof OrderAcknowledgement
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof OrderAcknowledgement
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof OrderAcknowledgement
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_ACK_ORDERS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof OrderAcknowledgement
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_ACK_ORDERS_ORDER_ID_ACKNOWLEDGEMENT_DETAILS and described as: 
     * @type {InvestmentOrder}
     * @memberof OrderAcknowledgement
     */
    order: InvestmentOrder;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_ACK_ORDERS_USER_ORDER_ACKNOWLEDGEMENTS and described as: 
     * @type {AllUser}
     * @memberof OrderAcknowledgement
     */
    user: AllUser;
}
/**
 * 
 * @export
 * @interface OrderAcknowledgementQuestion
 */
export interface OrderAcknowledgementQuestion {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof OrderAcknowledgementQuestion
     */
    id: number;
    /**
     * the text of the question to ask
     * @type {string}
     * @memberof OrderAcknowledgementQuestion
     */
    question: string;
    /**
     * uncertain
     * @type {number}
     * @memberof OrderAcknowledgementQuestion
     */
    answer_type: number;
    /**
     * an alternative way of phrasing the question or additional details for clarification
     * @type {string}
     * @memberof OrderAcknowledgementQuestion
     */
    explanation: string;
    /**
     * 
     * @type {string}
     * @memberof OrderAcknowledgementQuestion
     */
    additional_acknowldgement: string;
    /**
     * the ordinal position of the question
     * @type {number}
     * @memberof OrderAcknowledgementQuestion
     */
    sort_order: number;
    /**
     * if true, the investor should be shown this question
     * @type {boolean}
     * @memberof OrderAcknowledgementQuestion
     */
    visible: boolean;
    /**
     * if true, this question is a component of the Offering Memorandum exemption, and should be used only in that context
     * @type {number}
     * @memberof OrderAcknowledgementQuestion
     */
    om_component: number;
    /**
     * the well-known name of a specific question, to allow it be invoked in specific circumstances
     * @type {string}
     * @memberof OrderAcknowledgementQuestion
     */
    wellknown: string;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof OrderAcknowledgementQuestion
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof OrderAcknowledgementQuestion
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof OrderAcknowledgementQuestion
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof OrderAcknowledgementQuestion
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_ACKNOWLEDGEMENTS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof OrderAcknowledgementQuestion
     */
    last_changed_by: AllUser;
}
/**
 * 
 * @export
 * @interface Preference
 */
export interface Preference {
}
/**
 * 
 * @export
 * @interface ProfileBackground
 */
export interface ProfileBackground {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof ProfileBackground
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ProfileBackground
     */
    image: string;
    /**
     * 
     * @type {number}
     * @memberof ProfileBackground
     */
    sort_order: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof ProfileBackground
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof ProfileBackground
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof ProfileBackground
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof ProfileBackground
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_PROFILE_BACKGROUND_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof ProfileBackground
     */
    last_changed_by: AllUser;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof Project
     */
    id: number;
    /**
     * the human readable identifier of the project
     * @type {number}
     * @memberof Project
     */
    project_no: number;
    /**
     * the spoken identifier of the project
     * @type {string}
     * @memberof Project
     */
    name: string;
    /**
     * the registered, legal representation of the human readable identifier
     * @type {string}
     * @memberof Project
     */
    legal_name: string;
    /**
     * a short-form human-readable identifier for when the long-form identifier is too long
     * @type {string}
     * @memberof Project
     */
    short_name: string;
    /**
     * the class of the units on offer
     * @type {string}
     * @memberof Project
     */
    unit_class: string;
    /**
     * the series of the units on offer
     * @type {string}
     * @memberof Project
     */
    unit_series: string;
    /**
     * the name to use in seo placement
     * @type {string}
     * @memberof Project
     */
    seoname: string;
    /**
     * a verbose description of the project, essentially a first level marketing description
     * @type {string}
     * @memberof Project
     */
    contents: string;
    /**
     * if true, show the sponsor label
     * @type {boolean}
     * @memberof Project
     */
    sponsor_label: boolean;
    /**
     * the id of the organization that is issuing the project
     * @type {number}
     * @memberof Project
     */
    issuer_id: number;
    /**
     * a classification of where the project is along in its life cycle
     * @type {number}
     * @memberof Project
     */
    project_stage: number;
    /**
     * if true (1) send notifications to investors
     * @type {boolean}
     * @memberof Project
     */
    notification: boolean;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    capital_type: number;
    /**
     * the type of asset being offered
     * @type {number}
     * @memberof Project
     */
    asset_type: number;
    /**
     * the type of development
     * @type {number}
     * @memberof Project
     */
    development_type: number;
    /**
     * if true, move the data to hubspot
     * @type {number}
     * @memberof Project
     */
    sync_to_hubspot: number;
    /**
     * the amount that is being raised
     * @type {number}
     * @memberof Project
     */
    offering_amount: number;
    /**
     * the expected range of annual return
     * @type {string}
     * @memberof Project
     */
    annual_irr: string;
    /**
     * the percentage of overall value the load represents
     * @type {string}
     * @memberof Project
     */
    loan_to_value_ratio: string;
    /**
     * ?
     * @type {number}
     * @memberof Project
     */
    matrix_id: number;
    /**
     * ?
     * @type {string}
     * @memberof Project
     */
    matrix_input: string;
    /**
     * the currency the prices are quoted in
     * @type {number}
     * @memberof Project
     */
    currency_label: number;
    /**
     * the total number of shares for purchase
     * @type {number}
     * @memberof Project
     */
    total_share: number;
    /**
     * the current price shares are being offered for purchase at
     * @type {number}
     * @memberof Project
     */
    share_price: number;
    /**
     * the perceived market value of the shares
     * @type {number}
     * @memberof Project
     */
    market_price: number;
    /**
     * the price the shares have most recently transacted at
     * @type {number}
     * @memberof Project
     */
    sale_price: number;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    default_share: number;
    /**
     * the minimum number of shares that must be purchased to participate in this project
     * @type {number}
     * @memberof Project
     */
    min_share: number;
    /**
     * the maximum number of shares that can be owned when a party is participating in the project
     * @type {number}
     * @memberof Project
     */
    max_share: number;
    /**
     * the percentage rate, expressed as a string, interest will be charged at
     * @type {string}
     * @memberof Project
     */
    interest_rate: string;
    /**
     * the length of the investment (typed free form)
     * @type {string}
     * @memberof Project
     */
    investment_term: string;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    minimum_duration_units: number;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    maximum_duration_units: number;
    /**
     * the period of time used in minimum duration
     * @type {number}
     * @memberof Project
     */
    minimum_duration_type: number;
    /**
     * the period of time used in maximum duration
     * @type {number}
     * @memberof Project
     */
    maximum_duration_type: number;
    /**
     * the number of days left for funding activities
     * @type {boolean}
     * @memberof Project
     */
    daysleft_flag: boolean;
    /**
     * if true, all funds have been raised and it is closed to further investments
     * @type {boolean}
     * @memberof Project
     */
    funded_flag: boolean;
    /**
     * a narrative of where/how the dividends, if any, are expected to be returned from
     * @type {string}
     * @memberof Project
     */
    dividend_desc: string;
    /**
     * a statement of the order in which this debt is repaid compared to other debt
     * @type {number}
     * @memberof Project
     */
    debt_seniority: number;
    /**
     * if true, it can be redeemed prior to ending
     * @type {string}
     * @memberof Project
     */
    redeem_ability: string;
    /**
     * the type of accounts and/or organizations that can take advantage of this funding
     * @type {string}
     * @memberof Project
     */
    investment_eligibility: string;
    /**
     * the rules that must be obsered about redeeming shares
     * @type {string}
     * @memberof Project
     */
    redemption_info: string;
    /**
     * the street/local address of the project
     * @type {string}
     * @memberof Project
     */
    address: string;
    /**
     * the postal code of the project
     * @type {string}
     * @memberof Project
     */
    zip: string;
    /**
     * the municiple location of the porject
     * @type {string}
     * @memberof Project
     */
    city: string;
    /**
     * the id of the province that the project is in
     * @type {number}
     * @memberof Project
     */
    province_id: number;
    /**
     * the id of the country the project is in
     * @type {number}
     * @memberof Project
     */
    country_id: number;
    /**
     * a url to the primary image to display for marketing this project
     * @type {string}
     * @memberof Project
     */
    image: string;
    /**
     * a description of the assets, steps and/or actions to ensure there is no loss of captial to investors
     * @type {string}
     * @memberof Project
     */
    credit_guarantee: string;
    /**
     * the primary business the issuer engages in
     * @type {string}
     * @memberof Project
     */
    issuer_business: string;
    /**
     * the name of the organization that is placing the securities
     * @type {string}
     * @memberof Project
     */
    agent_name: string;
    /**
     * the method use for determining the commission paid to the agent
     * @type {number}
     * @memberof Project
     */
    commission_type: number;
    /**
     * the numberical amount for the commission that agent is taking. this has to be used with commission_type to determine whether its a pecentage or dollar amount
     * @type {number}
     * @memberof Project
     */
    agent_commission: number;
    /**
     * the contact details for the registrant
     * @type {string}
     * @memberof Project
     */
    registrant_contact: string;
    /**
     * a statement of how the issuer intends to use the funds that are raised
     * @type {string}
     * @memberof Project
     */
    use_of_proceeds: string;
    /**
     * additional ^ separated name value pairs of properties about the project. eg Trustee~Some Trust Company, or such other trust company as may be selected by the Manager^Auditor~KPMG LLP^Fund Administrator~My Fund Services Ltd.
     * @type {string}
     * @memberof Project
     */
    additional_desc: string;
    /**
     * a ^ separated list of questions that the user must acknowledge prior to investing
     * @type {string}
     * @memberof Project
     */
    acknowledgements: string;
    /**
     * a longer descriptive text for display
     * @type {string}
     * @memberof Project
     */
    long_desc: string;
    /**
     * text to show as a disclaime prior to investments proceeding
     * @type {string}
     * @memberof Project
     */
    disclaimer_note: string;
    /**
     * a ^ separated list of key value pairs to provide additional properties about the project
     * @type {string}
     * @memberof Project
     */
    properties: string;
    /**
     * a ^ separate list of the name of tabs to display project entities on
     * @type {string}
     * @memberof Project
     */
    tabs: string;
    /**
     * if true, it should be private
     * @type {boolean}
     * @memberof Project
     */
    is_private: boolean;
    /**
     * a comma separate list of user ids that are specifically permitted to view this project even if its private
     * @type {string}
     * @memberof Project
     */
    private_ids: string;
    /**
     * 
     * @type {boolean}
     * @memberof Project
     */
    auto_invite: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Project
     */
    allow_ineligible: boolean;
    /**
     * the state of the project for use in the system
     * @type {number}
     * @memberof Project
     */
    system_status: number;
    /**
     * if true, project has a dividend reinvestment plan available, and the user should be asked if they wish to sign up for it in the order process
     * @type {boolean}
     * @memberof Project
     */
    drip_available: boolean;
    /**
     * if true, the project should use the OM programmed into the system rather than DocuSign
     * @type {boolean}
     * @memberof Project
     */
    use_system_om: boolean;
    /**
     * if true, the project should automatically calculate the months remaining in the term for display on the front end
     * @type {boolean}
     * @memberof Project
     */
    calc_months_remaining: boolean;
    /**
     * if true, the project allows for joint subscription, and should ask the user if they intend to do so during the order process
     * @type {boolean}
     * @memberof Project
     */
    allow_joint_subscription: boolean;
    /**
     * if true, the project does not currently allow for any further orders to be started
     * @type {boolean}
     * @memberof Project
     */
    investments_locked: boolean;
    /**
     * if true, the project will not show its estimated completion date in the UI
     * @type {boolean}
     * @memberof Project
     */
    hide_est_complete_date: boolean;
    /**
     * if true, the projects settlement date should always be the first of the following month
     * @type {boolean}
     * @memberof Project
     */
    continuous_offering: boolean;
    /**
     * if true, this should be shown on the &quot;home&quot; page
     * @type {boolean}
     * @memberof Project
     */
    show_on_home: boolean;
    /**
     * if true over subscriptions should be allowed
     * @type {boolean}
     * @memberof Project
     */
    over_subscriptions: boolean;
    /**
     * the id of its exemption
     * @type {number}
     * @memberof Project
     */
    exempt_option_id: number;
    /**
     * if true it is exempt
     * @type {boolean}
     * @memberof Project
     */
    roed_exemption: boolean;
    /**
     * stores a CSV list of IDs for the ROED exemptions under which investors can invest in this project
     * @type {string}
     * @memberof Project
     */
    roed_exemption_list: string;
    /**
     * ?
     * @type {number}
     * @memberof Project
     */
    view_counts: number;
    /**
     * the ordinal position of the project displayed with others
     * @type {number}
     * @memberof Project
     */
    sort_order: number;
    /**
     * the docusign id of the docusign template that will be used for testing signing documents
     * @type {string}
     * @memberof Project
     */
    docusign_template_dev_test: string;
    /**
     * the docusign id of the docusign template that will be used for production document signing.  NOTE: this should always be a clone of the dev/test document. A change should occur in test first then be COPIED to prod
     * @type {string}
     * @memberof Project
     */
    docusign_template_production: string;
    /**
     * the rules for merging data from the database into docusign. NOTE: its important that both the dev/test and prod documents match this mapping!
     * @type {string}
     * @memberof Project
     */
    docusign_template_merge_rules: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    docusign_additional_recipients_sending_order: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    docusign_additional_recipients_role_name: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    docusign_additional_recipients_person_name: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    docusign_additional_recipients_person_email: string;
    /**
     * a CSV list of the names of the trust companies involved with this project
     * @type {string}
     * @memberof Project
     */
    trust_company_names: string;
    /**
     * the point in time that funding will start being placed
     * @type {Date}
     * @memberof Project
     */
    funding_start: Date;
    /**
     * the date that funding is set to cease even if its not full
     * @type {Date}
     * @memberof Project
     */
    funding_expiry: Date;
    /**
     * the date that the investment completes/matures/ends
     * @type {Date}
     * @memberof Project
     */
    maturity_date: Date;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    hubspot_id: string;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof Project
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof Project
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof Project
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof Project
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key EVENTS_PROJECT and described as: 
     * @type {Array<Event>}
     * @memberof Project
     */
    events_project: Array<Event>;
    /**
     * This was created from the details of the foreign key FK_FFBA_ASSOCIATION_TO_PROJECT and described as: 
     * @type {Array<FfbaAssociation>}
     * @memberof Project
     */
    ffba_association_to_project: Array<FfbaAssociation>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_PROJECT_ID_ORDERS and described as: 
     * @type {Array<InvestmentOrder>}
     * @memberof Project
     */
    orders: Array<InvestmentOrder>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_TRANSACTION_PROJECT_ID_TRANSACTIONS and described as: 
     * @type {Array<InvestmentTransaction>}
     * @memberof Project
     */
    transactions: Array<InvestmentTransaction>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_WATCHLIST_PROJECT_ID_WATCHES and described as: 
     * @type {Array<InvestmentWatchlist>}
     * @memberof Project
     */
    watches: Array<InvestmentWatchlist>;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_EARNINGS_PROJECT_ID_INVESTOR_EARNINGS and described as: 
     * @type {Array<InvestorEarning>}
     * @memberof Project
     */
    investor_earnings: Array<InvestorEarning>;
    /**
     * This was created from the details of the foreign key FK_PAYMENT_METHODS_PROJECT_ID_ACCOUNTS and described as: 
     * @type {Array<ProjectAccount>}
     * @memberof Project
     */
    accounts: Array<ProjectAccount>;
    /**
     * This was created from the details of the foreign key FK_PROJECT_DOCUSIGN_MAPPINGS_PROJECT_ID_DOCUSIGN_MAPPINGS and described as: 
     * @type {Array<ProjectDocusignMapping>}
     * @memberof Project
     */
    project_docusign_mappings_project_id_docusign_mappings: Array<ProjectDocusignMapping>;
    /**
     * This was created from the details of the foreign key FK_PROJECT_EARNINGS_PROJECT_ID_ADJUSTMENTS and described as: 
     * @type {Array<ProjectBalanceAdjustment>}
     * @memberof Project
     */
    adjustments: Array<ProjectBalanceAdjustment>;
    /**
     * This was created from the details of the foreign key FK_PROJECT_ENTITY_PROJECT_ID_ENTITIES and described as: 
     * @type {Array<ProjectEntity>}
     * @memberof Project
     */
    entities: Array<ProjectEntity>;
    /**
     * This was created from the details of the foreign key FK_PROJECT_IMAGES_PROJECT_ID_IMAGES and described as: 
     * @type {Array<ProjectImage>}
     * @memberof Project
     */
    images: Array<ProjectImage>;
    /**
     * This was created from the details of the foreign key FK_PROJECT_KEYBACKERS_PROJECT_ID_BACKERS and described as: 
     * @type {Array<ProjectKeybacker>}
     * @memberof Project
     */
    backers: Array<ProjectKeybacker>;
    /**
     * This was created from the details of the foreign key FK_PROJECT_PDFS_PROJECT_ID_PDFS and described as: 
     * @type {Array<ProjectPdf>}
     * @memberof Project
     */
    pdfs: Array<ProjectPdf>;
    /**
     * This was created from the details of the foreign key FK_PROJECT_STATUS_REPORTS_PROJECT_ID_STATUS_REPORTS and described as: 
     * @type {Array<ProjectStatusReport>}
     * @memberof Project
     */
    status_reports: Array<ProjectStatusReport>;
    /**
     * This was created from the details of the foreign key FK_PROJECT_TAX_REPORTS_PROJECT_ID_TAX_REPORTS and described as: 
     * @type {Array<ProjectTaxReport>}
     * @memberof Project
     */
    tax_reports: Array<ProjectTaxReport>;
    /**
     * This was created from the details of the foreign key FK_PROJECT_TAX_SUMMARIES_PROJECT_ID_TAX_SUMMARIES and described as: 
     * @type {Array<ProjectTaxSummary>}
     * @memberof Project
     */
    tax_summaries: Array<ProjectTaxSummary>;
    /**
     * This was created from the details of the foreign key FK_PROJECTS_COUNTRY_ID_PROJECTS and described as: 
     * @type {Country}
     * @memberof Project
     */
    country: Country;
    /**
     * This was created from the details of the foreign key FK_PROJECTS_ISSUER_ID_PROJECTS and described as: 
     * @type {UserSocialProfile}
     * @memberof Project
     */
    issuer: UserSocialProfile;
    /**
     * This was created from the details of the foreign key FK_PROJECTS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof Project
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_PROJECTS_PROVINCE_ID_PROJECTS and described as: 
     * @type {Province}
     * @memberof Project
     */
    province: Province;
    /**
     * This was created from the details of the foreign key FK_PROJECTS_ROED_SECURITYCODE_PROJECTS and described as: 
     * @type {ExemptDistributionOption}
     * @memberof Project
     */
    exempt_option: ExemptDistributionOption;
    /**
     * This was created from the details of the foreign key FK_ROED_SCHEDULE1S_TO_PROJECTS and described as: 
     * @type {Array<RoedSchedule1>}
     * @memberof Project
     */
    roed_schedule1_s_to_projects: Array<RoedSchedule1>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_PROJECT_ID_PROFILES and described as: 
     * @type {Array<UserSocialProfile>}
     * @memberof Project
     */
    users_socialprofile_project_id_profiles: Array<UserSocialProfile>;
    /**
     * This was created from the details of the foreign key FK_WEB_HOOKS_PROJECT and described as: 
     * @type {Array<WebHook>}
     * @memberof Project
     */
    web_hooks_project: Array<WebHook>;
}
/**
 * 
 * @export
 * @interface ProjectAccount
 */
export interface ProjectAccount {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof ProjectAccount
     */
    id: number;
    /**
     * the project this is for
     * @type {number}
     * @memberof ProjectAccount
     */
    project_id: number;
    /**
     * unused
     * @type {number}
     * @memberof ProjectAccount
     */
    method: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectAccount
     */
    eligibility_types: string;
    /**
     * the method in which the funds are transferred
     * @type {number}
     * @memberof ProjectAccount
     */
    payment_type: number;
    /**
     * the name of the projects trust organization. this needs to be the name of the account holder
     * @type {string}
     * @memberof ProjectAccount
     */
    trust_name: string;
    /**
     * the address of the trust
     * @type {string}
     * @memberof ProjectAccount
     */
    trust_address: string;
    /**
     *  the primary contact of the projects trust
     * @type {string}
     * @memberof ProjectAccount
     */
    trust_contact: string;
    /**
     * the name of the institution that will receive the funds
     * @type {string}
     * @memberof ProjectAccount
     */
    institution: string;
    /**
     * the identifier of the institution
     * @type {string}
     * @memberof ProjectAccount
     */
    institution_number: string;
    /**
     * the identifier of the branch at the institution
     * @type {string}
     * @memberof ProjectAccount
     */
    branch_number: string;
    /**
     * the bank account number the trust maintains at the branch
     * @type {string}
     * @memberof ProjectAccount
     */
    bank_account_number: string;
    /**
     * the address of the institution
     * @type {string}
     * @memberof ProjectAccount
     */
    branch_mailing_address: string;
    /**
     * the swift code for the institution
     * @type {string}
     * @memberof ProjectAccount
     */
    swift_code: string;
    /**
     * the ordinal position of this account in the list of accounts for the project
     * @type {number}
     * @memberof ProjectAccount
     */
    sort_order: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectAccount
     */
    custom_text: string;
    /**
     * if true, the method is still active and can used
     * @type {boolean}
     * @memberof ProjectAccount
     */
    is_active: boolean;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof ProjectAccount
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof ProjectAccount
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof ProjectAccount
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof ProjectAccount
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_PAYMENT_METHODS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof ProjectAccount
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_PAYMENT_METHODS_PROJECT_ID_ACCOUNTS and described as: 
     * @type {Project}
     * @memberof ProjectAccount
     */
    project: Project;
}
/**
 * 
 * @export
 * @interface ProjectBalanceAdjustment
 */
export interface ProjectBalanceAdjustment {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof ProjectBalanceAdjustment
     */
    id: number;
    /**
     * the project this is for
     * @type {number}
     * @memberof ProjectBalanceAdjustment
     */
    project_id: number;
    /**
     * the type of adjustment
     * @type {number}
     * @memberof ProjectBalanceAdjustment
     */
    adjustment_type: number;
    /**
     * a textual coded value represent the category of the earning/fee
     * @type {number}
     * @memberof ProjectBalanceAdjustment
     */
    category: number;
    /**
     * a description of the earning or fee
     * @type {string}
     * @memberof ProjectBalanceAdjustment
     */
    description: string;
    /**
     * the amount it earned
     * @type {number}
     * @memberof ProjectBalanceAdjustment
     */
    amount: number;
    /**
     * 
     * @type {Date}
     * @memberof ProjectBalanceAdjustment
     */
    transaction_date: Date;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof ProjectBalanceAdjustment
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof ProjectBalanceAdjustment
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof ProjectBalanceAdjustment
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof ProjectBalanceAdjustment
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_EARNINGS_PE_ID_INVESTOR_EARNINGS and described as: 
     * @type {Array<InvestorEarning>}
     * @memberof ProjectBalanceAdjustment
     */
    investor_earnings: Array<InvestorEarning>;
    /**
     * This was created from the details of the foreign key FK_PROJECT_EARNINGS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof ProjectBalanceAdjustment
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_PROJECT_EARNINGS_PROJECT_ID_ADJUSTMENTS and described as: 
     * @type {Project}
     * @memberof ProjectBalanceAdjustment
     */
    project: Project;
}
/**
 * 
 * @export
 * @interface ProjectDocusignMapping
 */
export interface ProjectDocusignMapping {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof ProjectDocusignMapping
     */
    id: number;
    /**
     * the project this is for
     * @type {number}
     * @memberof ProjectDocusignMapping
     */
    project_applied_to_id: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectDocusignMapping
     */
    ordinal_application_order: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectDocusignMapping
     */
    docusign_template_guid: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDocusignMapping
     */
    dil_conditions_to_apply: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDocusignMapping
     */
    merge_rules: string;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof ProjectDocusignMapping
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof ProjectDocusignMapping
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof ProjectDocusignMapping
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof ProjectDocusignMapping
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_PROJECT_DOCUSIGN_MAPPINGS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof ProjectDocusignMapping
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_PROJECT_DOCUSIGN_MAPPINGS_PROJECT_ID_DOCUSIGN_MAPPINGS and described as: 
     * @type {Project}
     * @memberof ProjectDocusignMapping
     */
    project_applied_to: Project;
}
/**
 * 
 * @export
 * @interface ProjectEntity
 */
export interface ProjectEntity {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof ProjectEntity
     */
    id: number;
    /**
     * the project this is for
     * @type {number}
     * @memberof ProjectEntity
     */
    project_id: number;
    /**
     * the numerical identier of the tab this should be shown on. there is no construct for tabs so those are inferred from this value
     * @type {number}
     * @memberof ProjectEntity
     */
    tab_id: number;
    /**
     * the categorzation of the entity. this used for decoding what to do with and how to represent its details
     * @type {number}
     * @memberof ProjectEntity
     */
    entity_type: number;
    /**
     * the title or textual display for this item
     * @type {string}
     * @memberof ProjectEntity
     */
    title: string;
    /**
     * a secondary title or textual display for this item
     * @type {string}
     * @memberof ProjectEntity
     */
    title_2: string;
    /**
     * a textual description of this entity
     * @type {string}
     * @memberof ProjectEntity
     */
    contents: string;
    /**
     * a url to an image to use to display at the heading
     * @type {string}
     * @memberof ProjectEntity
     */
    image: string;
    /**
     * if true, this item should be shown
     * @type {boolean}
     * @memberof ProjectEntity
     */
    visible: boolean;
    /**
     * the ordinal position of this entity within the project
     * @type {number}
     * @memberof ProjectEntity
     */
    sort_order: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof ProjectEntity
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof ProjectEntity
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof ProjectEntity
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof ProjectEntity
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_PROJECT_ENTITY_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof ProjectEntity
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_PROJECT_ENTITY_PROJECT_ID_ENTITIES and described as: 
     * @type {Project}
     * @memberof ProjectEntity
     */
    project: Project;
    /**
     * This was created from the details of the foreign key FK_PROJECT_ENTITY_DETAILS_PROJECT_ENTITY_ID_DETAILS and described as: 
     * @type {Array<ProjectEntityDetail>}
     * @memberof ProjectEntity
     */
    details: Array<ProjectEntityDetail>;
    /**
     * This was created from the details of the foreign key FK_PROJECT_IMAGES_PROJECT_ENTITY_ID_IMAGES and described as: 
     * @type {Array<ProjectImage>}
     * @memberof ProjectEntity
     */
    images: Array<ProjectImage>;
    /**
     * This was created from the details of the foreign key FK_PROJECT_KEYBACKERS_PROJECT_ENTITY_ID_BACKERS and described as: 
     * @type {Array<ProjectKeybacker>}
     * @memberof ProjectEntity
     */
    backers: Array<ProjectKeybacker>;
}
/**
 * 
 * @export
 * @interface ProjectEntityDetail
 */
export interface ProjectEntityDetail {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof ProjectEntityDetail
     */
    id: number;
    /**
     * the id of the entity this is details for
     * @type {number}
     * @memberof ProjectEntityDetail
     */
    project_entity_id: number;
    /**
     * the first piece of details. the exact use and type are determined by the entity type
     * @type {string}
     * @memberof ProjectEntityDetail
     */
    f1: string;
    /**
     * the 2nd piece of details. the exact use and type are determined by the entity type
     * @type {string}
     * @memberof ProjectEntityDetail
     */
    f2: string;
    /**
     * the 3rd piece of details. the exact use and type are determined by the entity type
     * @type {string}
     * @memberof ProjectEntityDetail
     */
    f3: string;
    /**
     * the fourth piece of details. the exact use and type are determined by the entity type
     * @type {string}
     * @memberof ProjectEntityDetail
     */
    f4: string;
    /**
     * the fifth piece of details. the exact use and type are determined by the entity type
     * @type {string}
     * @memberof ProjectEntityDetail
     */
    f5: string;
    /**
     * the sixth piece of details. the exact use and type are determined by the entity type
     * @type {string}
     * @memberof ProjectEntityDetail
     */
    f6: string;
    /**
     * the sevenh piece of details. the exact use and type are determined by the entity type
     * @type {string}
     * @memberof ProjectEntityDetail
     */
    f7: string;
    /**
     * the eigth piece of details. the exact use and type are determined by the entity type
     * @type {string}
     * @memberof ProjectEntityDetail
     */
    f8: string;
    /**
     * the ninth piece of details. the exact use and type are determined by the entity type
     * @type {string}
     * @memberof ProjectEntityDetail
     */
    f9: string;
    /**
     * the tenth piece of details. the exact use and type are determined by the entity type
     * @type {string}
     * @memberof ProjectEntityDetail
     */
    f10: string;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof ProjectEntityDetail
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof ProjectEntityDetail
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof ProjectEntityDetail
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof ProjectEntityDetail
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_PROJECT_ENTITY_DETAILS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof ProjectEntityDetail
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_PROJECT_ENTITY_DETAILS_PROJECT_ENTITY_ID_DETAILS and described as: 
     * @type {ProjectEntity}
     * @memberof ProjectEntityDetail
     */
    project_entity: ProjectEntity;
}
/**
 * 
 * @export
 * @interface ProjectImage
 */
export interface ProjectImage {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof ProjectImage
     */
    id: number;
    /**
     * the project this is for
     * @type {number}
     * @memberof ProjectImage
     */
    project_id: number;
    /**
     * the id of the entity its for
     * @type {number}
     * @memberof ProjectImage
     */
    project_entity_id: number;
    /**
     * the title to show with it
     * @type {string}
     * @memberof ProjectImage
     */
    title: string;
    /**
     * a url to the location of the image
     * @type {string}
     * @memberof ProjectImage
     */
    image: string;
    /**
     * the ordinal value of the image in the list of images
     * @type {number}
     * @memberof ProjectImage
     */
    sort_order: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof ProjectImage
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof ProjectImage
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof ProjectImage
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof ProjectImage
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_PROJECT_IMAGES_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof ProjectImage
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_PROJECT_IMAGES_PROJECT_ENTITY_ID_IMAGES and described as: 
     * @type {ProjectEntity}
     * @memberof ProjectImage
     */
    project_entity: ProjectEntity;
    /**
     * This was created from the details of the foreign key FK_PROJECT_IMAGES_PROJECT_ID_IMAGES and described as: 
     * @type {Project}
     * @memberof ProjectImage
     */
    project: Project;
}
/**
 * 
 * @export
 * @interface ProjectInterest
 */
export interface ProjectInterest {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof ProjectInterest
     */
    id: number;
    /**
     * the id of the profile of the person interested
     * @type {number}
     * @memberof ProjectInterest
     */
    interest_by_id: number;
    /**
     * the id of the property they have an interest in
     * @type {number}
     * @memberof ProjectInterest
     */
    interest_in_id: number;
    /**
     * an amount the person would expect to invest
     * @type {number}
     * @memberof ProjectInterest
     */
    amount_to_invest: number;
    /**
     * the time period that they would like to invest within
     * @type {string}
     * @memberof ProjectInterest
     */
    time_until_investment: string;
    /**
     * general remarks about the potential invesmtent
     * @type {string}
     * @memberof ProjectInterest
     */
    remarks: string;
    /**
     * doesnt seem used
     * @type {number}
     * @memberof ProjectInterest
     */
    status: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof ProjectInterest
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof ProjectInterest
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof ProjectInterest
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof ProjectInterest
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_PROPERTY_INTEREST_INTEREST_BY_ID_INTERESTS and described as: 
     * @type {UserSocialProfile}
     * @memberof ProjectInterest
     */
    interest_by: UserSocialProfile;
    /**
     * This was created from the details of the foreign key FK_PROPERTY_INTEREST_INTEREST_IN_ID_INVESTOR_INTERESTS and described as: 
     * @type {UserSocialProfile}
     * @memberof ProjectInterest
     */
    interest_in: UserSocialProfile;
    /**
     * This was created from the details of the foreign key FK_PROPERTY_INTEREST_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof ProjectInterest
     */
    last_changed_by: AllUser;
}
/**
 * 
 * @export
 * @interface ProjectKeybacker
 */
export interface ProjectKeybacker {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof ProjectKeybacker
     */
    id: number;
    /**
     * the project this is for
     * @type {number}
     * @memberof ProjectKeybacker
     */
    project_id: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectKeybacker
     */
    project_entity_id: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectKeybacker
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectKeybacker
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectKeybacker
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectKeybacker
     */
    work: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectKeybacker
     */
    info: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectKeybacker
     */
    image: string;
    /**
     * 
     * @type {number}
     * @memberof ProjectKeybacker
     */
    sort_order: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof ProjectKeybacker
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof ProjectKeybacker
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof ProjectKeybacker
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof ProjectKeybacker
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_PROJECT_KEYBACKERS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof ProjectKeybacker
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_PROJECT_KEYBACKERS_PROJECT_ENTITY_ID_BACKERS and described as: 
     * @type {ProjectEntity}
     * @memberof ProjectKeybacker
     */
    project_entity: ProjectEntity;
    /**
     * This was created from the details of the foreign key FK_PROJECT_KEYBACKERS_PROJECT_ID_BACKERS and described as: 
     * @type {Project}
     * @memberof ProjectKeybacker
     */
    project: Project;
}
/**
 * 
 * @export
 * @interface ProjectPdf
 */
export interface ProjectPdf {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof ProjectPdf
     */
    id: number;
    /**
     * the project this is for
     * @type {number}
     * @memberof ProjectPdf
     */
    project_id: number;
    /**
     * the (optional) id of the project entity this is for
     * @type {number}
     * @memberof ProjectPdf
     */
    project_entity_id: number;
    /**
     * the human readable identifier for the document
     * @type {string}
     * @memberof ProjectPdf
     */
    title: string;
    /**
     * a url to the pdf
     * @type {string}
     * @memberof ProjectPdf
     */
    filename: string;
    /**
     * if true, the document is shown
     * @type {boolean}
     * @memberof ProjectPdf
     */
    visible: boolean;
    /**
     * the ordinal position of this document within others
     * @type {number}
     * @memberof ProjectPdf
     */
    sort_order: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof ProjectPdf
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof ProjectPdf
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof ProjectPdf
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof ProjectPdf
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_PROJECT_PDFS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof ProjectPdf
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_PROJECT_PDFS_PROJECT_ID_PDFS and described as: 
     * @type {Project}
     * @memberof ProjectPdf
     */
    project: Project;
}
/**
 * 
 * @export
 * @interface ProjectStatusReport
 */
export interface ProjectStatusReport {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof ProjectStatusReport
     */
    id: number;
    /**
     * the project this is for
     * @type {number}
     * @memberof ProjectStatusReport
     */
    project_id: number;
    /**
     * a textual synopsis of the contents of the report
     * @type {string}
     * @memberof ProjectStatusReport
     */
    contents: string;
    /**
     * a url to where a file with the details of the report is located, typically pdf
     * @type {string}
     * @memberof ProjectStatusReport
     */
    document: string;
    /**
     * the date the report was issued FOR, not when it was issued
     * @type {Date}
     * @memberof ProjectStatusReport
     */
    report_date: Date;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof ProjectStatusReport
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof ProjectStatusReport
     */
    last_changed_by_id: number;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof ProjectStatusReport
     */
    updatetime: Date;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof ProjectStatusReport
     */
    createtime: Date;
    /**
     * This was created from the details of the foreign key FK_PROJECT_STATUS_REPORTS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof ProjectStatusReport
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_PROJECT_STATUS_REPORTS_PROJECT_ID_STATUS_REPORTS and described as: 
     * @type {Project}
     * @memberof ProjectStatusReport
     */
    project: Project;
}
/**
 * 
 * @export
 * @interface ProjectTaxReport
 */
export interface ProjectTaxReport {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof ProjectTaxReport
     */
    id: number;
    /**
     * the project this is for
     * @type {number}
     * @memberof ProjectTaxReport
     */
    project_id: number;
    /**
     * the id of the user the taxation is for
     * @type {number}
     * @memberof ProjectTaxReport
     */
    user_id: number;
    /**
     * the calendar year this represents taxes for
     * @type {number}
     * @memberof ProjectTaxReport
     */
    taxation_year: number;
    /**
     * general remarks about the taxes
     * @type {string}
     * @memberof ProjectTaxReport
     */
    remarks: string;
    /**
     * a url to a file that has the details, typically a pdf
     * @type {string}
     * @memberof ProjectTaxReport
     */
    document: string;
    /**
     * the number of times its used
     * @type {number}
     * @memberof ProjectTaxReport
     */
    view_count: number;
    /**
     * if true it has been published
     * @type {boolean}
     * @memberof ProjectTaxReport
     */
    is_published: boolean;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof ProjectTaxReport
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof ProjectTaxReport
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof ProjectTaxReport
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof ProjectTaxReport
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_PROJECT_TAX_REPORTS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof ProjectTaxReport
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_PROJECT_TAX_REPORTS_PROJECT_ID_TAX_REPORTS and described as: 
     * @type {Project}
     * @memberof ProjectTaxReport
     */
    project: Project;
    /**
     * This was created from the details of the foreign key FK_PROJECT_TAX_REPORTS_USER_ID_TAX_REPORTS and described as: 
     * @type {AllUser}
     * @memberof ProjectTaxReport
     */
    user: AllUser;
}
/**
 * 
 * @export
 * @interface ProjectTaxSummary
 */
export interface ProjectTaxSummary {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof ProjectTaxSummary
     */
    id: number;
    /**
     * the project this is for
     * @type {number}
     * @memberof ProjectTaxSummary
     */
    project_id: number;
    /**
     * the calendar year this represents taxes for
     * @type {number}
     * @memberof ProjectTaxSummary
     */
    taxation_year: number;
    /**
     * general remarks about the taxes
     * @type {string}
     * @memberof ProjectTaxSummary
     */
    remarks: string;
    /**
     * a url to a file that has the details, typically an excel file
     * @type {string}
     * @memberof ProjectTaxSummary
     */
    document: string;
    /**
     * the number of times its used
     * @type {number}
     * @memberof ProjectTaxSummary
     */
    view_count: number;
    /**
     * if true tax reports based ont it have been published
     * @type {boolean}
     * @memberof ProjectTaxSummary
     */
    is_published: boolean;
    /**
     * if true an XML report based on it has been generated
     * @type {boolean}
     * @memberof ProjectTaxSummary
     */
    xml_generated: boolean;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof ProjectTaxSummary
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof ProjectTaxSummary
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof ProjectTaxSummary
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof ProjectTaxSummary
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_PROJECT_TAX_SUMMARIES_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof ProjectTaxSummary
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_PROJECT_TAX_SUMMARIES_PROJECT_ID_TAX_SUMMARIES and described as: 
     * @type {Project}
     * @memberof ProjectTaxSummary
     */
    project: Project;
}
/**
 * 
 * @export
 * @interface PropertySocialProfile
 */
export interface PropertySocialProfile {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof PropertySocialProfile
     */
    id: number;
    /**
     * the user this is for
     * @type {number}
     * @memberof PropertySocialProfile
     */
    user_id: number;
    /**
     * the name of the project the profile is for
     * @type {string}
     * @memberof PropertySocialProfile
     */
    name: string;
    /**
     * a url to an image to use to represent the profile
     * @type {string}
     * @memberof PropertySocialProfile
     */
    image: string;
    /**
     * a url to the facebook presence for the profile
     * @type {string}
     * @memberof PropertySocialProfile
     */
    facebook: string;
    /**
     * a url to the twitter feed for the profile
     * @type {string}
     * @memberof PropertySocialProfile
     */
    twitter: string;
    /**
     * a url to the linked in presence for the profile
     * @type {string}
     * @memberof PropertySocialProfile
     */
    linkedin: string;
    /**
     * ?
     * @type {number}
     * @memberof PropertySocialProfile
     */
    status: number;
    /**
     * for user profiles, if true the user should receive notification
     * @type {boolean}
     * @memberof PropertySocialProfile
     */
    notification: boolean;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof PropertySocialProfile
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof PropertySocialProfile
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof PropertySocialProfile
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof PropertySocialProfile
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_COBRANDED_TO_SOCIAL_PROFILE and described as: 
     * @type {Array<AllUser>}
     * @memberof PropertySocialProfile
     */
    all_users_cobranded_to_social_profile: Array<AllUser>;
    /**
     * This was created from the details of the foreign key FK_EVENTS_TO_ISSUER and described as: 
     * @type {Array<Event>}
     * @memberof PropertySocialProfile
     */
    events_to_issuer: Array<Event>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_ISSUER_ID_ORDERS and described as: 
     * @type {Array<InvestmentOrder>}
     * @memberof PropertySocialProfile
     */
    orders: Array<InvestmentOrder>;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_INTENDED_TRADES_INTENDED_ISSUER_ID_INTENDED_TRADES and described as: 
     * @type {Array<InvestorIntendedTrades>}
     * @memberof PropertySocialProfile
     */
    intended_trades: Array<InvestorIntendedTrades>;
    /**
     * This was created from the details of the foreign key FK_PROJECTS_ISSUER_ID_PROJECTS and described as: 
     * @type {Array<Project>}
     * @memberof PropertySocialProfile
     */
    projects: Array<Project>;
    /**
     * This was created from the details of the foreign key FK_PROPERTY_INTEREST_INTEREST_BY_ID_INTERESTS and described as: 
     * @type {Array<ProjectInterest>}
     * @memberof PropertySocialProfile
     */
    interests: Array<ProjectInterest>;
    /**
     * This was created from the details of the foreign key FK_PROPERTY_INTEREST_INTEREST_IN_ID_INVESTOR_INTERESTS and described as: 
     * @type {Array<ProjectInterest>}
     * @memberof PropertySocialProfile
     */
    investor_interests: Array<ProjectInterest>;
    /**
     * This was created from the details of the foreign key FK_USER_ISSUER_ASSOCIATIONS_TO_ISSUER_ID_ASSOCIATED_USERS and described as: 
     * @type {Array<UserIssuerAssociation>}
     * @memberof PropertySocialProfile
     */
    user_issuer_associations_to_issuer_id_associated_users: Array<UserIssuerAssociation>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIAL_LINKUP_LINK_ID_FOLLOWERS and described as: 
     * @type {Array<SocialProfileFollowing>}
     * @memberof PropertySocialProfile
     */
    followers: Array<SocialProfileFollowing>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIAL_LINKUP_PROFILE_ID_FOLLOWING and described as: 
     * @type {Array<SocialProfileFollowing>}
     * @memberof PropertySocialProfile
     */
    following: Array<SocialProfileFollowing>;
    /**
     * 
     * @type {Array<UserSocialPost>}
     * @memberof PropertySocialProfile
     */
    posts: Array<UserSocialPost>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_COUNTRY_ID and described as: 
     * @type {Country}
     * @memberof PropertySocialProfile
     */
    country: Country;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_JURISDICTION_ID_PROFILES and described as: 
     * @type {Province}
     * @memberof PropertySocialProfile
     */
    jurisdiction: Province;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof PropertySocialProfile
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_PROJECT_ID_PROFILES and described as: 
     * @type {Project}
     * @memberof PropertySocialProfile
     */
    project: Project;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_PROVINCE_ID and described as: 
     * @type {Province}
     * @memberof PropertySocialProfile
     */
    province: Province;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_STATUTE_ID_TO_PROVINCES and described as: 
     * @type {Province}
     * @memberof PropertySocialProfile
     */
    statute: Province;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_USER_ID_PROFILES and described as: 
     * @type {AllUser}
     * @memberof PropertySocialProfile
     */
    user: AllUser;
    /**
     * This was created from the details of the foreign key FK_WEB_HOOKS_TO_ISSUER and described as: 
     * @type {Array<WebHook>}
     * @memberof PropertySocialProfile
     */
    web_hooks_to_issuer: Array<WebHook>;
    /**
     * if the profile is for a project, the id of that project
     * @type {number}
     * @memberof PropertySocialProfile
     */
    project_id: number;
    /**
     * 
     * @type {number}
     * @memberof PropertySocialProfile
     */
    developer_number: number;
    /**
     * the short identifier of an issuer
     * @type {string}
     * @memberof PropertySocialProfile
     */
    issuer_code: string;
    /**
     * ?
     * @type {number}
     * @memberof PropertySocialProfile
     */
    profile_type: number;
    /**
     * the legal name of the project
     * @type {string}
     * @memberof PropertySocialProfile
     */
    legal_name: string;
    /**
     * a caret (^) separated list of category tags for the invesmtent. the tags are currently unstructured
     * @type {string}
     * @memberof PropertySocialProfile
     */
    categories: string;
    /**
     * for a user profile, the tags of projects that person is interested in
     * @type {string}
     * @memberof PropertySocialProfile
     */
    self_category: string;
    /**
     * 
     * @type {string}
     * @memberof PropertySocialProfile
     */
    bg_image: string;
    /**
     * 
     * @type {string}
     * @memberof PropertySocialProfile
     */
    signup_image: string;
    /**
     * 
     * @type {string}
     * @memberof PropertySocialProfile
     */
    signup_guide_image: string;
    /**
     * a url to an image to use for the project when it is displayed &quot;in our network&quot;
     * @type {string}
     * @memberof PropertySocialProfile
     */
    network_logo: string;
    /**
     * a url to an image to use for the background of the project when it is displayed &quot;in our network&quot;
     * @type {string}
     * @memberof PropertySocialProfile
     */
    network_background: string;
    /**
     * a sentence or paragraph about the history of the person/project
     * @type {string}
     * @memberof PropertySocialProfile
     */
    biography: string;
    /**
     * a narrative about the persons (not projects) career so far
     * @type {string}
     * @memberof PropertySocialProfile
     */
    career: string;
    /**
     * a narrative about the persons (not projects) educational background
     * @type {string}
     * @memberof PropertySocialProfile
     */
    education: string;
    /**
     * a free form narrative of what the person prefers to work with
     * @type {string}
     * @memberof PropertySocialProfile
     */
    preferences: string;
    /**
     * internal storage for the list of person ids
     * @type {string}
     * @memberof PropertySocialProfile
     */
    person_ids: string;
    /**
     * if true (1) they are actively investing
     * @type {number}
     * @memberof PropertySocialProfile
     */
    investment_status: number;
    /**
     * a url to an image to show in the background for the project
     * @type {string}
     * @memberof PropertySocialProfile
     */
    background_image: string;
}
/**
 * 
 * @export
 * @interface Province
 */
export interface Province {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof Province
     */
    id: number;
    /**
     * the human readable identifier
     * @type {string}
     * @memberof Province
     */
    name: string;
    /**
     * the id of the country it is in
     * @type {number}
     * @memberof Province
     */
    country_id: number;
    /**
     * the code typically used to denote it inside the country
     * @type {string}
     * @memberof Province
     */
    code: string;
    /**
     * the latitude of its geographic center
     * @type {number}
     * @memberof Province
     */
    latitude: number;
    /**
     * the longitude of its geographic center
     * @type {number}
     * @memberof Province
     */
    longitude: number;
    /**
     * the most commonly known or used timezone in it
     * @type {string}
     * @memberof Province
     */
    timezone: string;
    /**
     * if true it should be shown in pick lists
     * @type {boolean}
     * @memberof Province
     */
    visible: boolean;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof Province
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof Province
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof Province
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof Province
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_TO_MPROVINCES and described as: 
     * @type {Array<AllUser>}
     * @memberof Province
     */
    all_users_to_mprovinces: Array<AllUser>;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_TO_PROVINCE and described as: 
     * @type {Array<AllUser>}
     * @memberof Province
     */
    all_users_to_province: Array<AllUser>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_WITHDRAWAL_TO_PROVINCE and described as: 
     * @type {Array<InvestmentWithdrawal>}
     * @memberof Province
     */
    investment_withdrawal_to_province: Array<InvestmentWithdrawal>;
    /**
     * This was created from the details of the foreign key FK_PROJECTS_PROVINCE_ID_PROJECTS and described as: 
     * @type {Array<Project>}
     * @memberof Province
     */
    projects: Array<Project>;
    /**
     * This was created from the details of the foreign key FK_PROVINCES_TO_COUNTRIES and described as: 
     * @type {Country}
     * @memberof Province
     */
    country: Country;
    /**
     * This was created from the details of the foreign key FK_PROVINCES_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof Province
     */
    last_changed_by: AllUser;
    /**
     * 
     * @type {Array<UserEntity>}
     * @memberof Province
     */
    investor_companies: Array<UserEntity>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_JURISDICTION_ID_PROFILES and described as: 
     * @type {Array<UserSocialProfile>}
     * @memberof Province
     */
    users_socialprofile_jurisdiction_id_profiles: Array<UserSocialProfile>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_PROVINCE_ID and described as: 
     * @type {Array<UserSocialProfile>}
     * @memberof Province
     */
    users_socialprofile_province_id: Array<UserSocialProfile>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_STATUTE_ID_TO_PROVINCES and described as: 
     * @type {Array<UserSocialProfile>}
     * @memberof Province
     */
    users_socialprofile_statute_id_to_provinces: Array<UserSocialProfile>;
}
/**
 * 
 * @export
 * @interface RegistrationQuestion
 */
export interface RegistrationQuestion {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof RegistrationQuestion
     */
    id: number;
    /**
     * the category of the question
     * @type {number}
     * @memberof RegistrationQuestion
     */
    category: number;
    /**
     * the textual identifier (key phrase) of the question to ask
     * @type {string}
     * @memberof RegistrationQuestion
     */
    question: string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationQuestion
     */
    wellknown: string;
    /**
     * the body text of the question to ask
     * @type {string}
     * @memberof RegistrationQuestion
     */
    content: string;
    /**
     * the set of questions (version) this set belongs to
     * @type {number}
     * @memberof RegistrationQuestion
     */
    question_set: number;
    /**
     * a url to an image that can be used to represent the question
     * @type {string}
     * @memberof RegistrationQuestion
     */
    representative_image: string;
    /**
     * the type of presentation to use to present the asnwer
     * @type {number}
     * @memberof RegistrationQuestion
     */
    answer_type: number;
    /**
     * if its question type 3, this is a string with 2 numbers separated by a comma. those values are the low and high of the permitted range
     * @type {string}
     * @memberof RegistrationQuestion
     */
    type_3_range: string;
    /**
     * if its question type 3, this what the sum of the answers must match (eg, 100%)
     * @type {number}
     * @memberof RegistrationQuestion
     */
    type_3_total: number;
    /**
     * 
     * @type {boolean}
     * @memberof RegistrationQuestion
     */
    slider_display: boolean;
    /**
     * the first possible choice as an answer
     * @type {string}
     * @memberof RegistrationQuestion
     */
    answer_choice_1: string;
    /**
     * a url to an image that can be used to represent the first answer choice
     * @type {string}
     * @memberof RegistrationQuestion
     */
    answer1_image: string;
    /**
     * the second possible choice as an answer
     * @type {string}
     * @memberof RegistrationQuestion
     */
    answer_choice_2: string;
    /**
     * a url to an image that can be used to represent the second answer choice
     * @type {string}
     * @memberof RegistrationQuestion
     */
    answer2_image: string;
    /**
     * the third possible choice as an answer
     * @type {string}
     * @memberof RegistrationQuestion
     */
    answer_choice_3: string;
    /**
     * a url to an image that can be used to represent the third answer choice
     * @type {string}
     * @memberof RegistrationQuestion
     */
    answer3_image: string;
    /**
     * the fourth possible choice as an answer
     * @type {string}
     * @memberof RegistrationQuestion
     */
    answer_choice_4: string;
    /**
     * a url to an image that can be used to represent the fourth answer choice
     * @type {string}
     * @memberof RegistrationQuestion
     */
    answer4_image: string;
    /**
     * the fifth possible choice as an answer
     * @type {string}
     * @memberof RegistrationQuestion
     */
    answer_choice_5: string;
    /**
     * a url to an image that can be used to represent the fifth answer choice
     * @type {string}
     * @memberof RegistrationQuestion
     */
    answer5_image: string;
    /**
     * the sixth possible choice as an answer
     * @type {string}
     * @memberof RegistrationQuestion
     */
    answer_choice_6: string;
    /**
     * a url to an image that can be used to represent the sixth answer choice
     * @type {string}
     * @memberof RegistrationQuestion
     */
    answer6_image: string;
    /**
     * the seventh possible choice as an answer
     * @type {string}
     * @memberof RegistrationQuestion
     */
    answer_choice_7: string;
    /**
     * a url to an image that can be used to represent the seventh answer choice
     * @type {string}
     * @memberof RegistrationQuestion
     */
    answer7_image: string;
    /**
     * the eigth possible choice as an answer
     * @type {string}
     * @memberof RegistrationQuestion
     */
    answer_choice_8: string;
    /**
     * a url to an image that can be used to represent the eigth answer choice
     * @type {string}
     * @memberof RegistrationQuestion
     */
    answer8_image: string;
    /**
     * the ninth possible choice as an answer
     * @type {string}
     * @memberof RegistrationQuestion
     */
    answer_choice_9: string;
    /**
     * a url to an image that can be used to represent the ninth answer choice
     * @type {string}
     * @memberof RegistrationQuestion
     */
    answer9_image: string;
    /**
     * the tenth possible choice as an answer
     * @type {string}
     * @memberof RegistrationQuestion
     */
    answer_choice_10: string;
    /**
     * a url to an image that can be used to represent the tenth answer choice
     * @type {string}
     * @memberof RegistrationQuestion
     */
    answer10_image: string;
    /**
     * the ordinal position of this question in the list of questions to ask
     * @type {number}
     * @memberof RegistrationQuestion
     */
    sort_order: number;
    /**
     * if true the question should be shown otherwise is should not be shown
     * @type {boolean}
     * @memberof RegistrationQuestion
     */
    visible: boolean;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof RegistrationQuestion
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof RegistrationQuestion
     */
    last_changed_by_id: number;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof RegistrationQuestion
     */
    updatetime: Date;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof RegistrationQuestion
     */
    createtime: Date;
    /**
     * This was created from the details of the foreign key FK_REGISTRATION_QUESTIONARY_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof RegistrationQuestion
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_USERS_QUESTIONARY_QUESTION_ID_ANSWERS and described as: 
     * @type {Array<UserAnswer>}
     * @memberof RegistrationQuestion
     */
    answers: Array<UserAnswer>;
}
/**
 * 
 * @export
 * @interface RoedSchedule1
 */
export interface RoedSchedule1 {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof RoedSchedule1
     */
    id: number;
    /**
     * a human readable identifier of the report
     * @type {string}
     * @memberof RoedSchedule1
     */
    name: string;
    /**
     * general remarks about the report
     * @type {string}
     * @memberof RoedSchedule1
     */
    remarks: string;
    /**
     * the project it belongs to
     * @type {number}
     * @memberof RoedSchedule1
     */
    project_id: number;
    /**
     * a url to a file that has the report, usually an excel file
     * @type {string}
     * @memberof RoedSchedule1
     */
    document: string;
    /**
     * a list of rows to be ignored in the filed document
     * @type {string}
     * @memberof RoedSchedule1
     */
    filed_rows_to_ignore: string;
    /**
     * the current state of the schedule 1
     * @type {number}
     * @memberof RoedSchedule1
     */
    status: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof RoedSchedule1
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof RoedSchedule1
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof RoedSchedule1
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof RoedSchedule1
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_ROED_SCHEDULE1_ID_ORDERS and described as: 
     * @type {Array<InvestmentOrder>}
     * @memberof RoedSchedule1
     */
    orders: Array<InvestmentOrder>;
    /**
     * This was created from the details of the foreign key FK_ROED_SCHEDULE1S_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof RoedSchedule1
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_ROED_SCHEDULE1S_TO_PROJECTS and described as: 
     * @type {Project}
     * @memberof RoedSchedule1
     */
    project: Project;
}
/**
 * 
 * @export
 * @interface Setting
 */
export interface Setting {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof Setting
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    company: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    address2: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    zip: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    province: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    country: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    site_name: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    site_domain: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    phone: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    phone2: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    fax: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    info_email: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    petoes: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    keywords: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    facebook: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    twitter: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    google: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    pinterest: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    linkedin: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    instagram: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    tumblr: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    youtube: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    blog: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    relationship_disclosure: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    google_analytics: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    google_analytics_body: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    dev_company: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    dev_address: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    dev_address2: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    dev_city: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    dev_zip: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    dev_province: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    dev_country: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    dev_phone: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    dev_fax: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    dev_email: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    dev_web: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    timezone: string;
    /**
     * 
     * @type {boolean}
     * @memberof Setting
     */
    use_openssl: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof Setting
     */
    last_changed_by_id: number;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof Setting
     */
    updatetime: Date;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof Setting
     */
    is_deleted: boolean;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof Setting
     */
    createtime: Date;
    /**
     * This was created from the details of the foreign key FK_SETTINGS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof Setting
     */
    last_changed_by: AllUser;
}
/**
 * 
 * @export
 * @interface SocialProfileFollowing
 */
export interface SocialProfileFollowing {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof SocialProfileFollowing
     */
    id: number;
    /**
     * the id of the user that is being observed
     * @type {number}
     * @memberof SocialProfileFollowing
     */
    following_id: number;
    /**
     * the id of the user that is observing
     * @type {number}
     * @memberof SocialProfileFollowing
     */
    follower_id: number;
    /**
     * the current state of the connection
     * @type {number}
     * @memberof SocialProfileFollowing
     */
    status: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof SocialProfileFollowing
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof SocialProfileFollowing
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof SocialProfileFollowing
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof SocialProfileFollowing
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIAL_LINKUP_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof SocialProfileFollowing
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIAL_LINKUP_LINK_ID_FOLLOWERS and described as: 
     * @type {UserSocialProfile}
     * @memberof SocialProfileFollowing
     */
    follower: UserSocialProfile;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIAL_LINKUP_PROFILE_ID_FOLLOWING and described as: 
     * @type {UserSocialProfile}
     * @memberof SocialProfileFollowing
     */
    following: UserSocialProfile;
}
/**
 * 
 * @export
 * @interface SponsorSocialProfile
 */
export interface SponsorSocialProfile {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof SponsorSocialProfile
     */
    id: number;
    /**
     * the user this is for
     * @type {number}
     * @memberof SponsorSocialProfile
     */
    user_id: number;
    /**
     * the name of the project the profile is for
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    name: string;
    /**
     * a url to an image to use to represent the profile
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    image: string;
    /**
     * a url to the facebook presence for the profile
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    facebook: string;
    /**
     * a url to the twitter feed for the profile
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    twitter: string;
    /**
     * a url to the linked in presence for the profile
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    linkedin: string;
    /**
     * ?
     * @type {number}
     * @memberof SponsorSocialProfile
     */
    status: number;
    /**
     * for user profiles, if true the user should receive notification
     * @type {boolean}
     * @memberof SponsorSocialProfile
     */
    notification: boolean;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof SponsorSocialProfile
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof SponsorSocialProfile
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof SponsorSocialProfile
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof SponsorSocialProfile
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_COBRANDED_TO_SOCIAL_PROFILE and described as: 
     * @type {Array<AllUser>}
     * @memberof SponsorSocialProfile
     */
    all_users_cobranded_to_social_profile: Array<AllUser>;
    /**
     * This was created from the details of the foreign key FK_EVENTS_TO_ISSUER and described as: 
     * @type {Array<Event>}
     * @memberof SponsorSocialProfile
     */
    events_to_issuer: Array<Event>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_ISSUER_ID_ORDERS and described as: 
     * @type {Array<InvestmentOrder>}
     * @memberof SponsorSocialProfile
     */
    orders: Array<InvestmentOrder>;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_INTENDED_TRADES_INTENDED_ISSUER_ID_INTENDED_TRADES and described as: 
     * @type {Array<InvestorIntendedTrades>}
     * @memberof SponsorSocialProfile
     */
    intended_trades: Array<InvestorIntendedTrades>;
    /**
     * This was created from the details of the foreign key FK_PROJECTS_ISSUER_ID_PROJECTS and described as: 
     * @type {Array<Project>}
     * @memberof SponsorSocialProfile
     */
    projects: Array<Project>;
    /**
     * This was created from the details of the foreign key FK_PROPERTY_INTEREST_INTEREST_BY_ID_INTERESTS and described as: 
     * @type {Array<ProjectInterest>}
     * @memberof SponsorSocialProfile
     */
    interests: Array<ProjectInterest>;
    /**
     * This was created from the details of the foreign key FK_PROPERTY_INTEREST_INTEREST_IN_ID_INVESTOR_INTERESTS and described as: 
     * @type {Array<ProjectInterest>}
     * @memberof SponsorSocialProfile
     */
    investor_interests: Array<ProjectInterest>;
    /**
     * This was created from the details of the foreign key FK_USER_ISSUER_ASSOCIATIONS_TO_ISSUER_ID_ASSOCIATED_USERS and described as: 
     * @type {Array<UserIssuerAssociation>}
     * @memberof SponsorSocialProfile
     */
    user_issuer_associations_to_issuer_id_associated_users: Array<UserIssuerAssociation>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIAL_LINKUP_LINK_ID_FOLLOWERS and described as: 
     * @type {Array<SocialProfileFollowing>}
     * @memberof SponsorSocialProfile
     */
    followers: Array<SocialProfileFollowing>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIAL_LINKUP_PROFILE_ID_FOLLOWING and described as: 
     * @type {Array<SocialProfileFollowing>}
     * @memberof SponsorSocialProfile
     */
    following: Array<SocialProfileFollowing>;
    /**
     * 
     * @type {Array<UserSocialPost>}
     * @memberof SponsorSocialProfile
     */
    posts: Array<UserSocialPost>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_COUNTRY_ID and described as: 
     * @type {Country}
     * @memberof SponsorSocialProfile
     */
    country: Country;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_JURISDICTION_ID_PROFILES and described as: 
     * @type {Province}
     * @memberof SponsorSocialProfile
     */
    jurisdiction: Province;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof SponsorSocialProfile
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_PROJECT_ID_PROFILES and described as: 
     * @type {Project}
     * @memberof SponsorSocialProfile
     */
    project: Project;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_PROVINCE_ID and described as: 
     * @type {Province}
     * @memberof SponsorSocialProfile
     */
    province: Province;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_STATUTE_ID_TO_PROVINCES and described as: 
     * @type {Province}
     * @memberof SponsorSocialProfile
     */
    statute: Province;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_USER_ID_PROFILES and described as: 
     * @type {AllUser}
     * @memberof SponsorSocialProfile
     */
    user: AllUser;
    /**
     * This was created from the details of the foreign key FK_WEB_HOOKS_TO_ISSUER and described as: 
     * @type {Array<WebHook>}
     * @memberof SponsorSocialProfile
     */
    web_hooks_to_issuer: Array<WebHook>;
    /**
     * if the profile is for a project, the id of that project
     * @type {number}
     * @memberof SponsorSocialProfile
     */
    project_id: number;
    /**
     * 
     * @type {number}
     * @memberof SponsorSocialProfile
     */
    developer_number: number;
    /**
     * the short identifier of an issuer
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    issuer_code: string;
    /**
     * ?
     * @type {number}
     * @memberof SponsorSocialProfile
     */
    profile_type: number;
    /**
     * the legal name of the project
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    legal_name: string;
    /**
     * the id of the sub-national region that legal proceeding are bound to
     * @type {number}
     * @memberof SponsorSocialProfile
     */
    jurisdiction_id: number;
    /**
     * the id of the sub-national region that the project must comply to for compliance
     * @type {number}
     * @memberof SponsorSocialProfile
     */
    statute_id: number;
    /**
     * the id of the country the project is in
     * @type {number}
     * @memberof SponsorSocialProfile
     */
    country_id: number;
    /**
     * the id of the province the project is in
     * @type {number}
     * @memberof SponsorSocialProfile
     */
    province_id: number;
    /**
     * the city the project is in
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    city: string;
    /**
     * the legal address of the project
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    address: string;
    /**
     * the mailing identifier for the address of the project
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    zip: string;
    /**
     * the email address to use to contact the project with
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    email: string;
    /**
     * the telephone number to use to reach out to contact someone at the project
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    phone: string;
    /**
     * the quantity of projects that have been built so far
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    total_built: string;
    /**
     * the total value of properties built by the originator of the project so far
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    value_built: string;
    /**
     * a caret (^) separated list of category tags for the invesmtent. the tags are currently unstructured
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    categories: string;
    /**
     * for a user profile, the tags of projects that person is interested in
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    self_category: string;
    /**
     * 
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    bg_image: string;
    /**
     * 
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    signup_image: string;
    /**
     * 
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    signup_guide_image: string;
    /**
     * a url to an image to use for the project when it is displayed &quot;in our network&quot;
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    network_logo: string;
    /**
     * a url to an image to use for the background of the project when it is displayed &quot;in our network&quot;
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    network_background: string;
    /**
     * 
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    rep_first_name: string;
    /**
     * 
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    rep_last_name: string;
    /**
     * 
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    rep_email: string;
    /**
     * 
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    rep_phone: string;
    /**
     * 
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    signup_greeting: string;
    /**
     * 
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    signup_paragraph: string;
    /**
     * 
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    signup_link: string;
    /**
     * 
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    signup_logo: string;
    /**
     * 
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    investment_step_cc_email: string;
    /**
     * if true (1) they are actively investing
     * @type {number}
     * @memberof SponsorSocialProfile
     */
    investment_status: number;
    /**
     * if true, a message alerting the user to a financial incentive should be shown on the referral page
     * @type {boolean}
     * @memberof SponsorSocialProfile
     */
    show_referral_text: boolean;
    /**
     * if true (1), users signing up cobranded to this profile will have the referall dialog presented to them at the end of the proces
     * @type {boolean}
     * @memberof SponsorSocialProfile
     */
    show_referral_dialog: boolean;
    /**
     * 
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    signup_splash_logo: string;
    /**
     * a url to an image to show in the background for the project
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    background_image: string;
    /**
     * 
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    referral_bonus: string;
    /**
     * 
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    referral_disclaimer: string;
    /**
     * 
     * @type {Date}
     * @memberof SponsorSocialProfile
     */
    referral_expiry: Date;
    /**
     * 
     * @type {string}
     * @memberof SponsorSocialProfile
     */
    referral_link: string;
}
/**
 * 
 * @export
 * @interface SupportEngineer
 */
export interface SupportEngineer {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof SupportEngineer
     */
    id: number;
    /**
     * the id of the user who performs support
     * @type {number}
     * @memberof SupportEngineer
     */
    user_id: number;
    /**
     * the users first name
     * @type {string}
     * @memberof SupportEngineer
     */
    first_name: string;
    /**
     * the users last name
     * @type {string}
     * @memberof SupportEngineer
     */
    last_name: string;
    /**
     * the identifier of the role the person performs for support
     * @type {string}
     * @memberof SupportEngineer
     */
    title: string;
    /**
     * the telephone number to use to contact them
     * @type {string}
     * @memberof SupportEngineer
     */
    phone: string;
    /**
     * the email address to use to contact the person
     * @type {string}
     * @memberof SupportEngineer
     */
    email: string;
    /**
     * a url to the photo used to represent the support person
     * @type {string}
     * @memberof SupportEngineer
     */
    image: string;
    /**
     * a paragraph describing the persons role
     * @type {string}
     * @memberof SupportEngineer
     */
    content: string;
    /**
     * uncertain
     * @type {number}
     * @memberof SupportEngineer
     */
    profile_cap: number;
    /**
     * the ordinal position of the engineer
     * @type {number}
     * @memberof SupportEngineer
     */
    sort_order: number;
    /**
     * if true the support engineer should be shown
     * @type {boolean}
     * @memberof SupportEngineer
     */
    visible: boolean;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof SupportEngineer
     */
    is_deleted: boolean;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof SupportEngineer
     */
    updatetime: Date;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof SupportEngineer
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof SupportEngineer
     */
    createtime: Date;
    /**
     * This was created from the details of the foreign key FK_SUPPORT_ENGINEERS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof SupportEngineer
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_SUPPORT_ENGINEERS_USER_ID_OWNER_USER and described as: 
     * @type {AllUser}
     * @memberof SupportEngineer
     */
    user: AllUser;
}
/**
 * 
 * @export
 * @interface UserAnswer
 */
export interface UserAnswer {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof UserAnswer
     */
    id: number;
    /**
     * the user this is for
     * @type {number}
     * @memberof UserAnswer
     */
    user_id: number;
    /**
     * the id of the user entity that they were acting on the behalf of when they answered it
     * @type {number}
     * @memberof UserAnswer
     */
    entity_id: number;
    /**
     * the identification of what category the question is about
     * @type {number}
     * @memberof UserAnswer
     */
    category: number;
    /**
     * the id of the question that was answered
     * @type {number}
     * @memberof UserAnswer
     */
    question_id: number;
    /**
     * the text of the question when it was asked. assuming the original question has not change this should still match it
     * @type {string}
     * @memberof UserAnswer
     */
    question_text: string;
    /**
     * the way on the ui in which the question was answer
     * @type {number}
     * @memberof UserAnswer
     */
    answer_type: number;
    /**
     * the response the user provided. if its a multipart response then its a collection of caret (^) separated answers
     * @type {string}
     * @memberof UserAnswer
     */
    answer_text: string;
    /**
     * identify if the answer has been confirmed
     * @type {boolean}
     * @memberof UserAnswer
     */
    is_confirmed: boolean;
    /**
     * extra notes by admin for the user answer of a question
     * @type {string}
     * @memberof UserAnswer
     */
    notes: string;
    /**
     * unused
     * @type {number}
     * @memberof UserAnswer
     */
    status: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof UserAnswer
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof UserAnswer
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof UserAnswer
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof UserAnswer
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_USERS_QUESTIONARY_ENTITY_ANSWERS and described as: 
     * @type {UserEntity}
     * @memberof UserAnswer
     */
    entity: UserEntity;
    /**
     * This was created from the details of the foreign key FK_USERS_QUESTIONARY_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof UserAnswer
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_USERS_QUESTIONARY_QUESTION_ID_ANSWERS and described as: 
     * @type {RegistrationQuestion}
     * @memberof UserAnswer
     */
    question: RegistrationQuestion;
    /**
     * This was created from the details of the foreign key FK_USERS_QUESTIONARY_USER_ID_ANSWERS and described as: 
     * @type {AllUser}
     * @memberof UserAnswer
     */
    user: AllUser;
}
/**
 * 
 * @export
 * @interface UserBankingDetails
 */
export interface UserBankingDetails {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof UserBankingDetails
     */
    id: number;
    /**
     * the foreign ID of the user side of this relationship
     * @type {number}
     * @memberof UserBankingDetails
     */
    user_id: number;
    /**
     * the foreign ID of the user entity the details are associated with, if any
     * @type {number}
     * @memberof UserBankingDetails
     */
    user_entity_id: number;
    /**
     * the foreign ID of the joint subscriber the details are also associated with, if any
     * @type {number}
     * @memberof UserBankingDetails
     */
    joint_subscriber_id: number;
    /**
     * the name associated with the details
     * @type {string}
     * @memberof UserBankingDetails
     */
    beneficiary_name: string;
    /**
     * the securely encrypted data representing the users banking details
     * @type {string}
     * @memberof UserBankingDetails
     */
    encrypted_data: string;
    /**
     * whether the users data is saved securely offline - if 1, encrypted_data should be blank as the value is stored elsewhere
     * @type {boolean}
     * @memberof UserBankingDetails
     */
    stored_offline: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof UserBankingDetails
     */
    last_changed_by_id: number;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof UserBankingDetails
     */
    updatetime: Date;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof UserBankingDetails
     */
    createtime: Date;
    /**
     * This was created from the details of the foreign key FK_USERS_BANKING_DETAILS_TO_JOINT_USER and described as: 
     * @type {AllUser}
     * @memberof UserBankingDetails
     */
    joint_subscriber: AllUser;
    /**
     * This was created from the details of the foreign key FK_USERS_BANKING_DETAILS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof UserBankingDetails
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_USERS_BANKING_DETAILS_TO_USER_ENTITY and described as: 
     * @type {UserEntity}
     * @memberof UserBankingDetails
     */
    user_entity: UserEntity;
    /**
     * This was created from the details of the foreign key FK_USERS_BANKING_DETAILS_TO_USER and described as: 
     * @type {AllUser}
     * @memberof UserBankingDetails
     */
    user: AllUser;
}
/**
 * 
 * @export
 * @interface UserBasic
 */
export interface UserBasic {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof UserBasic
     */
    id: number;
    /**
     * the category of user this is (i&#x3D;investor, a&#x3D;admin, c&#x3D;issuer admin)
     * @type {string}
     * @memberof UserBasic
     */
    user_type: string;
    /**
     * the first name of the person who uses the account
     * @type {string}
     * @memberof UserBasic
     */
    first_name: string;
    /**
     * the initial of the persons last name
     * @type {string}
     * @memberof UserBasic
     */
    last_initial: string;
    /**
     * 
     * @type {number}
     * @memberof UserBasic
     */
    cobranded_client_of_id: number;
    /**
     * the name of the file that holds the avatars picture. this is the resouce relative, not site relative.
     * @type {string}
     * @memberof UserBasic
     */
    avatar_image_file_name: string;
    /**
     * the point in time the user first signed up
     * @type {Date}
     * @memberof UserBasic
     */
    signup_date: Date;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof UserBasic
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof UserBasic
     */
    last_changed_by_id: number;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof UserBasic
     */
    updatetime: Date;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof UserBasic
     */
    createtime: Date;
}
/**
 * 
 * @export
 * @interface UserBeneficiary
 */
export interface UserBeneficiary {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof UserBeneficiary
     */
    id: number;
    /**
     * the type of entitye this is. for trusts its 2
     * @type {number}
     * @memberof UserBeneficiary
     */
    type: number;
    /**
     * the user this is for
     * @type {number}
     * @memberof UserBeneficiary
     */
    user_id: number;
    /**
     * the fs id for the corporation
     * @type {string}
     * @memberof UserBeneficiary
     */
    client_number: string;
    /**
     * the legal name of the corporation
     * @type {string}
     * @memberof UserBeneficiary
     */
    name: string;
    /**
     * the street addresss of where the corporation is located
     * @type {string}
     * @memberof UserBeneficiary
     */
    address: string;
    /**
     * the second line of the street address for where the corporation is located
     * @type {string}
     * @memberof UserBeneficiary
     */
    address2: string;
    /**
     * 
     * @type {string}
     * @memberof UserBeneficiary
     */
    apt_number: string;
    /**
     * the id of the country where the company is located
     * @type {number}
     * @memberof UserBeneficiary
     */
    country_id: number;
    /**
     * the id of the province for where the company is located
     * @type {number}
     * @memberof UserBeneficiary
     */
    province_id: number;
    /**
     * the postal identifier for where the company is located
     * @type {string}
     * @memberof UserBeneficiary
     */
    zip: string;
    /**
     * the city for where the company is located
     * @type {string}
     * @memberof UserBeneficiary
     */
    city: string;
    /**
     * a url to an additional document if required to clarify disbursements
     * @type {string}
     * @memberof UserBeneficiary
     */
    pdf_file: string;
    /**
     * the usability state of the trust
     * @type {number}
     * @memberof UserBeneficiary
     */
    status: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof UserBeneficiary
     */
    is_deleted: boolean;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof UserBeneficiary
     */
    createtime: Date;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof UserBeneficiary
     */
    last_changed_by_id: number;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof UserBeneficiary
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_FFBA_ASSOCIATION_TO_USER_ENTITY and described as: 
     * @type {Array<FfbaAssociation>}
     * @memberof UserBeneficiary
     */
    ffba_association_to_user_entity: Array<FfbaAssociation>;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_EARNINGS_USER_ENTITY_ID_EARNINGS and described as: 
     * @type {Array<InvestorEarning>}
     * @memberof UserBeneficiary
     */
    earnings: Array<InvestorEarning>;
    /**
     * This was created from the details of the foreign key FK_USERS_BANKING_DETAILS_TO_USER_ENTITY and described as: 
     * @type {Array<UserBankingDetails>}
     * @memberof UserBeneficiary
     */
    users_banking_details_to_user_entity: Array<UserBankingDetails>;
    /**
     * This was created from the details of the foreign key FK_USERS_ENTITY_COMPANY_PROVINCE_ID_INVESTOR_COMPANIES and described as: 
     * @type {Province}
     * @memberof UserBeneficiary
     */
    company_province: Province;
    /**
     * This was created from the details of the foreign key FK_USERS_ENTITY_COUNTRY_ID_INVESTOR_COMPANIES and described as: 
     * @type {Country}
     * @memberof UserBeneficiary
     */
    country: Country;
    /**
     * This was created from the details of the foreign key FK_USERS_ENTITY_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof UserBeneficiary
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_USERS_ENTITY_PROVINCE_ID_INVESTOR_COMPANIES and described as: 
     * @type {Province}
     * @memberof UserBeneficiary
     */
    province: Province;
    /**
     * This was created from the details of the foreign key FK_USERS_ENTITY_USER_ID_ENTITIES and described as: 
     * @type {AllUser}
     * @memberof UserBeneficiary
     */
    user: AllUser;
    /**
     * This was created from the details of the foreign key FK_USERS_QUESTIONARY_ENTITY_ANSWERS and described as: 
     * @type {Array<UserAnswer>}
     * @memberof UserBeneficiary
     */
    users_questionary_entity_answers: Array<UserAnswer>;
    /**
     * The first name of the beneficiary
     * @type {string}
     * @memberof UserBeneficiary
     */
    beneficiary_first_name: string;
    /**
     * The last name of the beneficiary
     * @type {string}
     * @memberof UserBeneficiary
     */
    beneficiary_last_name: string;
    /**
     * the relationship the beneficiary has with the entities founder
     * @type {string}
     * @memberof UserBeneficiary
     */
    beneficiary_relationship: string;
    /**
     * the percentage portion this beneficiary has of the entity
     * @type {string}
     * @memberof UserBeneficiary
     */
    beneficiary_share: string;
    /**
     * general purpose comments
     * @type {string}
     * @memberof UserBeneficiary
     */
    comments: string;
}
/**
 * 
 * @export
 * @interface UserCorporation
 */
export interface UserCorporation {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof UserCorporation
     */
    id: number;
    /**
     * the type of entitye this is. for trusts its 2
     * @type {number}
     * @memberof UserCorporation
     */
    type: number;
    /**
     * the user this is for
     * @type {number}
     * @memberof UserCorporation
     */
    user_id: number;
    /**
     * the fs id for the corporation
     * @type {string}
     * @memberof UserCorporation
     */
    client_number: string;
    /**
     * the legal name of the corporation
     * @type {string}
     * @memberof UserCorporation
     */
    name: string;
    /**
     * the street addresss of where the corporation is located
     * @type {string}
     * @memberof UserCorporation
     */
    address: string;
    /**
     * the second line of the street address for where the corporation is located
     * @type {string}
     * @memberof UserCorporation
     */
    address2: string;
    /**
     * 
     * @type {string}
     * @memberof UserCorporation
     */
    apt_number: string;
    /**
     * the id of the country where the company is located
     * @type {number}
     * @memberof UserCorporation
     */
    country_id: number;
    /**
     * the id of the province for where the company is located
     * @type {number}
     * @memberof UserCorporation
     */
    province_id: number;
    /**
     * the postal identifier for where the company is located
     * @type {string}
     * @memberof UserCorporation
     */
    zip: string;
    /**
     * the city for where the company is located
     * @type {string}
     * @memberof UserCorporation
     */
    city: string;
    /**
     * a url to an additional document if required to clarify disbursements
     * @type {string}
     * @memberof UserCorporation
     */
    pdf_file: string;
    /**
     * the usability state of the trust
     * @type {number}
     * @memberof UserCorporation
     */
    status: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof UserCorporation
     */
    is_deleted: boolean;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof UserCorporation
     */
    createtime: Date;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof UserCorporation
     */
    last_changed_by_id: number;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof UserCorporation
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_FFBA_ASSOCIATION_TO_USER_ENTITY and described as: 
     * @type {Array<FfbaAssociation>}
     * @memberof UserCorporation
     */
    ffba_association_to_user_entity: Array<FfbaAssociation>;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_EARNINGS_USER_ENTITY_ID_EARNINGS and described as: 
     * @type {Array<InvestorEarning>}
     * @memberof UserCorporation
     */
    earnings: Array<InvestorEarning>;
    /**
     * This was created from the details of the foreign key FK_USERS_BANKING_DETAILS_TO_USER_ENTITY and described as: 
     * @type {Array<UserBankingDetails>}
     * @memberof UserCorporation
     */
    users_banking_details_to_user_entity: Array<UserBankingDetails>;
    /**
     * This was created from the details of the foreign key FK_USERS_ENTITY_COMPANY_PROVINCE_ID_INVESTOR_COMPANIES and described as: 
     * @type {Province}
     * @memberof UserCorporation
     */
    company_province: Province;
    /**
     * This was created from the details of the foreign key FK_USERS_ENTITY_COUNTRY_ID_INVESTOR_COMPANIES and described as: 
     * @type {Country}
     * @memberof UserCorporation
     */
    country: Country;
    /**
     * This was created from the details of the foreign key FK_USERS_ENTITY_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof UserCorporation
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_USERS_ENTITY_PROVINCE_ID_INVESTOR_COMPANIES and described as: 
     * @type {Province}
     * @memberof UserCorporation
     */
    province: Province;
    /**
     * This was created from the details of the foreign key FK_USERS_ENTITY_USER_ID_ENTITIES and described as: 
     * @type {AllUser}
     * @memberof UserCorporation
     */
    user: AllUser;
    /**
     * This was created from the details of the foreign key FK_USERS_QUESTIONARY_ENTITY_ANSWERS and described as: 
     * @type {Array<UserAnswer>}
     * @memberof UserCorporation
     */
    users_questionary_entity_answers: Array<UserAnswer>;
    /**
     * the number the company is identified by according to the registration authority where it is domiciled
     * @type {string}
     * @memberof UserCorporation
     */
    reg_no: string;
    /**
     * the name of the are where the company is domiciled
     * @type {string}
     * @memberof UserCorporation
     */
    reg_domicile: string;
    /**
     * the id of the province that the company is in
     * @type {number}
     * @memberof UserCorporation
     */
    company_province_id: number;
    /**
     * a short description of the type of business the company is engaged in
     * @type {string}
     * @memberof UserCorporation
     */
    business_nature: string;
    /**
     * the point in time the trust was registered
     * @type {string}
     * @memberof UserCorporation
     */
    registration_date: string;
    /**
     * an email address to use to contact individuals at the company
     * @type {string}
     * @memberof UserCorporation
     */
    email: string;
    /**
     * a telephone number to use to contact people at the company
     * @type {string}
     * @memberof UserCorporation
     */
    phone: string;
    /**
     * an extenstion to the telephone number to use to contact people at the company
     * @type {string}
     * @memberof UserCorporation
     */
    phone_ext: string;
    /**
     * ^separated list of the first names of the directoros of the company
     * @type {string}
     * @memberof UserCorporation
     */
    director_first_name: string;
    /**
     * ^separated list of the last names of the directors of the company
     * @type {string}
     * @memberof UserCorporation
     */
    director_last_name: string;
    /**
     * ^separated list of the addresses of the directors
     * @type {string}
     * @memberof UserCorporation
     */
    director_address: string;
    /**
     * ^separated list of whether the director is a canadian
     * @type {string}
     * @memberof UserCorporation
     */
    director_canadian: string;
    /**
     * ^separated list of the shareholders first names
     * @type {string}
     * @memberof UserCorporation
     */
    shareholder_first_name: string;
    /**
     * ^separated list of the shareholders last names
     * @type {string}
     * @memberof UserCorporation
     */
    shareholder_last_name: string;
    /**
     * ^separated list of the shareholders addresses
     * @type {string}
     * @memberof UserCorporation
     */
    shareholder_address: string;
    /**
     * ^separated list of whether the shareholder is canadian
     * @type {string}
     * @memberof UserCorporation
     */
    shareholder_canadian: string;
    /**
     * ^separated list of the signing officers first names
     * @type {string}
     * @memberof UserCorporation
     */
    signing_officer_first_name: string;
    /**
     * ^separated list of the signing officers last names
     * @type {string}
     * @memberof UserCorporation
     */
    signing_officer_last_name: string;
    /**
     * ^separated list of the signing officers titles
     * @type {string}
     * @memberof UserCorporation
     */
    signing_officer_title: string;
    /**
     * if true, the account holder is a shareholder
     * @type {string}
     * @memberof UserCorporation
     */
    shareholder: string;
}
/**
 * 
 * @export
 * @interface UserEntity
 */
export interface UserEntity {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof UserEntity
     */
    id: number;
    /**
     * the type of entitye this is. for trusts its 2
     * @type {number}
     * @memberof UserEntity
     */
    type: number;
    /**
     * the user this is for
     * @type {number}
     * @memberof UserEntity
     */
    user_id: number;
    /**
     * the fs id for the corporation
     * @type {string}
     * @memberof UserEntity
     */
    client_number: string;
    /**
     * the legal name of the corporation
     * @type {string}
     * @memberof UserEntity
     */
    name: string;
    /**
     * the street addresss of where the corporation is located
     * @type {string}
     * @memberof UserEntity
     */
    address: string;
    /**
     * the second line of the street address for where the corporation is located
     * @type {string}
     * @memberof UserEntity
     */
    address2: string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    apt_number: string;
    /**
     * the id of the country where the company is located
     * @type {number}
     * @memberof UserEntity
     */
    country_id: number;
    /**
     * the id of the province for where the company is located
     * @type {number}
     * @memberof UserEntity
     */
    province_id: number;
    /**
     * the postal identifier for where the company is located
     * @type {string}
     * @memberof UserEntity
     */
    zip: string;
    /**
     * the city for where the company is located
     * @type {string}
     * @memberof UserEntity
     */
    city: string;
    /**
     * a url to an additional document if required to clarify disbursements
     * @type {string}
     * @memberof UserEntity
     */
    pdf_file: string;
    /**
     * the usability state of the trust
     * @type {number}
     * @memberof UserEntity
     */
    status: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof UserEntity
     */
    is_deleted: boolean;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof UserEntity
     */
    createtime: Date;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof UserEntity
     */
    last_changed_by_id: number;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof UserEntity
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_FFBA_ASSOCIATION_TO_USER_ENTITY and described as: 
     * @type {Array<FfbaAssociation>}
     * @memberof UserEntity
     */
    ffba_association_to_user_entity: Array<FfbaAssociation>;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_EARNINGS_USER_ENTITY_ID_EARNINGS and described as: 
     * @type {Array<InvestorEarning>}
     * @memberof UserEntity
     */
    earnings: Array<InvestorEarning>;
    /**
     * This was created from the details of the foreign key FK_USERS_BANKING_DETAILS_TO_USER_ENTITY and described as: 
     * @type {Array<UserBankingDetails>}
     * @memberof UserEntity
     */
    users_banking_details_to_user_entity: Array<UserBankingDetails>;
    /**
     * This was created from the details of the foreign key FK_USERS_ENTITY_COMPANY_PROVINCE_ID_INVESTOR_COMPANIES and described as: 
     * @type {Province}
     * @memberof UserEntity
     */
    company_province: Province;
    /**
     * This was created from the details of the foreign key FK_USERS_ENTITY_COUNTRY_ID_INVESTOR_COMPANIES and described as: 
     * @type {Country}
     * @memberof UserEntity
     */
    country: Country;
    /**
     * This was created from the details of the foreign key FK_USERS_ENTITY_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof UserEntity
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_USERS_ENTITY_PROVINCE_ID_INVESTOR_COMPANIES and described as: 
     * @type {Province}
     * @memberof UserEntity
     */
    province: Province;
    /**
     * This was created from the details of the foreign key FK_USERS_ENTITY_USER_ID_ENTITIES and described as: 
     * @type {AllUser}
     * @memberof UserEntity
     */
    user: AllUser;
    /**
     * This was created from the details of the foreign key FK_USERS_QUESTIONARY_ENTITY_ANSWERS and described as: 
     * @type {Array<UserAnswer>}
     * @memberof UserEntity
     */
    users_questionary_entity_answers: Array<UserAnswer>;
}
/**
 * 
 * @export
 * @interface UserFinancialKyc
 */
export interface UserFinancialKyc {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof UserFinancialKyc
     */
    id: number;
    /**
     * the user this is for
     * @type {number}
     * @memberof UserFinancialKyc
     */
    user_id: number;
    /**
     * the type of employment the user currently enagages in.
     * @type {string}
     * @memberof UserFinancialKyc
     */
    employment_status: string;
    /**
     * the name of the organization that the user was employed by at the time
     * @type {string}
     * @memberof UserFinancialKyc
     */
    employer: string;
    /**
     * the industry the employment was engaged in
     * @type {string}
     * @memberof UserFinancialKyc
     */
    industry: string;
    /**
     * the title/position the person held for their employment
     * @type {string}
     * @memberof UserFinancialKyc
     */
    position: string;
    /**
     * the number of years that the person has been working for that employer
     * @type {string}
     * @memberof UserFinancialKyc
     */
    years: string;
    /**
     * text describing how income is being reported. Combined with spouse, single
     * @type {string}
     * @memberof UserFinancialKyc
     */
    income_includes_partner: string;
    /**
     * the current year when these details were entered
     * @type {number}
     * @memberof UserFinancialKyc
     */
    year_entered: number;
    /**
     * projected income for the current year
     * @type {number}
     * @memberof UserFinancialKyc
     */
    income_current_year: number;
    /**
     * actual income for the previous year
     * @type {number}
     * @memberof UserFinancialKyc
     */
    income_previous_year: number;
    /**
     * actual income for 2 years ago
     * @type {number}
     * @memberof UserFinancialKyc
     */
    income_two_years_ago: number;
    /**
     * a range of their net financial assets
     * @type {number}
     * @memberof UserFinancialKyc
     */
    net_financial_assest_range: number;
    /**
     * are they currently an advisor dealer?
     * @type {string}
     * @memberof UserFinancialKyc
     */
    advisor_dealer: string;
    /**
     * does this person represent an advisor dealer?
     * @type {string}
     * @memberof UserFinancialKyc
     */
    represents_advisor_dealer: string;
    /**
     * are they managing an account for an advisor dealer
     * @type {string}
     * @memberof UserFinancialKyc
     */
    acting_on_account_for_advisor_dealer: string;
    /**
     * their net assets in a range
     * @type {number}
     * @memberof UserFinancialKyc
     */
    net_assets_range: number;
    /**
     * 
     * @type {number}
     * @memberof UserFinancialKyc
     */
    income_curr_new: number;
    /**
     * 
     * @type {number}
     * @memberof UserFinancialKyc
     */
    income_curr1_new: number;
    /**
     * 
     * @type {number}
     * @memberof UserFinancialKyc
     */
    income_curr2_new: number;
    /**
     * 
     * @type {number}
     * @memberof UserFinancialKyc
     */
    income_net_new: number;
    /**
     * 
     * @type {number}
     * @memberof UserFinancialKyc
     */
    assets_net_new: number;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof UserFinancialKyc
     */
    last_changed_by_id: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof UserFinancialKyc
     */
    is_deleted: boolean;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof UserFinancialKyc
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof UserFinancialKyc
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_USERS_EMPLOYMENT_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof UserFinancialKyc
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_USERS_EMPLOYMENT_USER_ID_FINANCIAL_KYC and described as: 
     * @type {AllUser}
     * @memberof UserFinancialKyc
     */
    user: AllUser;
}
/**
 * 
 * @export
 * @interface UserInvitation
 */
export interface UserInvitation {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof UserInvitation
     */
    id: number;
    /**
     * the user this is for
     * @type {number}
     * @memberof UserInvitation
     */
    user_id: number;
    /**
     * the first name of the person that was invited
     * @type {string}
     * @memberof UserInvitation
     */
    first_name: string;
    /**
     * the last name of the person that was invited
     * @type {string}
     * @memberof UserInvitation
     */
    last_name: string;
    /**
     * the email address that the invitation was sent to
     * @type {string}
     * @memberof UserInvitation
     */
    email: string;
    /**
     * the message that was entered by the user to extended the invitations
     * @type {string}
     * @memberof UserInvitation
     */
    message: string;
    /**
     * unused
     * @type {number}
     * @memberof UserInvitation
     */
    status: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof UserInvitation
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof UserInvitation
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof UserInvitation
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof UserInvitation
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_USERS_INVITEE_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof UserInvitation
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_USERS_INVITEE_USER_ID_INVITATIONS and described as: 
     * @type {AllUser}
     * @memberof UserInvitation
     */
    user: AllUser;
}
/**
 * 
 * @export
 * @interface UserIssuerAssociation
 */
export interface UserIssuerAssociation {
    /**
     * the unique, internal identifier for the association
     * @type {number}
     * @memberof UserIssuerAssociation
     */
    id: number;
    /**
     * the id of the user that has a direct association with an issuer
     * @type {number}
     * @memberof UserIssuerAssociation
     */
    user_id: number;
    /**
     * the issuer that has the association with the user
     * @type {number}
     * @memberof UserIssuerAssociation
     */
    issuer_id: number;
    /**
     * a characterization of the association between the user and the issuer
     * @type {string}
     * @memberof UserIssuerAssociation
     */
    association_type: string;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof UserIssuerAssociation
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof UserIssuerAssociation
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof UserIssuerAssociation
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof UserIssuerAssociation
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_USER_ISSUER_ASSOCIATIONS_TO_ISSUER_ID_ASSOCIATED_USERS and described as: 
     * @type {UserSocialProfile}
     * @memberof UserIssuerAssociation
     */
    issuer: UserSocialProfile;
    /**
     * This was created from the details of the foreign key FK_USER_ISSUER_ASSOCIATIONS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof UserIssuerAssociation
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_USER_ISSUER_ASSOCIATIONS_TO_USER_ID_ISSUER_ASSOCIATIONS and described as: 
     * @type {AllUser}
     * @memberof UserIssuerAssociation
     */
    user: AllUser;
}
/**
 * 
 * @export
 * @interface UserPdf
 */
export interface UserPdf {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof UserPdf
     */
    id: number;
    /**
     * the user this is for
     * @type {number}
     * @memberof UserPdf
     */
    user_id: number;
    /**
     * an order that the document is related to
     * @type {number}
     * @memberof UserPdf
     */
    order_id: number;
    /**
     * a textual (non-code) categorization of the purpose of the pdf
     * @type {string}
     * @memberof UserPdf
     */
    pdf_type: string;
    /**
     * a url to the pdf
     * @type {string}
     * @memberof UserPdf
     */
    pdf_name: string;
    /**
     * unused
     * @type {string}
     * @memberof UserPdf
     */
    exel_name: string;
    /**
     * if the pdf is relevant to a given point in time, such as a bank statement, this is the month of that point in time
     * @type {number}
     * @memberof UserPdf
     */
    relevant_month: number;
    /**
     * if the pdf is relevant to a given point in time, such as a bank statement, this is the year of that point in time
     * @type {number}
     * @memberof UserPdf
     */
    relevant_year: number;
    /**
     * generic remarks about what the pdf is
     * @type {string}
     * @memberof UserPdf
     */
    remarks: string;
    /**
     * an effective date of the pdf
     * @type {Date}
     * @memberof UserPdf
     */
    effective_date: Date;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof UserPdf
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof UserPdf
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof UserPdf
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof UserPdf
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_EVENTS_TO_USERS_PDF and described as: 
     * @type {Array<Event>}
     * @memberof UserPdf
     */
    events_to_users_pdf: Array<Event>;
    /**
     * This was created from the details of the foreign key FK_USERS_PDF_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof UserPdf
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_USERS_PDF_ORDER_ID_PDFS and described as: 
     * @type {InvestmentOrder}
     * @memberof UserPdf
     */
    order: InvestmentOrder;
    /**
     * This was created from the details of the foreign key FK_USERS_PDF_USER_ID_PDFS and described as: 
     * @type {AllUser}
     * @memberof UserPdf
     */
    user: AllUser;
}
/**
 * 
 * @export
 * @interface UserRelationship
 */
export interface UserRelationship {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof UserRelationship
     */
    id: number;
    /**
     * one of the users involved in the relationship
     * @type {number}
     * @memberof UserRelationship
     */
    user_1_id: number;
    /**
     * one of the users involved in the relationship
     * @type {number}
     * @memberof UserRelationship
     */
    user_2_id: number;
    /**
     * the nature of the relationship (enumerated)
     * @type {string}
     * @memberof UserRelationship
     */
    relationship_type: string;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof UserRelationship
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof UserRelationship
     */
    last_changed_by_id: number;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof UserRelationship
     */
    updatetime: Date;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof UserRelationship
     */
    createtime: Date;
    /**
     * This was created from the details of the foreign key FK_USER_RELATIONSHIP_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof UserRelationship
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_USER_RELATIONSHIP_TO_USER_1 and described as: 
     * @type {AllUser}
     * @memberof UserRelationship
     */
    user_1: AllUser;
    /**
     * This was created from the details of the foreign key FK_USER_RELATIONSHIP_TO_USER_2 and described as: 
     * @type {AllUser}
     * @memberof UserRelationship
     */
    user_2: AllUser;
}
/**
 * 
 * @export
 * @interface UserRequest
 */
export interface UserRequest {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof UserRequest
     */
    id: number;
    /**
     * the user this is for
     * @type {number}
     * @memberof UserRequest
     */
    user_id: number;
    /**
     * a textual code representing the type of request
     * @type {string}
     * @memberof UserRequest
     */
    request: string;
    /**
     * the body message of the request. this is a sentence or paragraph
     * @type {string}
     * @memberof UserRequest
     */
    message: string;
    /**
     * the state in which a request may be
     * @type {number}
     * @memberof UserRequest
     */
    status: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof UserRequest
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof UserRequest
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof UserRequest
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof UserRequest
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_USERS_REQUEST_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof UserRequest
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_USERS_REQUEST_USER_ID_REQUESTS and described as: 
     * @type {AllUser}
     * @memberof UserRequest
     */
    user: AllUser;
}
/**
 * 
 * @export
 * @interface UserSignupEvent
 */
export interface UserSignupEvent {
    /**
     * 
     * @type {number}
     * @memberof UserSignupEvent
     */
    user_id: number;
    /**
     * 
     * @type {Date}
     * @memberof UserSignupEvent
     */
    basic_info: Date;
    /**
     * 
     * @type {Date}
     * @memberof UserSignupEvent
     */
    kyc_done: Date;
    /**
     * 
     * @type {Date}
     * @memberof UserSignupEvent
     */
    retrn_pref: Date;
    /**
     * 
     * @type {Date}
     * @memberof UserSignupEvent
     */
    time_hrzn: Date;
    /**
     * 
     * @type {Date}
     * @memberof UserSignupEvent
     */
    risk_toler: Date;
}
/**
 * 
 * @export
 * @interface UserSocialPost
 */
export interface UserSocialPost {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof UserSocialPost
     */
    id: number;
    /**
     * a categorization of the post type. some of the fields below are directly dependent upon the post type for their context
     * @type {string}
     * @memberof UserSocialPost
     */
    post_type: string;
    /**
     * the id of the user profile that originated the item to be shared
     * @type {number}
     * @memberof UserSocialPost
     */
    profile_id: number;
    /**
     * the id of of a related profile. the specific purpose of this link is dependent upon the type of post
     * @type {number}
     * @memberof UserSocialPost
     */
    related_profile_id: number;
    /**
     * the id of a post that this is related to
     * @type {number}
     * @memberof UserSocialPost
     */
    related_post_id: number;
    /**
     * the state the post may be in
     * @type {number}
     * @memberof UserSocialPost
     */
    status: number;
    /**
     * the text of this post
     * @type {string}
     * @memberof UserSocialPost
     */
    post: string;
    /**
     * a url to an image to display alongside this post
     * @type {string}
     * @memberof UserSocialPost
     */
    image: string;
    /**
     * doesnt seem to be used
     * @type {string}
     * @memberof UserSocialPost
     */
    link: string;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof UserSocialPost
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof UserSocialPost
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof UserSocialPost
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof UserSocialPost
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIAL_POST_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof UserSocialPost
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIAL_POST_LINK_ID_POSTS and described as: 
     * @type {UserSocialProfile}
     * @memberof UserSocialPost
     */
    related_profile: UserSocialProfile;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIAL_POST_PROFILE_ID_POSTS and described as: 
     * @type {UserSocialProfile}
     * @memberof UserSocialPost
     */
    profile: UserSocialProfile;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIAL_POST_RELATED_POST_ID_RELATED_TO and described as: 
     * @type {UserSocialPost}
     * @memberof UserSocialPost
     */
    related_post: UserSocialPost;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIAL_POST_RELATED_POST_ID_RELATED_TO and described as: 
     * @type {Array<UserSocialPost>}
     * @memberof UserSocialPost
     */
    related_to: Array<UserSocialPost>;
}
/**
 * 
 * @export
 * @interface UserSocialProfile
 */
export interface UserSocialProfile {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof UserSocialProfile
     */
    id: number;
    /**
     * the user this is for
     * @type {number}
     * @memberof UserSocialProfile
     */
    user_id: number;
    /**
     * the name of the project the profile is for
     * @type {string}
     * @memberof UserSocialProfile
     */
    name: string;
    /**
     * a url to an image to use to represent the profile
     * @type {string}
     * @memberof UserSocialProfile
     */
    image: string;
    /**
     * a url to the facebook presence for the profile
     * @type {string}
     * @memberof UserSocialProfile
     */
    facebook: string;
    /**
     * a url to the twitter feed for the profile
     * @type {string}
     * @memberof UserSocialProfile
     */
    twitter: string;
    /**
     * a url to the linked in presence for the profile
     * @type {string}
     * @memberof UserSocialProfile
     */
    linkedin: string;
    /**
     * ?
     * @type {number}
     * @memberof UserSocialProfile
     */
    status: number;
    /**
     * for user profiles, if true the user should receive notification
     * @type {boolean}
     * @memberof UserSocialProfile
     */
    notification: boolean;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof UserSocialProfile
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof UserSocialProfile
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof UserSocialProfile
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof UserSocialProfile
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_ALL_USERS_COBRANDED_TO_SOCIAL_PROFILE and described as: 
     * @type {Array<AllUser>}
     * @memberof UserSocialProfile
     */
    all_users_cobranded_to_social_profile: Array<AllUser>;
    /**
     * This was created from the details of the foreign key FK_EVENTS_TO_ISSUER and described as: 
     * @type {Array<Event>}
     * @memberof UserSocialProfile
     */
    events_to_issuer: Array<Event>;
    /**
     * This was created from the details of the foreign key FK_INVESTMENT_ORDERS_ISSUER_ID_ORDERS and described as: 
     * @type {Array<InvestmentOrder>}
     * @memberof UserSocialProfile
     */
    orders: Array<InvestmentOrder>;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_INTENDED_TRADES_INTENDED_ISSUER_ID_INTENDED_TRADES and described as: 
     * @type {Array<InvestorIntendedTrades>}
     * @memberof UserSocialProfile
     */
    intended_trades: Array<InvestorIntendedTrades>;
    /**
     * This was created from the details of the foreign key FK_PROJECTS_ISSUER_ID_PROJECTS and described as: 
     * @type {Array<Project>}
     * @memberof UserSocialProfile
     */
    projects: Array<Project>;
    /**
     * This was created from the details of the foreign key FK_PROPERTY_INTEREST_INTEREST_BY_ID_INTERESTS and described as: 
     * @type {Array<ProjectInterest>}
     * @memberof UserSocialProfile
     */
    interests: Array<ProjectInterest>;
    /**
     * This was created from the details of the foreign key FK_PROPERTY_INTEREST_INTEREST_IN_ID_INVESTOR_INTERESTS and described as: 
     * @type {Array<ProjectInterest>}
     * @memberof UserSocialProfile
     */
    investor_interests: Array<ProjectInterest>;
    /**
     * This was created from the details of the foreign key FK_USER_ISSUER_ASSOCIATIONS_TO_ISSUER_ID_ASSOCIATED_USERS and described as: 
     * @type {Array<UserIssuerAssociation>}
     * @memberof UserSocialProfile
     */
    user_issuer_associations_to_issuer_id_associated_users: Array<UserIssuerAssociation>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIAL_LINKUP_LINK_ID_FOLLOWERS and described as: 
     * @type {Array<SocialProfileFollowing>}
     * @memberof UserSocialProfile
     */
    followers: Array<SocialProfileFollowing>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIAL_LINKUP_PROFILE_ID_FOLLOWING and described as: 
     * @type {Array<SocialProfileFollowing>}
     * @memberof UserSocialProfile
     */
    following: Array<SocialProfileFollowing>;
    /**
     * 
     * @type {Array<UserSocialPost>}
     * @memberof UserSocialProfile
     */
    posts: Array<UserSocialPost>;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_COUNTRY_ID and described as: 
     * @type {Country}
     * @memberof UserSocialProfile
     */
    country: Country;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_JURISDICTION_ID_PROFILES and described as: 
     * @type {Province}
     * @memberof UserSocialProfile
     */
    jurisdiction: Province;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof UserSocialProfile
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_PROJECT_ID_PROFILES and described as: 
     * @type {Project}
     * @memberof UserSocialProfile
     */
    project: Project;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_PROVINCE_ID and described as: 
     * @type {Province}
     * @memberof UserSocialProfile
     */
    province: Province;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_STATUTE_ID_TO_PROVINCES and described as: 
     * @type {Province}
     * @memberof UserSocialProfile
     */
    statute: Province;
    /**
     * This was created from the details of the foreign key FK_USERS_SOCIALPROFILE_USER_ID_PROFILES and described as: 
     * @type {AllUser}
     * @memberof UserSocialProfile
     */
    user: AllUser;
    /**
     * This was created from the details of the foreign key FK_WEB_HOOKS_TO_ISSUER and described as: 
     * @type {Array<WebHook>}
     * @memberof UserSocialProfile
     */
    web_hooks_to_issuer: Array<WebHook>;
}
/**
 * 
 * @export
 * @interface UserSubscription
 */
export interface UserSubscription {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof UserSubscription
     */
    id: number;
    /**
     * the user this is for
     * @type {number}
     * @memberof UserSubscription
     */
    user_id: number;
    /**
     * a textual categorization of what the user is asking for notifications about
     * @type {string}
     * @memberof UserSubscription
     */
    flag: string;
    /**
     * the email address to send the notifications to
     * @type {string}
     * @memberof UserSubscription
     */
    email: string;
    /**
     * the current state of the subscription
     * @type {number}
     * @memberof UserSubscription
     */
    status: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof UserSubscription
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof UserSubscription
     */
    last_changed_by_id: number;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof UserSubscription
     */
    createtime: Date;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof UserSubscription
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_USERS_SUBSCRIBE_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof UserSubscription
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_USERS_SUBSCRIBE_USER_ID_SUBSCRIPTIONS and described as: 
     * @type {AllUser}
     * @memberof UserSubscription
     */
    user: AllUser;
}
/**
 * 
 * @export
 * @interface UserTrust
 */
export interface UserTrust {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof UserTrust
     */
    id: number;
    /**
     * the type of entitye this is. for trusts its 2
     * @type {number}
     * @memberof UserTrust
     */
    type: number;
    /**
     * the user this is for
     * @type {number}
     * @memberof UserTrust
     */
    user_id: number;
    /**
     * the fs id for the corporation
     * @type {string}
     * @memberof UserTrust
     */
    client_number: string;
    /**
     * the legal name of the corporation
     * @type {string}
     * @memberof UserTrust
     */
    name: string;
    /**
     * the street addresss of where the corporation is located
     * @type {string}
     * @memberof UserTrust
     */
    address: string;
    /**
     * the second line of the street address for where the corporation is located
     * @type {string}
     * @memberof UserTrust
     */
    address2: string;
    /**
     * 
     * @type {string}
     * @memberof UserTrust
     */
    apt_number: string;
    /**
     * the id of the country where the company is located
     * @type {number}
     * @memberof UserTrust
     */
    country_id: number;
    /**
     * the id of the province for where the company is located
     * @type {number}
     * @memberof UserTrust
     */
    province_id: number;
    /**
     * the postal identifier for where the company is located
     * @type {string}
     * @memberof UserTrust
     */
    zip: string;
    /**
     * the city for where the company is located
     * @type {string}
     * @memberof UserTrust
     */
    city: string;
    /**
     * a url to an additional document if required to clarify disbursements
     * @type {string}
     * @memberof UserTrust
     */
    pdf_file: string;
    /**
     * the usability state of the trust
     * @type {number}
     * @memberof UserTrust
     */
    status: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof UserTrust
     */
    is_deleted: boolean;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof UserTrust
     */
    createtime: Date;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof UserTrust
     */
    last_changed_by_id: number;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof UserTrust
     */
    updatetime: Date;
    /**
     * This was created from the details of the foreign key FK_FFBA_ASSOCIATION_TO_USER_ENTITY and described as: 
     * @type {Array<FfbaAssociation>}
     * @memberof UserTrust
     */
    ffba_association_to_user_entity: Array<FfbaAssociation>;
    /**
     * This was created from the details of the foreign key FK_INVESTOR_EARNINGS_USER_ENTITY_ID_EARNINGS and described as: 
     * @type {Array<InvestorEarning>}
     * @memberof UserTrust
     */
    earnings: Array<InvestorEarning>;
    /**
     * This was created from the details of the foreign key FK_USERS_BANKING_DETAILS_TO_USER_ENTITY and described as: 
     * @type {Array<UserBankingDetails>}
     * @memberof UserTrust
     */
    users_banking_details_to_user_entity: Array<UserBankingDetails>;
    /**
     * This was created from the details of the foreign key FK_USERS_ENTITY_COMPANY_PROVINCE_ID_INVESTOR_COMPANIES and described as: 
     * @type {Province}
     * @memberof UserTrust
     */
    company_province: Province;
    /**
     * This was created from the details of the foreign key FK_USERS_ENTITY_COUNTRY_ID_INVESTOR_COMPANIES and described as: 
     * @type {Country}
     * @memberof UserTrust
     */
    country: Country;
    /**
     * This was created from the details of the foreign key FK_USERS_ENTITY_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof UserTrust
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_USERS_ENTITY_PROVINCE_ID_INVESTOR_COMPANIES and described as: 
     * @type {Province}
     * @memberof UserTrust
     */
    province: Province;
    /**
     * This was created from the details of the foreign key FK_USERS_ENTITY_USER_ID_ENTITIES and described as: 
     * @type {AllUser}
     * @memberof UserTrust
     */
    user: AllUser;
    /**
     * This was created from the details of the foreign key FK_USERS_QUESTIONARY_ENTITY_ANSWERS and described as: 
     * @type {Array<UserAnswer>}
     * @memberof UserTrust
     */
    users_questionary_entity_answers: Array<UserAnswer>;
    /**
     * the point in time the trust was registered
     * @type {string}
     * @memberof UserTrust
     */
    registration_date: string;
    /**
     * an email address to use to contact individuals at the company
     * @type {string}
     * @memberof UserTrust
     */
    email: string;
    /**
     * a telephone number to use to contact people at the company
     * @type {string}
     * @memberof UserTrust
     */
    phone: string;
    /**
     * an extenstion to the telephone number to use to contact people at the company
     * @type {string}
     * @memberof UserTrust
     */
    phone_ext: string;
    /**
     * ^caret separated list of the first names of the trustees
     * @type {string}
     * @memberof UserTrust
     */
    trustee_first_name: string;
    /**
     * caret separated list of the last names of the trustees
     * @type {string}
     * @memberof UserTrust
     */
    trustee_last_name: string;
    /**
     * caret separated list of the titles of the trustees
     * @type {string}
     * @memberof UserTrust
     */
    trustee_title: string;
}
/**
 * 
 * @export
 * @interface WebHook
 */
export interface WebHook {
    /**
     * the unique internal identifier (primary key) of the row
     * @type {number}
     * @memberof WebHook
     */
    id: number;
    /**
     * the type of event that triggers this hook being called
     * @type {string}
     * @memberof WebHook
     */
    event_type: string;
    /**
     * the url that gets called
     * @type {string}
     * @memberof WebHook
     */
    url: string;
    /**
     * the user that the hook listens to
     * @type {number}
     * @memberof WebHook
     */
    user_id: number;
    /**
     * the project that the hook listens to
     * @type {number}
     * @memberof WebHook
     */
    project_id: number;
    /**
     * the issuer (social profile) the that hook listens to
     * @type {number}
     * @memberof WebHook
     */
    issuer_id: number;
    /**
     * if true, this row is &quot;logically&quot; deleted. that is, its not to be used any more and is kept for historical/audit purposes only
     * @type {boolean}
     * @memberof WebHook
     */
    is_deleted: boolean;
    /**
     * the id of the user that made the last change or in the case of its initial creation, the user that created it
     * @type {number}
     * @memberof WebHook
     */
    last_changed_by_id: number;
    /**
     * the last point in time this row was modified
     * @type {Date}
     * @memberof WebHook
     */
    updatetime: Date;
    /**
     * the point in time this row was first created regardless of modifications
     * @type {Date}
     * @memberof WebHook
     */
    createtime: Date;
    /**
     * This was created from the details of the foreign key FK_WEB_HOOKS_TO_ISSUER and described as: 
     * @type {UserSocialProfile}
     * @memberof WebHook
     */
    issuer: UserSocialProfile;
    /**
     * This was created from the details of the foreign key FK_WEB_HOOKS_LAST_CHANGED_BY_ID_CHANGES and described as: 
     * @type {AllUser}
     * @memberof WebHook
     */
    last_changed_by: AllUser;
    /**
     * This was created from the details of the foreign key FK_WEB_HOOKS_PROJECT and described as: 
     * @type {Project}
     * @memberof WebHook
     */
    project: Project;
    /**
     * This was created from the details of the foreign key FK_WEB_HOOKS_TO_USER and described as: 
     * @type {AllUser}
     * @memberof WebHook
     */
    user: AllUser;
}
/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates new instances of AdminModule based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<AdminModule>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminModuleApiCreate(body: Array<AdminModule>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling adminModuleApiCreate.');
            }
            const localVarPath = `/AdminModule`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;AdminModule&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of AdminModule that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminModuleApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/AdminModule`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of AdminModule with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminModuleApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling adminModuleApiFindOneById.');
            }
            const localVarPath = `/AdminModule/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of AdminModule with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminModuleApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling adminModuleApiRemove.');
            }
            const localVarPath = `/AdminModule/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of AdminModule that are provided
         * @param {Array<AdminModule>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminModuleApiUpdate(body: Array<AdminModule>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling adminModuleApiUpdate.');
            }
            const localVarPath = `/AdminModule`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;AdminModule&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of AdminUser based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<AdminUser>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserApiCreate(body: Array<AdminUser>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling adminUserApiCreate.');
            }
            const localVarPath = `/AdminUser`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;AdminUser&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of AdminUser that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/AdminUser`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of AdminUser with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling adminUserApiFindOneById.');
            }
            const localVarPath = `/AdminUser/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of AdminUser with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling adminUserApiRemove.');
            }
            const localVarPath = `/AdminUser/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of AdminUser that are provided
         * @param {Array<AdminUser>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserApiUpdate(body: Array<AdminUser>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling adminUserApiUpdate.');
            }
            const localVarPath = `/AdminUser`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;AdminUser&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of AllUserAnswer based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<AllUserAnswer>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserAnswerApiCreate(body: Array<AllUserAnswer>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling allUserAnswerApiCreate.');
            }
            const localVarPath = `/AllUserAnswer`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;AllUserAnswer&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of AllUserAnswer that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserAnswerApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/AllUserAnswer`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of AllUserAnswer with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserAnswerApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling allUserAnswerApiFindOneById.');
            }
            const localVarPath = `/AllUserAnswer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of AllUserAnswer with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserAnswerApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling allUserAnswerApiRemove.');
            }
            const localVarPath = `/AllUserAnswer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of AllUserAnswer that are provided
         * @param {Array<AllUserAnswer>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserAnswerApiUpdate(body: Array<AllUserAnswer>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling allUserAnswerApiUpdate.');
            }
            const localVarPath = `/AllUserAnswer`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;AllUserAnswer&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of AllUser based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<AllUser>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserApiCreate(body: Array<AllUser>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling allUserApiCreate.');
            }
            const localVarPath = `/AllUser`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;AllUser&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of AllUser that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/AllUser`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of AllUser with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling allUserApiFindOneById.');
            }
            const localVarPath = `/AllUser/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a preference setting for a specific user
         * @param {string} preference The name of the preference to get the value of
         * @param {number} id The id of the user to get the preference of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserApiGetPreference(preference: string, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'preference' is not null or undefined
            if (preference === null || preference === undefined) {
                throw new RequiredError('preference', 'Required parameter preference was null or undefined when calling allUserApiGetPreference.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling allUserApiGetPreference.');
            }
            const localVarPath = `/AllUser/{id}/preference/{preference}`
                .replace(`{${"preference"}}`, encodeURIComponent(String(preference)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of AllUser with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling allUserApiRemove.');
            }
            const localVarPath = `/AllUser/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set a single preference for a given user
         * @param {Preference} body 
         * @param {number} id The id of the user to set the preference for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserApiSetPreference(body: Preference, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling allUserApiSetPreference.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling allUserApiSetPreference.');
            }
            const localVarPath = `/AllUser/{id}/preference`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Preference" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of AllUser that are provided
         * @param {Array<AllUser>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserApiUpdate(body: Array<AllUser>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling allUserApiUpdate.');
            }
            const localVarPath = `/AllUser`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;AllUser&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of BackgroundProcess based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<BackgroundProcess>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backgroundProcessApiCreate(body: Array<BackgroundProcess>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling backgroundProcessApiCreate.');
            }
            const localVarPath = `/BackgroundProcess`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;BackgroundProcess&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of BackgroundProcess that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backgroundProcessApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/BackgroundProcess`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of BackgroundProcess with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backgroundProcessApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling backgroundProcessApiFindOneById.');
            }
            const localVarPath = `/BackgroundProcess/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of BackgroundProcess with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backgroundProcessApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling backgroundProcessApiRemove.');
            }
            const localVarPath = `/BackgroundProcess/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of BackgroundProcess that are provided
         * @param {Array<BackgroundProcess>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backgroundProcessApiUpdate(body: Array<BackgroundProcess>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling backgroundProcessApiUpdate.');
            }
            const localVarPath = `/BackgroundProcess`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;BackgroundProcess&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of ComputedAccount that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedAccountApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/ComputedAccount`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of ComputedAccountIncome based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ComputedAccountIncome>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedAccountIncomeApiCreate(body: Array<ComputedAccountIncome>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling computedAccountIncomeApiCreate.');
            }
            const localVarPath = `/ComputedAccountIncome`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ComputedAccountIncome&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of ComputedAccountIncome that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedAccountIncomeApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/ComputedAccountIncome`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of ComputedAccountIncome with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedAccountIncomeApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling computedAccountIncomeApiFindOneById.');
            }
            const localVarPath = `/ComputedAccountIncome/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of ComputedAccountIncome with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedAccountIncomeApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling computedAccountIncomeApiRemove.');
            }
            const localVarPath = `/ComputedAccountIncome/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ComputedAccountIncome that are provided
         * @param {Array<ComputedAccountIncome>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedAccountIncomeApiUpdate(body: Array<ComputedAccountIncome>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling computedAccountIncomeApiUpdate.');
            }
            const localVarPath = `/ComputedAccountIncome`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ComputedAccountIncome&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of ComputedAccountPosition that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedAccountPositionApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/ComputedAccountPosition`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of ComputedAccountTotalIncome that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedAccountTotalIncomeApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/ComputedAccountTotalIncome`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of ComputedProjectIncome based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ComputedProjectIncome>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedProjectIncomeApiCreate(body: Array<ComputedProjectIncome>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling computedProjectIncomeApiCreate.');
            }
            const localVarPath = `/ComputedProjectIncome`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ComputedProjectIncome&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of ComputedProjectIncome that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedProjectIncomeApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/ComputedProjectIncome`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of ComputedProjectIncome with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedProjectIncomeApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling computedProjectIncomeApiFindOneById.');
            }
            const localVarPath = `/ComputedProjectIncome/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of ComputedProjectIncome with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedProjectIncomeApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling computedProjectIncomeApiRemove.');
            }
            const localVarPath = `/ComputedProjectIncome/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ComputedProjectIncome that are provided
         * @param {Array<ComputedProjectIncome>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedProjectIncomeApiUpdate(body: Array<ComputedProjectIncome>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling computedProjectIncomeApiUpdate.');
            }
            const localVarPath = `/ComputedProjectIncome`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ComputedProjectIncome&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of ComputedProjectTotalIncome that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedProjectTotalIncomeApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/ComputedProjectTotalIncome`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of Country based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<Country>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryApiCreate(body: Array<Country>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling countryApiCreate.');
            }
            const localVarPath = `/Country`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Country&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of Country that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/Country`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of Country with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling countryApiFindOneById.');
            }
            const localVarPath = `/Country/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of Country with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling countryApiRemove.');
            }
            const localVarPath = `/Country/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of Country that are provided
         * @param {Array<Country>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryApiUpdate(body: Array<Country>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling countryApiUpdate.');
            }
            const localVarPath = `/Country`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Country&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of Event based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<Event>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventApiCreate(body: Array<Event>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling eventApiCreate.');
            }
            const localVarPath = `/Event`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Event&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of Event that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/Event`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of Event with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling eventApiFindOneById.');
            }
            const localVarPath = `/Event/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of Event with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling eventApiRemove.');
            }
            const localVarPath = `/Event/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of Event that are provided
         * @param {Array<Event>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventApiUpdate(body: Array<Event>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling eventApiUpdate.');
            }
            const localVarPath = `/Event`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Event&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of ExemptDistributionOption based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ExemptDistributionOption>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exemptDistributionOptionApiCreate(body: Array<ExemptDistributionOption>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling exemptDistributionOptionApiCreate.');
            }
            const localVarPath = `/ExemptDistributionOption`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ExemptDistributionOption&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of ExemptDistributionOption that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exemptDistributionOptionApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/ExemptDistributionOption`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of ExemptDistributionOption with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exemptDistributionOptionApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling exemptDistributionOptionApiFindOneById.');
            }
            const localVarPath = `/ExemptDistributionOption/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of ExemptDistributionOption with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exemptDistributionOptionApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling exemptDistributionOptionApiRemove.');
            }
            const localVarPath = `/ExemptDistributionOption/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ExemptDistributionOption that are provided
         * @param {Array<ExemptDistributionOption>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exemptDistributionOptionApiUpdate(body: Array<ExemptDistributionOption>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling exemptDistributionOptionApiUpdate.');
            }
            const localVarPath = `/ExemptDistributionOption`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ExemptDistributionOption&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of FfbaAssociation based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<FfbaAssociation>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ffbaAssociationApiCreate(body: Array<FfbaAssociation>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling ffbaAssociationApiCreate.');
            }
            const localVarPath = `/FfbaAssociation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;FfbaAssociation&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of FfbaAssociation that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ffbaAssociationApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/FfbaAssociation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of FfbaAssociation with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ffbaAssociationApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling ffbaAssociationApiFindOneById.');
            }
            const localVarPath = `/FfbaAssociation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of FfbaAssociation with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ffbaAssociationApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling ffbaAssociationApiRemove.');
            }
            const localVarPath = `/FfbaAssociation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of FfbaAssociation that are provided
         * @param {Array<FfbaAssociation>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ffbaAssociationApiUpdate(body: Array<FfbaAssociation>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling ffbaAssociationApiUpdate.');
            }
            const localVarPath = `/FfbaAssociation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;FfbaAssociation&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cross check all cms cobranders with hubspot properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotContactCobrandersControllerCheckCobranders(options: any = {}): FetchArgs {
            const localVarPath = `/HubspotContactCobranders/checkCobranders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cross check all cms investors with hubspot contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotContactControllerCheckInvestors(options: any = {}): FetchArgs {
            const localVarPath = `/HubspotContact/checkInvestors`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Synchronize a single cms investor with a corresponding hubspot contact
         * @param {number} id The id of the investor to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotContactControllerSyncInvestor(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling hubspotContactControllerSyncInvestor.');
            }
            const localVarPath = `/HubspotContact/syncInvestor/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cross check all cms orders with hubspot deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotDealControllerCheckAllDeals(options: any = {}): FetchArgs {
            const localVarPath = `/HubspotDeal/checkDeals`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cross check all cms orders with hubspot deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotDealControllerCheckOrders(options: any = {}): FetchArgs {
            const localVarPath = `/HubspotDeal/checkOrders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new order based on the details of a deal whoose id is provided
         * @param {string} dealId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotDealControllerCreate(dealId: string, options: any = {}): FetchArgs {
            // verify required parameter 'dealId' is not null or undefined
            if (dealId === null || dealId === undefined) {
                throw new RequiredError('dealId', 'Required parameter dealId was null or undefined when calling hubspotDealControllerCreate.');
            }
            const localVarPath = `/HubspotDeal/new/{dealId}`
                .replace(`{${"dealId"}}`, encodeURIComponent(String(dealId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Synchronize a single cms order with a corresponding hubspot deal
         * @param {number} id The id of the order to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotDealControllerSyncOrder(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling hubspotDealControllerSyncOrder.');
            }
            const localVarPath = `/HubspotDeal/syncOrder/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Ensure a single project is reflected in hubspot custom objects correctly
         * @param {number} id The id of the project to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotProjectControllerCheckProject(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling hubspotProjectControllerCheckProject.');
            }
            const localVarPath = `/HubspotProject/syncProject/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cross check all cms projects with hubspot properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotProjectControllerCheckProjects(options: any = {}): FetchArgs {
            const localVarPath = `/HubspotProject/checkProjects`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of ImportedContact based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ImportedContact>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedContactApiCreate(body: Array<ImportedContact>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling importedContactApiCreate.');
            }
            const localVarPath = `/ImportedContact`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ImportedContact&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of ImportedContact that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedContactApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/ImportedContact`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of ImportedContact with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedContactApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling importedContactApiFindOneById.');
            }
            const localVarPath = `/ImportedContact/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of ImportedContact with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedContactApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling importedContactApiRemove.');
            }
            const localVarPath = `/ImportedContact/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ImportedContact that are provided
         * @param {Array<ImportedContact>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedContactApiUpdate(body: Array<ImportedContact>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling importedContactApiUpdate.');
            }
            const localVarPath = `/ImportedContact`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ImportedContact&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of InvestmentOrder based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<InvestmentOrder>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentOrderApiCreate(body: Array<InvestmentOrder>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling investmentOrderApiCreate.');
            }
            const localVarPath = `/InvestmentOrder`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;InvestmentOrder&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of InvestmentOrder that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentOrderApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/InvestmentOrder`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of InvestmentOrder with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentOrderApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling investmentOrderApiFindOneById.');
            }
            const localVarPath = `/InvestmentOrder/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of InvestmentOrder with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentOrderApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling investmentOrderApiRemove.');
            }
            const localVarPath = `/InvestmentOrder/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of InvestmentOrder that are provided
         * @param {Array<InvestmentOrder>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentOrderApiUpdate(body: Array<InvestmentOrder>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling investmentOrderApiUpdate.');
            }
            const localVarPath = `/InvestmentOrder`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;InvestmentOrder&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of InvestmentTransaction based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<InvestmentTransaction>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentTransactionApiCreate(body: Array<InvestmentTransaction>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling investmentTransactionApiCreate.');
            }
            const localVarPath = `/InvestmentTransaction`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;InvestmentTransaction&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of InvestmentTransaction that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentTransactionApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/InvestmentTransaction`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of InvestmentTransaction with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentTransactionApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling investmentTransactionApiFindOneById.');
            }
            const localVarPath = `/InvestmentTransaction/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of InvestmentTransaction with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentTransactionApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling investmentTransactionApiRemove.');
            }
            const localVarPath = `/InvestmentTransaction/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of InvestmentTransaction that are provided
         * @param {Array<InvestmentTransaction>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentTransactionApiUpdate(body: Array<InvestmentTransaction>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling investmentTransactionApiUpdate.');
            }
            const localVarPath = `/InvestmentTransaction`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;InvestmentTransaction&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of InvestmentWatchlist based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<InvestmentWatchlist>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWatchlistApiCreate(body: Array<InvestmentWatchlist>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling investmentWatchlistApiCreate.');
            }
            const localVarPath = `/InvestmentWatchlist`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;InvestmentWatchlist&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of InvestmentWatchlist that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWatchlistApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/InvestmentWatchlist`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of InvestmentWatchlist with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWatchlistApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling investmentWatchlistApiFindOneById.');
            }
            const localVarPath = `/InvestmentWatchlist/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of InvestmentWatchlist with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWatchlistApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling investmentWatchlistApiRemove.');
            }
            const localVarPath = `/InvestmentWatchlist/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of InvestmentWatchlist that are provided
         * @param {Array<InvestmentWatchlist>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWatchlistApiUpdate(body: Array<InvestmentWatchlist>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling investmentWatchlistApiUpdate.');
            }
            const localVarPath = `/InvestmentWatchlist`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;InvestmentWatchlist&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of InvestmentWithdrawal based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<InvestmentWithdrawal>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWithdrawalApiCreate(body: Array<InvestmentWithdrawal>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling investmentWithdrawalApiCreate.');
            }
            const localVarPath = `/InvestmentWithdrawal`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;InvestmentWithdrawal&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of InvestmentWithdrawal that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWithdrawalApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/InvestmentWithdrawal`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of InvestmentWithdrawal with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWithdrawalApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling investmentWithdrawalApiFindOneById.');
            }
            const localVarPath = `/InvestmentWithdrawal/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of InvestmentWithdrawal with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWithdrawalApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling investmentWithdrawalApiRemove.');
            }
            const localVarPath = `/InvestmentWithdrawal/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of InvestmentWithdrawal that are provided
         * @param {Array<InvestmentWithdrawal>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWithdrawalApiUpdate(body: Array<InvestmentWithdrawal>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling investmentWithdrawalApiUpdate.');
            }
            const localVarPath = `/InvestmentWithdrawal`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;InvestmentWithdrawal&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of Investor based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<Investor>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiCreate(body: Array<Investor>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling investorApiCreate.');
            }
            const localVarPath = `/Investor`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Investor&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of Investor that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/Investor`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of Investor with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling investorApiFindOneById.');
            }
            const localVarPath = `/Investor/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all non-deleted orders for a specific investor
         * @param {number} id The id of the investor to get all non-deleted orders for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiGetAllNonDeletedOrders(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling investorApiGetAllNonDeletedOrders.');
            }
            const localVarPath = `/Investor/{id}/allNonDeletedOrders`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the annual investment limits for the given investor
         * @param {number} id The id of the investor to get the annual investment limits for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiGetAnnualInvestmentLimits(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling investorApiGetAnnualInvestmentLimits.');
            }
            const localVarPath = `/Investor/{id}/annualInvestmentLimits`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the oldest non-deleted order in the last year for a given investor
         * @param {number} id the id of the investor to get the oldest non-deleted order in the last year for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiGetOldestNonDeletedOrderLastYear(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling investorApiGetOldestNonDeletedOrderLastYear.');
            }
            const localVarPath = `/Investor/{id}/oldestNonDeletedOrderLastYear`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the total amount of all orders in the last year for a given investor
         * @param {number} id the id of the investor to get the total amount of all orders in the last year for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiGetTotalAmountInvestedInLastYear(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling investorApiGetTotalAmountInvestedInLastYear.');
            }
            const localVarPath = `/Investor/{id}/totalAmountInvestedInLastYear`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of Investor with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling investorApiRemove.');
            }
            const localVarPath = `/Investor/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of Investor that are provided
         * @param {Array<Investor>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiUpdate(body: Array<Investor>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling investorApiUpdate.');
            }
            const localVarPath = `/Investor`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Investor&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of InvestorCobranding that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorCobrandingApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/InvestorCobranding`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of InvestorEarning based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<InvestorEarning>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorEarningApiCreate(body: Array<InvestorEarning>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling investorEarningApiCreate.');
            }
            const localVarPath = `/InvestorEarning`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;InvestorEarning&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of InvestorEarning that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorEarningApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/InvestorEarning`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of InvestorEarning with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorEarningApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling investorEarningApiFindOneById.');
            }
            const localVarPath = `/InvestorEarning/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of InvestorEarning with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorEarningApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling investorEarningApiRemove.');
            }
            const localVarPath = `/InvestorEarning/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of InvestorEarning that are provided
         * @param {Array<InvestorEarning>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorEarningApiUpdate(body: Array<InvestorEarning>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling investorEarningApiUpdate.');
            }
            const localVarPath = `/InvestorEarning`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;InvestorEarning&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of InvestorIntendedTrades based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<InvestorIntendedTrades>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorIntendedTradesApiCreate(body: Array<InvestorIntendedTrades>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling investorIntendedTradesApiCreate.');
            }
            const localVarPath = `/InvestorIntendedTrades`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;InvestorIntendedTrades&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of InvestorIntendedTrades that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorIntendedTradesApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/InvestorIntendedTrades`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of InvestorIntendedTrades with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorIntendedTradesApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling investorIntendedTradesApiFindOneById.');
            }
            const localVarPath = `/InvestorIntendedTrades/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of InvestorIntendedTrades with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorIntendedTradesApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling investorIntendedTradesApiRemove.');
            }
            const localVarPath = `/InvestorIntendedTrades/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of InvestorIntendedTrades that are provided
         * @param {Array<InvestorIntendedTrades>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorIntendedTradesApiUpdate(body: Array<InvestorIntendedTrades>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling investorIntendedTradesApiUpdate.');
            }
            const localVarPath = `/InvestorIntendedTrades`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;InvestorIntendedTrades&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of InvestorSocialProfile based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<InvestorSocialProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorSocialProfileApiCreate(body: Array<InvestorSocialProfile>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling investorSocialProfileApiCreate.');
            }
            const localVarPath = `/InvestorSocialProfile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;InvestorSocialProfile&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of InvestorSocialProfile that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorSocialProfileApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/InvestorSocialProfile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of InvestorSocialProfile with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorSocialProfileApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling investorSocialProfileApiFindOneById.');
            }
            const localVarPath = `/InvestorSocialProfile/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of InvestorSocialProfile with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorSocialProfileApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling investorSocialProfileApiRemove.');
            }
            const localVarPath = `/InvestorSocialProfile/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of InvestorSocialProfile that are provided
         * @param {Array<InvestorSocialProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorSocialProfileApiUpdate(body: Array<InvestorSocialProfile>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling investorSocialProfileApiUpdate.');
            }
            const localVarPath = `/InvestorSocialProfile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;InvestorSocialProfile&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of IssuerAdmin based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<IssuerAdmin>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuerAdminApiCreate(body: Array<IssuerAdmin>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling issuerAdminApiCreate.');
            }
            const localVarPath = `/IssuerAdmin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;IssuerAdmin&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of IssuerAdmin that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuerAdminApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/IssuerAdmin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of IssuerAdmin with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuerAdminApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling issuerAdminApiFindOneById.');
            }
            const localVarPath = `/IssuerAdmin/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of IssuerAdmin with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuerAdminApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling issuerAdminApiRemove.');
            }
            const localVarPath = `/IssuerAdmin/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of IssuerAdmin that are provided
         * @param {Array<IssuerAdmin>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuerAdminApiUpdate(body: Array<IssuerAdmin>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling issuerAdminApiUpdate.');
            }
            const localVarPath = `/IssuerAdmin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;IssuerAdmin&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of Mail based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<Mail>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mailApiCreate(body: Array<Mail>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling mailApiCreate.');
            }
            const localVarPath = `/Mail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Mail&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of Mail that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mailApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/Mail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of Mail with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mailApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling mailApiFindOneById.');
            }
            const localVarPath = `/Mail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of Mail with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mailApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling mailApiRemove.');
            }
            const localVarPath = `/Mail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of Mail that are provided
         * @param {Array<Mail>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mailApiUpdate(body: Array<Mail>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling mailApiUpdate.');
            }
            const localVarPath = `/Mail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Mail&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of Menu based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<Menu>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menuApiCreate(body: Array<Menu>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling menuApiCreate.');
            }
            const localVarPath = `/Menu`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Menu&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of Menu that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menuApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/Menu`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of Menu with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menuApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling menuApiFindOneById.');
            }
            const localVarPath = `/Menu/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of Menu with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menuApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling menuApiRemove.');
            }
            const localVarPath = `/Menu/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of Menu that are provided
         * @param {Array<Menu>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menuApiUpdate(body: Array<Menu>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling menuApiUpdate.');
            }
            const localVarPath = `/Menu`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Menu&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a metrics based on a request saved in the current users specified preference
         * @param {string} preference The name of the preference to get the request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsApiFindByPreference(preference: string, options: any = {}): FetchArgs {
            // verify required parameter 'preference' is not null or undefined
            if (preference === null || preference === undefined) {
                throw new RequiredError('preference', 'Required parameter preference was null or undefined when calling metricsApiFindByPreference.');
            }
            const localVarPath = `/Metrics/preference/{preference}`
                .replace(`{${"preference"}}`, encodeURIComponent(String(preference)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the data associated with the specified metric
         * @param {MetricsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsApiFindOneById(body: MetricsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling metricsApiFindOneById.');
            }
            const localVarPath = `/Metrics`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MetricsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Save the given request as a preference and then get the mtrics
         * @param {MetricsRequest} body 
         * @param {string} preference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsApiSavePreferenceAnGet(body: MetricsRequest, preference: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling metricsApiSavePreferenceAnGet.');
            }
            // verify required parameter 'preference' is not null or undefined
            if (preference === null || preference === undefined) {
                throw new RequiredError('preference', 'Required parameter preference was null or undefined when calling metricsApiSavePreferenceAnGet.');
            }
            const localVarPath = `/Metrics/preference/{preference}`
                .replace(`{${"preference"}}`, encodeURIComponent(String(preference)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MetricsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of ModuleAccess based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ModuleAccess>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleAccessApiCreate(body: Array<ModuleAccess>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling moduleAccessApiCreate.');
            }
            const localVarPath = `/ModuleAccess`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ModuleAccess&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of ModuleAccess that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleAccessApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/ModuleAccess`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of ModuleAccess with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleAccessApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling moduleAccessApiFindOneById.');
            }
            const localVarPath = `/ModuleAccess/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of ModuleAccess with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleAccessApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling moduleAccessApiRemove.');
            }
            const localVarPath = `/ModuleAccess/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ModuleAccess that are provided
         * @param {Array<ModuleAccess>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleAccessApiUpdate(body: Array<ModuleAccess>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling moduleAccessApiUpdate.');
            }
            const localVarPath = `/ModuleAccess`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ModuleAccess&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of NotableInvestorProfile based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<NotableInvestorProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notableInvestorProfileApiCreate(body: Array<NotableInvestorProfile>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling notableInvestorProfileApiCreate.');
            }
            const localVarPath = `/NotableInvestorProfile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;NotableInvestorProfile&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of NotableInvestorProfile that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notableInvestorProfileApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/NotableInvestorProfile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of NotableInvestorProfile with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notableInvestorProfileApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling notableInvestorProfileApiFindOneById.');
            }
            const localVarPath = `/NotableInvestorProfile/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of NotableInvestorProfile with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notableInvestorProfileApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling notableInvestorProfileApiRemove.');
            }
            const localVarPath = `/NotableInvestorProfile/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of NotableInvestorProfile that are provided
         * @param {Array<NotableInvestorProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notableInvestorProfileApiUpdate(body: Array<NotableInvestorProfile>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling notableInvestorProfileApiUpdate.');
            }
            const localVarPath = `/NotableInvestorProfile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;NotableInvestorProfile&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of OrderAcknowledgement based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<OrderAcknowledgement>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementApiCreate(body: Array<OrderAcknowledgement>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling orderAcknowledgementApiCreate.');
            }
            const localVarPath = `/OrderAcknowledgement`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;OrderAcknowledgement&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of OrderAcknowledgement that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/OrderAcknowledgement`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of OrderAcknowledgement with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling orderAcknowledgementApiFindOneById.');
            }
            const localVarPath = `/OrderAcknowledgement/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of OrderAcknowledgement with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling orderAcknowledgementApiRemove.');
            }
            const localVarPath = `/OrderAcknowledgement/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of OrderAcknowledgement that are provided
         * @param {Array<OrderAcknowledgement>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementApiUpdate(body: Array<OrderAcknowledgement>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling orderAcknowledgementApiUpdate.');
            }
            const localVarPath = `/OrderAcknowledgement`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;OrderAcknowledgement&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of OrderAcknowledgementQuestion based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<OrderAcknowledgementQuestion>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementQuestionApiCreate(body: Array<OrderAcknowledgementQuestion>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling orderAcknowledgementQuestionApiCreate.');
            }
            const localVarPath = `/OrderAcknowledgementQuestion`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;OrderAcknowledgementQuestion&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of OrderAcknowledgementQuestion that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementQuestionApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/OrderAcknowledgementQuestion`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of OrderAcknowledgementQuestion with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementQuestionApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling orderAcknowledgementQuestionApiFindOneById.');
            }
            const localVarPath = `/OrderAcknowledgementQuestion/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of OrderAcknowledgementQuestion with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementQuestionApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling orderAcknowledgementQuestionApiRemove.');
            }
            const localVarPath = `/OrderAcknowledgementQuestion/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of OrderAcknowledgementQuestion that are provided
         * @param {Array<OrderAcknowledgementQuestion>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementQuestionApiUpdate(body: Array<OrderAcknowledgementQuestion>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling orderAcknowledgementQuestionApiUpdate.');
            }
            const localVarPath = `/OrderAcknowledgementQuestion`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;OrderAcknowledgementQuestion&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of ProfileBackground based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProfileBackground>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileBackgroundApiCreate(body: Array<ProfileBackground>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling profileBackgroundApiCreate.');
            }
            const localVarPath = `/ProfileBackground`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProfileBackground&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of ProfileBackground that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileBackgroundApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/ProfileBackground`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of ProfileBackground with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileBackgroundApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling profileBackgroundApiFindOneById.');
            }
            const localVarPath = `/ProfileBackground/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProfileBackground with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileBackgroundApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling profileBackgroundApiRemove.');
            }
            const localVarPath = `/ProfileBackground/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProfileBackground that are provided
         * @param {Array<ProfileBackground>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileBackgroundApiUpdate(body: Array<ProfileBackground>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling profileBackgroundApiUpdate.');
            }
            const localVarPath = `/ProfileBackground`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProfileBackground&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of ProjectAccount based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectAccount>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectAccountApiCreate(body: Array<ProjectAccount>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectAccountApiCreate.');
            }
            const localVarPath = `/ProjectAccount`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProjectAccount&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of ProjectAccount that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectAccountApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/ProjectAccount`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of ProjectAccount with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectAccountApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectAccountApiFindOneById.');
            }
            const localVarPath = `/ProjectAccount/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProjectAccount with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectAccountApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectAccountApiRemove.');
            }
            const localVarPath = `/ProjectAccount/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectAccount that are provided
         * @param {Array<ProjectAccount>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectAccountApiUpdate(body: Array<ProjectAccount>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectAccountApiUpdate.');
            }
            const localVarPath = `/ProjectAccount`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProjectAccount&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of Project based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<Project>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectApiCreate(body: Array<Project>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectApiCreate.');
            }
            const localVarPath = `/Project`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Project&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of Project that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/Project`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of Project with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectApiFindOneById.');
            }
            const localVarPath = `/Project/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of Project with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectApiRemove.');
            }
            const localVarPath = `/Project/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of Project that are provided
         * @param {Array<Project>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectApiUpdate(body: Array<Project>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectApiUpdate.');
            }
            const localVarPath = `/Project`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Project&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of ProjectBalanceAdjustment based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectBalanceAdjustment>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectBalanceAdjustmentApiCreate(body: Array<ProjectBalanceAdjustment>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectBalanceAdjustmentApiCreate.');
            }
            const localVarPath = `/ProjectBalanceAdjustment`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProjectBalanceAdjustment&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of ProjectBalanceAdjustment that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectBalanceAdjustmentApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/ProjectBalanceAdjustment`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of ProjectBalanceAdjustment with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectBalanceAdjustmentApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectBalanceAdjustmentApiFindOneById.');
            }
            const localVarPath = `/ProjectBalanceAdjustment/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProjectBalanceAdjustment with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectBalanceAdjustmentApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectBalanceAdjustmentApiRemove.');
            }
            const localVarPath = `/ProjectBalanceAdjustment/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectBalanceAdjustment that are provided
         * @param {Array<ProjectBalanceAdjustment>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectBalanceAdjustmentApiUpdate(body: Array<ProjectBalanceAdjustment>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectBalanceAdjustmentApiUpdate.');
            }
            const localVarPath = `/ProjectBalanceAdjustment`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProjectBalanceAdjustment&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of ProjectDocusignMapping based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectDocusignMapping>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDocusignMappingApiCreate(body: Array<ProjectDocusignMapping>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectDocusignMappingApiCreate.');
            }
            const localVarPath = `/ProjectDocusignMapping`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProjectDocusignMapping&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of ProjectDocusignMapping that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDocusignMappingApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/ProjectDocusignMapping`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of ProjectDocusignMapping with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDocusignMappingApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectDocusignMappingApiFindOneById.');
            }
            const localVarPath = `/ProjectDocusignMapping/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProjectDocusignMapping with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDocusignMappingApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectDocusignMappingApiRemove.');
            }
            const localVarPath = `/ProjectDocusignMapping/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectDocusignMapping that are provided
         * @param {Array<ProjectDocusignMapping>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDocusignMappingApiUpdate(body: Array<ProjectDocusignMapping>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectDocusignMappingApiUpdate.');
            }
            const localVarPath = `/ProjectDocusignMapping`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProjectDocusignMapping&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of ProjectEntity based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectEntity>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityApiCreate(body: Array<ProjectEntity>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectEntityApiCreate.');
            }
            const localVarPath = `/ProjectEntity`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProjectEntity&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of ProjectEntity that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/ProjectEntity`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of ProjectEntity with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectEntityApiFindOneById.');
            }
            const localVarPath = `/ProjectEntity/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProjectEntity with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectEntityApiRemove.');
            }
            const localVarPath = `/ProjectEntity/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectEntity that are provided
         * @param {Array<ProjectEntity>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityApiUpdate(body: Array<ProjectEntity>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectEntityApiUpdate.');
            }
            const localVarPath = `/ProjectEntity`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProjectEntity&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of ProjectEntityDetail based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectEntityDetail>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityDetailApiCreate(body: Array<ProjectEntityDetail>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectEntityDetailApiCreate.');
            }
            const localVarPath = `/ProjectEntityDetail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProjectEntityDetail&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of ProjectEntityDetail that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityDetailApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/ProjectEntityDetail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of ProjectEntityDetail with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityDetailApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectEntityDetailApiFindOneById.');
            }
            const localVarPath = `/ProjectEntityDetail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProjectEntityDetail with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityDetailApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectEntityDetailApiRemove.');
            }
            const localVarPath = `/ProjectEntityDetail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectEntityDetail that are provided
         * @param {Array<ProjectEntityDetail>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityDetailApiUpdate(body: Array<ProjectEntityDetail>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectEntityDetailApiUpdate.');
            }
            const localVarPath = `/ProjectEntityDetail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProjectEntityDetail&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of ProjectImage based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectImage>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectImageApiCreate(body: Array<ProjectImage>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectImageApiCreate.');
            }
            const localVarPath = `/ProjectImage`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProjectImage&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of ProjectImage that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectImageApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/ProjectImage`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of ProjectImage with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectImageApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectImageApiFindOneById.');
            }
            const localVarPath = `/ProjectImage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProjectImage with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectImageApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectImageApiRemove.');
            }
            const localVarPath = `/ProjectImage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectImage that are provided
         * @param {Array<ProjectImage>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectImageApiUpdate(body: Array<ProjectImage>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectImageApiUpdate.');
            }
            const localVarPath = `/ProjectImage`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProjectImage&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of ProjectInterest based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectInterest>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectInterestApiCreate(body: Array<ProjectInterest>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectInterestApiCreate.');
            }
            const localVarPath = `/ProjectInterest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProjectInterest&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of ProjectInterest that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectInterestApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/ProjectInterest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of ProjectInterest with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectInterestApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectInterestApiFindOneById.');
            }
            const localVarPath = `/ProjectInterest/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProjectInterest with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectInterestApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectInterestApiRemove.');
            }
            const localVarPath = `/ProjectInterest/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectInterest that are provided
         * @param {Array<ProjectInterest>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectInterestApiUpdate(body: Array<ProjectInterest>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectInterestApiUpdate.');
            }
            const localVarPath = `/ProjectInterest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProjectInterest&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of ProjectKeybacker based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectKeybacker>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectKeybackerApiCreate(body: Array<ProjectKeybacker>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectKeybackerApiCreate.');
            }
            const localVarPath = `/ProjectKeybacker`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProjectKeybacker&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of ProjectKeybacker that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectKeybackerApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/ProjectKeybacker`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of ProjectKeybacker with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectKeybackerApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectKeybackerApiFindOneById.');
            }
            const localVarPath = `/ProjectKeybacker/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProjectKeybacker with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectKeybackerApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectKeybackerApiRemove.');
            }
            const localVarPath = `/ProjectKeybacker/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectKeybacker that are provided
         * @param {Array<ProjectKeybacker>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectKeybackerApiUpdate(body: Array<ProjectKeybacker>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectKeybackerApiUpdate.');
            }
            const localVarPath = `/ProjectKeybacker`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProjectKeybacker&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of ProjectPdf based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectPdf>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectPdfApiCreate(body: Array<ProjectPdf>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectPdfApiCreate.');
            }
            const localVarPath = `/ProjectPdf`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProjectPdf&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of ProjectPdf that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectPdfApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/ProjectPdf`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of ProjectPdf with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectPdfApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectPdfApiFindOneById.');
            }
            const localVarPath = `/ProjectPdf/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProjectPdf with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectPdfApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectPdfApiRemove.');
            }
            const localVarPath = `/ProjectPdf/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectPdf that are provided
         * @param {Array<ProjectPdf>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectPdfApiUpdate(body: Array<ProjectPdf>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectPdfApiUpdate.');
            }
            const localVarPath = `/ProjectPdf`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProjectPdf&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of ProjectStatusReport based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectStatusReport>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectStatusReportApiCreate(body: Array<ProjectStatusReport>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectStatusReportApiCreate.');
            }
            const localVarPath = `/ProjectStatusReport`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProjectStatusReport&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of ProjectStatusReport that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectStatusReportApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/ProjectStatusReport`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of ProjectStatusReport with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectStatusReportApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectStatusReportApiFindOneById.');
            }
            const localVarPath = `/ProjectStatusReport/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProjectStatusReport with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectStatusReportApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectStatusReportApiRemove.');
            }
            const localVarPath = `/ProjectStatusReport/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectStatusReport that are provided
         * @param {Array<ProjectStatusReport>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectStatusReportApiUpdate(body: Array<ProjectStatusReport>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectStatusReportApiUpdate.');
            }
            const localVarPath = `/ProjectStatusReport`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProjectStatusReport&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of ProjectTaxReport based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectTaxReport>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxReportApiCreate(body: Array<ProjectTaxReport>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectTaxReportApiCreate.');
            }
            const localVarPath = `/ProjectTaxReport`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProjectTaxReport&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of ProjectTaxReport that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxReportApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/ProjectTaxReport`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of ProjectTaxReport with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxReportApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectTaxReportApiFindOneById.');
            }
            const localVarPath = `/ProjectTaxReport/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProjectTaxReport with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxReportApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectTaxReportApiRemove.');
            }
            const localVarPath = `/ProjectTaxReport/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectTaxReport that are provided
         * @param {Array<ProjectTaxReport>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxReportApiUpdate(body: Array<ProjectTaxReport>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectTaxReportApiUpdate.');
            }
            const localVarPath = `/ProjectTaxReport`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProjectTaxReport&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of ProjectTaxSummary based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectTaxSummary>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxSummaryApiCreate(body: Array<ProjectTaxSummary>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectTaxSummaryApiCreate.');
            }
            const localVarPath = `/ProjectTaxSummary`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProjectTaxSummary&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of ProjectTaxSummary that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxSummaryApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/ProjectTaxSummary`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of ProjectTaxSummary with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxSummaryApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectTaxSummaryApiFindOneById.');
            }
            const localVarPath = `/ProjectTaxSummary/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProjectTaxSummary with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxSummaryApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling projectTaxSummaryApiRemove.');
            }
            const localVarPath = `/ProjectTaxSummary/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectTaxSummary that are provided
         * @param {Array<ProjectTaxSummary>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxSummaryApiUpdate(body: Array<ProjectTaxSummary>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectTaxSummaryApiUpdate.');
            }
            const localVarPath = `/ProjectTaxSummary`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProjectTaxSummary&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of PropertySocialProfile based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<PropertySocialProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propertySocialProfileApiCreate(body: Array<PropertySocialProfile>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling propertySocialProfileApiCreate.');
            }
            const localVarPath = `/PropertySocialProfile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;PropertySocialProfile&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of PropertySocialProfile that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propertySocialProfileApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/PropertySocialProfile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of PropertySocialProfile with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propertySocialProfileApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling propertySocialProfileApiFindOneById.');
            }
            const localVarPath = `/PropertySocialProfile/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of PropertySocialProfile with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propertySocialProfileApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling propertySocialProfileApiRemove.');
            }
            const localVarPath = `/PropertySocialProfile/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of PropertySocialProfile that are provided
         * @param {Array<PropertySocialProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propertySocialProfileApiUpdate(body: Array<PropertySocialProfile>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling propertySocialProfileApiUpdate.');
            }
            const localVarPath = `/PropertySocialProfile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;PropertySocialProfile&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of Province based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<Province>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceApiCreate(body: Array<Province>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling provinceApiCreate.');
            }
            const localVarPath = `/Province`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Province&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of Province that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/Province`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of Province with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling provinceApiFindOneById.');
            }
            const localVarPath = `/Province/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of Province with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling provinceApiRemove.');
            }
            const localVarPath = `/Province/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of Province that are provided
         * @param {Array<Province>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceApiUpdate(body: Array<Province>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling provinceApiUpdate.');
            }
            const localVarPath = `/Province`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Province&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of RegistrationQuestion based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<RegistrationQuestion>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registrationQuestionApiCreate(body: Array<RegistrationQuestion>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling registrationQuestionApiCreate.');
            }
            const localVarPath = `/RegistrationQuestion`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;RegistrationQuestion&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of RegistrationQuestion that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registrationQuestionApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/RegistrationQuestion`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of RegistrationQuestion with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registrationQuestionApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling registrationQuestionApiFindOneById.');
            }
            const localVarPath = `/RegistrationQuestion/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of RegistrationQuestion with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registrationQuestionApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling registrationQuestionApiRemove.');
            }
            const localVarPath = `/RegistrationQuestion/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of RegistrationQuestion that are provided
         * @param {Array<RegistrationQuestion>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registrationQuestionApiUpdate(body: Array<RegistrationQuestion>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling registrationQuestionApiUpdate.');
            }
            const localVarPath = `/RegistrationQuestion`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;RegistrationQuestion&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Confirm escrow and trade dates for orders on a roed
         * @param {RoedSchedule1} body 
         * @param {number} id The id of the roed to confirm
         * @param {string} date The date to fill escrow and trade dates if they are empty
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roedSchedule1ApiConfirmReconciliation(body: RoedSchedule1, id: number, date: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling roedSchedule1ApiConfirmReconciliation.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling roedSchedule1ApiConfirmReconciliation.');
            }
            // verify required parameter 'date' is not null or undefined
            if (date === null || date === undefined) {
                throw new RequiredError('date', 'Required parameter date was null or undefined when calling roedSchedule1ApiConfirmReconciliation.');
            }
            const localVarPath = `/RoedSchedule1/{id}/reconcile/{date}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RoedSchedule1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of RoedSchedule1 based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<RoedSchedule1>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roedSchedule1ApiCreate(body: Array<RoedSchedule1>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling roedSchedule1ApiCreate.');
            }
            const localVarPath = `/RoedSchedule1`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;RoedSchedule1&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of RoedSchedule1 that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roedSchedule1ApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/RoedSchedule1`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of RoedSchedule1 with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roedSchedule1ApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling roedSchedule1ApiFindOneById.');
            }
            const localVarPath = `/RoedSchedule1/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of RoedSchedule1 with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roedSchedule1ApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling roedSchedule1ApiRemove.');
            }
            const localVarPath = `/RoedSchedule1/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of RoedSchedule1 that are provided
         * @param {Array<RoedSchedule1>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roedSchedule1ApiUpdate(body: Array<RoedSchedule1>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling roedSchedule1ApiUpdate.');
            }
            const localVarPath = `/RoedSchedule1`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;RoedSchedule1&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of Setting based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<Setting>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingApiCreate(body: Array<Setting>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling settingApiCreate.');
            }
            const localVarPath = `/Setting`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Setting&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of Setting that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/Setting`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of Setting with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling settingApiFindOneById.');
            }
            const localVarPath = `/Setting/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of Setting with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling settingApiRemove.');
            }
            const localVarPath = `/Setting/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of Setting that are provided
         * @param {Array<Setting>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingApiUpdate(body: Array<Setting>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling settingApiUpdate.');
            }
            const localVarPath = `/Setting`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Setting&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of SocialProfileFollowing based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<SocialProfileFollowing>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        socialProfileFollowingApiCreate(body: Array<SocialProfileFollowing>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling socialProfileFollowingApiCreate.');
            }
            const localVarPath = `/SocialProfileFollowing`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;SocialProfileFollowing&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of SocialProfileFollowing that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        socialProfileFollowingApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/SocialProfileFollowing`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of SocialProfileFollowing with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        socialProfileFollowingApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling socialProfileFollowingApiFindOneById.');
            }
            const localVarPath = `/SocialProfileFollowing/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of SocialProfileFollowing with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        socialProfileFollowingApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling socialProfileFollowingApiRemove.');
            }
            const localVarPath = `/SocialProfileFollowing/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of SocialProfileFollowing that are provided
         * @param {Array<SocialProfileFollowing>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        socialProfileFollowingApiUpdate(body: Array<SocialProfileFollowing>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling socialProfileFollowingApiUpdate.');
            }
            const localVarPath = `/SocialProfileFollowing`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;SocialProfileFollowing&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of SponsorSocialProfile based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<SponsorSocialProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sponsorSocialProfileApiCreate(body: Array<SponsorSocialProfile>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling sponsorSocialProfileApiCreate.');
            }
            const localVarPath = `/SponsorSocialProfile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;SponsorSocialProfile&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of SponsorSocialProfile that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sponsorSocialProfileApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/SponsorSocialProfile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of SponsorSocialProfile with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sponsorSocialProfileApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling sponsorSocialProfileApiFindOneById.');
            }
            const localVarPath = `/SponsorSocialProfile/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of SponsorSocialProfile with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sponsorSocialProfileApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling sponsorSocialProfileApiRemove.');
            }
            const localVarPath = `/SponsorSocialProfile/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of SponsorSocialProfile that are provided
         * @param {Array<SponsorSocialProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sponsorSocialProfileApiUpdate(body: Array<SponsorSocialProfile>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling sponsorSocialProfileApiUpdate.');
            }
            const localVarPath = `/SponsorSocialProfile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;SponsorSocialProfile&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of SupportEngineer based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<SupportEngineer>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportEngineerApiCreate(body: Array<SupportEngineer>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling supportEngineerApiCreate.');
            }
            const localVarPath = `/SupportEngineer`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;SupportEngineer&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of SupportEngineer that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportEngineerApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/SupportEngineer`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of SupportEngineer with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportEngineerApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling supportEngineerApiFindOneById.');
            }
            const localVarPath = `/SupportEngineer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of SupportEngineer with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportEngineerApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling supportEngineerApiRemove.');
            }
            const localVarPath = `/SupportEngineer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of SupportEngineer that are provided
         * @param {Array<SupportEngineer>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportEngineerApiUpdate(body: Array<SupportEngineer>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling supportEngineerApiUpdate.');
            }
            const localVarPath = `/SupportEngineer`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;SupportEngineer&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of UserAnswer based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserAnswer>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAnswerApiCreate(body: Array<UserAnswer>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userAnswerApiCreate.');
            }
            const localVarPath = `/UserAnswer`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserAnswer&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of UserAnswer that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAnswerApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/UserAnswer`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of UserAnswer with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAnswerApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userAnswerApiFindOneById.');
            }
            const localVarPath = `/UserAnswer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserAnswer with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAnswerApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userAnswerApiRemove.');
            }
            const localVarPath = `/UserAnswer/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserAnswer that are provided
         * @param {Array<UserAnswer>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAnswerApiUpdate(body: Array<UserAnswer>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userAnswerApiUpdate.');
            }
            const localVarPath = `/UserAnswer`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserAnswer&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of UserBankingDetails based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserBankingDetails>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBankingDetailsApiCreate(body: Array<UserBankingDetails>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userBankingDetailsApiCreate.');
            }
            const localVarPath = `/UserBankingDetails`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserBankingDetails&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of UserBankingDetails that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBankingDetailsApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/UserBankingDetails`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of UserBankingDetails with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBankingDetailsApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userBankingDetailsApiFindOneById.');
            }
            const localVarPath = `/UserBankingDetails/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserBankingDetails with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBankingDetailsApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userBankingDetailsApiRemove.');
            }
            const localVarPath = `/UserBankingDetails/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserBankingDetails that are provided
         * @param {Array<UserBankingDetails>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBankingDetailsApiUpdate(body: Array<UserBankingDetails>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userBankingDetailsApiUpdate.');
            }
            const localVarPath = `/UserBankingDetails`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserBankingDetails&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of UserBasic based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserBasic>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBasicApiCreate(body: Array<UserBasic>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userBasicApiCreate.');
            }
            const localVarPath = `/UserBasic`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserBasic&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of UserBasic that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBasicApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/UserBasic`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of UserBasic with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBasicApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userBasicApiFindOneById.');
            }
            const localVarPath = `/UserBasic/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserBasic with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBasicApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userBasicApiRemove.');
            }
            const localVarPath = `/UserBasic/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserBasic that are provided
         * @param {Array<UserBasic>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBasicApiUpdate(body: Array<UserBasic>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userBasicApiUpdate.');
            }
            const localVarPath = `/UserBasic`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserBasic&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of UserBeneficiary based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserBeneficiary>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBeneficiaryApiCreate(body: Array<UserBeneficiary>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userBeneficiaryApiCreate.');
            }
            const localVarPath = `/UserBeneficiary`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserBeneficiary&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of UserBeneficiary that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBeneficiaryApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/UserBeneficiary`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of UserBeneficiary with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBeneficiaryApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userBeneficiaryApiFindOneById.');
            }
            const localVarPath = `/UserBeneficiary/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserBeneficiary with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBeneficiaryApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userBeneficiaryApiRemove.');
            }
            const localVarPath = `/UserBeneficiary/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserBeneficiary that are provided
         * @param {Array<UserBeneficiary>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBeneficiaryApiUpdate(body: Array<UserBeneficiary>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userBeneficiaryApiUpdate.');
            }
            const localVarPath = `/UserBeneficiary`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserBeneficiary&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of UserCorporation based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserCorporation>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCorporationApiCreate(body: Array<UserCorporation>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userCorporationApiCreate.');
            }
            const localVarPath = `/UserCorporation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserCorporation&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of UserCorporation that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCorporationApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/UserCorporation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of UserCorporation with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCorporationApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userCorporationApiFindOneById.');
            }
            const localVarPath = `/UserCorporation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserCorporation with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCorporationApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userCorporationApiRemove.');
            }
            const localVarPath = `/UserCorporation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserCorporation that are provided
         * @param {Array<UserCorporation>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCorporationApiUpdate(body: Array<UserCorporation>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userCorporationApiUpdate.');
            }
            const localVarPath = `/UserCorporation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserCorporation&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of UserEntity based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserEntity>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEntityApiCreate(body: Array<UserEntity>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userEntityApiCreate.');
            }
            const localVarPath = `/UserEntity`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserEntity&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of UserEntity that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEntityApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/UserEntity`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of UserEntity with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEntityApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userEntityApiFindOneById.');
            }
            const localVarPath = `/UserEntity/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserEntity with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEntityApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userEntityApiRemove.');
            }
            const localVarPath = `/UserEntity/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserEntity that are provided
         * @param {Array<UserEntity>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEntityApiUpdate(body: Array<UserEntity>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userEntityApiUpdate.');
            }
            const localVarPath = `/UserEntity`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserEntity&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of UserFinancialKyc based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserFinancialKyc>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFinancialKycApiCreate(body: Array<UserFinancialKyc>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userFinancialKycApiCreate.');
            }
            const localVarPath = `/UserFinancialKyc`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserFinancialKyc&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of UserFinancialKyc that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFinancialKycApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/UserFinancialKyc`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of UserFinancialKyc with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFinancialKycApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userFinancialKycApiFindOneById.');
            }
            const localVarPath = `/UserFinancialKyc/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserFinancialKyc with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFinancialKycApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userFinancialKycApiRemove.');
            }
            const localVarPath = `/UserFinancialKyc/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserFinancialKyc that are provided
         * @param {Array<UserFinancialKyc>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFinancialKycApiUpdate(body: Array<UserFinancialKyc>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userFinancialKycApiUpdate.');
            }
            const localVarPath = `/UserFinancialKyc`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserFinancialKyc&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of UserInvitation based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserInvitation>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationApiCreate(body: Array<UserInvitation>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userInvitationApiCreate.');
            }
            const localVarPath = `/UserInvitation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserInvitation&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of UserInvitation that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/UserInvitation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of UserInvitation with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userInvitationApiFindOneById.');
            }
            const localVarPath = `/UserInvitation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserInvitation with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userInvitationApiRemove.');
            }
            const localVarPath = `/UserInvitation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserInvitation that are provided
         * @param {Array<UserInvitation>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationApiUpdate(body: Array<UserInvitation>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userInvitationApiUpdate.');
            }
            const localVarPath = `/UserInvitation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserInvitation&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of UserIssuerAssociation based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserIssuerAssociation>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIssuerAssociationApiCreate(body: Array<UserIssuerAssociation>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userIssuerAssociationApiCreate.');
            }
            const localVarPath = `/UserIssuerAssociation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserIssuerAssociation&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of UserIssuerAssociation that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIssuerAssociationApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/UserIssuerAssociation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of UserIssuerAssociation with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIssuerAssociationApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userIssuerAssociationApiFindOneById.');
            }
            const localVarPath = `/UserIssuerAssociation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserIssuerAssociation with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIssuerAssociationApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userIssuerAssociationApiRemove.');
            }
            const localVarPath = `/UserIssuerAssociation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserIssuerAssociation that are provided
         * @param {Array<UserIssuerAssociation>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIssuerAssociationApiUpdate(body: Array<UserIssuerAssociation>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userIssuerAssociationApiUpdate.');
            }
            const localVarPath = `/UserIssuerAssociation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserIssuerAssociation&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new instance of UserPdf base on the value passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the id of the newly created object
         * @param {UserPdf} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPdfApiCreate(body: UserPdf, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userPdfApiCreate.');
            }
            const localVarPath = `/UserPdf`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserPdf" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download the file
         * @param {number} id The id of the pdf to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPdfApiDownload(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userPdfApiDownload.');
            }
            const localVarPath = `/UserPdf/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all UserPdf of AdminLog that match the given filter, and structure the associated pdf files and download zipped bundle file
         * @param {string} filter the odata like filter expression use to match which instances are returned. pdf_type, pdf_name, fullName(user.first_name + user.last_name) are mandatory
         * @param {string} pattern a comma separated list of naming pattern that specfiy how the pdf files are structured and named. There are three naming patterns. First and second patterns are for directory and third naming pattern is for pdf file name. If pattern is \&quot;order.project.name,user.client_number,pdf_name\&quot;, you would create a root directory from the property users_pdf.order.project.name, inside of that create a directory from the property users_pdf.user.client_number and in that create a file name users_pdf.pdf_name with a \&quot;.pdf\&quot; suffix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPdfApiDownloadBundle(filter: string, pattern: string, options: any = {}): FetchArgs {
            // verify required parameter 'filter' is not null or undefined
            if (filter === null || filter === undefined) {
                throw new RequiredError('filter', 'Required parameter filter was null or undefined when calling userPdfApiDownloadBundle.');
            }
            // verify required parameter 'pattern' is not null or undefined
            if (pattern === null || pattern === undefined) {
                throw new RequiredError('pattern', 'Required parameter pattern was null or undefined when calling userPdfApiDownloadBundle.');
            }
            const localVarPath = `/UserPdf/download/bundle`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (pattern !== undefined) {
                localVarQueryParameter['pattern'] = pattern;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all UserPdf of AdminLog that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPdfApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/UserPdf`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all UserPdf of AdminLog that match the given filter. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPdfApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userPdfApiFindOneById.');
            }
            const localVarPath = `/UserPdf/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserPdf with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPdfApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userPdfApiRemove.');
            }
            const localVarPath = `/UserPdf/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instance of UserPdf that is provided
         * @param {UserPdf} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPdfApiUpdate(body: UserPdf, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userPdfApiUpdate.');
            }
            const localVarPath = `/UserPdf`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserPdf" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of UserRelationship based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserRelationship>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRelationshipApiCreate(body: Array<UserRelationship>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userRelationshipApiCreate.');
            }
            const localVarPath = `/UserRelationship`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserRelationship&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of UserRelationship that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRelationshipApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/UserRelationship`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of UserRelationship with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRelationshipApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userRelationshipApiFindOneById.');
            }
            const localVarPath = `/UserRelationship/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserRelationship with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRelationshipApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userRelationshipApiRemove.');
            }
            const localVarPath = `/UserRelationship/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserRelationship that are provided
         * @param {Array<UserRelationship>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRelationshipApiUpdate(body: Array<UserRelationship>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userRelationshipApiUpdate.');
            }
            const localVarPath = `/UserRelationship`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserRelationship&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of UserRequest based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserRequest>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRequestApiCreate(body: Array<UserRequest>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userRequestApiCreate.');
            }
            const localVarPath = `/UserRequest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserRequest&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of UserRequest that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRequestApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/UserRequest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of UserRequest with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRequestApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userRequestApiFindOneById.');
            }
            const localVarPath = `/UserRequest/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserRequest with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRequestApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userRequestApiRemove.');
            }
            const localVarPath = `/UserRequest/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserRequest that are provided
         * @param {Array<UserRequest>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRequestApiUpdate(body: Array<UserRequest>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userRequestApiUpdate.');
            }
            const localVarPath = `/UserRequest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserRequest&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of UserSignupEvent that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSignupEventApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/UserSignupEvent`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of UserSocialPost based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserSocialPost>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialPostApiCreate(body: Array<UserSocialPost>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userSocialPostApiCreate.');
            }
            const localVarPath = `/UserSocialPost`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserSocialPost&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of UserSocialPost that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialPostApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/UserSocialPost`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of UserSocialPost with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialPostApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userSocialPostApiFindOneById.');
            }
            const localVarPath = `/UserSocialPost/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserSocialPost with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialPostApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userSocialPostApiRemove.');
            }
            const localVarPath = `/UserSocialPost/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserSocialPost that are provided
         * @param {Array<UserSocialPost>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialPostApiUpdate(body: Array<UserSocialPost>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userSocialPostApiUpdate.');
            }
            const localVarPath = `/UserSocialPost`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserSocialPost&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of UserSocialProfile based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserSocialProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialProfileApiCreate(body: Array<UserSocialProfile>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userSocialProfileApiCreate.');
            }
            const localVarPath = `/UserSocialProfile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserSocialProfile&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of UserSocialProfile that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialProfileApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/UserSocialProfile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of UserSocialProfile with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialProfileApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userSocialProfileApiFindOneById.');
            }
            const localVarPath = `/UserSocialProfile/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserSocialProfile with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialProfileApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userSocialProfileApiRemove.');
            }
            const localVarPath = `/UserSocialProfile/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserSocialProfile that are provided
         * @param {Array<UserSocialProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialProfileApiUpdate(body: Array<UserSocialProfile>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userSocialProfileApiUpdate.');
            }
            const localVarPath = `/UserSocialProfile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserSocialProfile&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of UserSubscription based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserSubscription>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSubscriptionApiCreate(body: Array<UserSubscription>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userSubscriptionApiCreate.');
            }
            const localVarPath = `/UserSubscription`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserSubscription&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of UserSubscription that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSubscriptionApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/UserSubscription`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of UserSubscription with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSubscriptionApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userSubscriptionApiFindOneById.');
            }
            const localVarPath = `/UserSubscription/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserSubscription with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSubscriptionApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userSubscriptionApiRemove.');
            }
            const localVarPath = `/UserSubscription/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserSubscription that are provided
         * @param {Array<UserSubscription>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSubscriptionApiUpdate(body: Array<UserSubscription>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userSubscriptionApiUpdate.');
            }
            const localVarPath = `/UserSubscription`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserSubscription&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of UserTrust based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserTrust>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTrustApiCreate(body: Array<UserTrust>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userTrustApiCreate.');
            }
            const localVarPath = `/UserTrust`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserTrust&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of UserTrust that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTrustApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/UserTrust`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of UserTrust with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTrustApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userTrustApiFindOneById.');
            }
            const localVarPath = `/UserTrust/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserTrust with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTrustApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userTrustApiRemove.');
            }
            const localVarPath = `/UserTrust/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserTrust that are provided
         * @param {Array<UserTrust>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTrustApiUpdate(body: Array<UserTrust>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userTrustApiUpdate.');
            }
            const localVarPath = `/UserTrust`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;UserTrust&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new instances of WebHook based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<WebHook>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webHookApiCreate(body: Array<WebHook>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling webHookApiCreate.');
            }
            const localVarPath = `/WebHook`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;WebHook&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find all instances of WebHook that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webHookApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/WebHook`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a single instance of WebHook with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webHookApiFindOneById(id: number, expand?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling webHookApiFindOneById.');
            }
            const localVarPath = `/WebHook/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the single instance of WebHook with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webHookApiRemove(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling webHookApiRemove.');
            }
            const localVarPath = `/WebHook/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the values for the instances of WebHook that are provided
         * @param {Array<WebHook>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webHookApiUpdate(body: Array<WebHook>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling webHookApiUpdate.');
            }
            const localVarPath = `/WebHook`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;WebHook&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates new instances of AdminModule based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<AdminModule>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminModuleApiCreate(body: Array<AdminModule>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AdminModule>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).adminModuleApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of AdminModule that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminModuleApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AdminModule>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).adminModuleApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of AdminModule with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminModuleApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AdminModule> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).adminModuleApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of AdminModule with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminModuleApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).adminModuleApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of AdminModule that are provided
         * @param {Array<AdminModule>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminModuleApiUpdate(body: Array<AdminModule>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).adminModuleApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of AdminUser based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<AdminUser>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserApiCreate(body: Array<AdminUser>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AdminUser>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).adminUserApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of AdminUser that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AdminUser>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).adminUserApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of AdminUser with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AdminUser> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).adminUserApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of AdminUser with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).adminUserApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of AdminUser that are provided
         * @param {Array<AdminUser>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserApiUpdate(body: Array<AdminUser>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).adminUserApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of AllUserAnswer based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<AllUserAnswer>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserAnswerApiCreate(body: Array<AllUserAnswer>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AllUserAnswer>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).allUserAnswerApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of AllUserAnswer that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserAnswerApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AllUserAnswer>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).allUserAnswerApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of AllUserAnswer with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserAnswerApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AllUserAnswer> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).allUserAnswerApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of AllUserAnswer with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserAnswerApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).allUserAnswerApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of AllUserAnswer that are provided
         * @param {Array<AllUserAnswer>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserAnswerApiUpdate(body: Array<AllUserAnswer>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).allUserAnswerApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of AllUser based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<AllUser>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserApiCreate(body: Array<AllUser>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AllUser>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).allUserApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of AllUser that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AllUser>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).allUserApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of AllUser with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AllUser> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).allUserApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a preference setting for a specific user
         * @param {string} preference The name of the preference to get the value of
         * @param {number} id The id of the user to get the preference of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserApiGetPreference(preference: string, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Preference> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).allUserApiGetPreference(preference, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of AllUser with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).allUserApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set a single preference for a given user
         * @param {Preference} body 
         * @param {number} id The id of the user to set the preference for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserApiSetPreference(body: Preference, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).allUserApiSetPreference(body, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of AllUser that are provided
         * @param {Array<AllUser>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserApiUpdate(body: Array<AllUser>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).allUserApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of BackgroundProcess based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<BackgroundProcess>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backgroundProcessApiCreate(body: Array<BackgroundProcess>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BackgroundProcess>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).backgroundProcessApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of BackgroundProcess that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backgroundProcessApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BackgroundProcess>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).backgroundProcessApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of BackgroundProcess with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backgroundProcessApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BackgroundProcess> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).backgroundProcessApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of BackgroundProcess with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backgroundProcessApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).backgroundProcessApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of BackgroundProcess that are provided
         * @param {Array<BackgroundProcess>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backgroundProcessApiUpdate(body: Array<BackgroundProcess>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).backgroundProcessApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of ComputedAccount that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedAccountApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ComputedAccount>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).computedAccountApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of ComputedAccountIncome based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ComputedAccountIncome>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedAccountIncomeApiCreate(body: Array<ComputedAccountIncome>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ComputedAccountIncome>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).computedAccountIncomeApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of ComputedAccountIncome that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedAccountIncomeApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ComputedAccountIncome>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).computedAccountIncomeApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of ComputedAccountIncome with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedAccountIncomeApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ComputedAccountIncome> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).computedAccountIncomeApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of ComputedAccountIncome with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedAccountIncomeApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).computedAccountIncomeApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ComputedAccountIncome that are provided
         * @param {Array<ComputedAccountIncome>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedAccountIncomeApiUpdate(body: Array<ComputedAccountIncome>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).computedAccountIncomeApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of ComputedAccountPosition that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedAccountPositionApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ComputedAccountPosition>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).computedAccountPositionApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of ComputedAccountTotalIncome that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedAccountTotalIncomeApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ComputedAccountTotalIncome>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).computedAccountTotalIncomeApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of ComputedProjectIncome based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ComputedProjectIncome>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedProjectIncomeApiCreate(body: Array<ComputedProjectIncome>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ComputedProjectIncome>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).computedProjectIncomeApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of ComputedProjectIncome that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedProjectIncomeApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ComputedProjectIncome>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).computedProjectIncomeApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of ComputedProjectIncome with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedProjectIncomeApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ComputedProjectIncome> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).computedProjectIncomeApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of ComputedProjectIncome with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedProjectIncomeApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).computedProjectIncomeApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ComputedProjectIncome that are provided
         * @param {Array<ComputedProjectIncome>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedProjectIncomeApiUpdate(body: Array<ComputedProjectIncome>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).computedProjectIncomeApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of ComputedProjectTotalIncome that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedProjectTotalIncomeApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ComputedProjectTotalIncome>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).computedProjectTotalIncomeApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of Country based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<Country>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryApiCreate(body: Array<Country>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Country>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).countryApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of Country that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Country>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).countryApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of Country with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Country> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).countryApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of Country with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).countryApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of Country that are provided
         * @param {Array<Country>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryApiUpdate(body: Array<Country>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).countryApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of Event based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<Event>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventApiCreate(body: Array<Event>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Event>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).eventApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of Event that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Event>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).eventApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of Event with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Event> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).eventApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of Event with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).eventApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of Event that are provided
         * @param {Array<Event>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventApiUpdate(body: Array<Event>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).eventApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of ExemptDistributionOption based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ExemptDistributionOption>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exemptDistributionOptionApiCreate(body: Array<ExemptDistributionOption>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ExemptDistributionOption>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).exemptDistributionOptionApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of ExemptDistributionOption that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exemptDistributionOptionApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ExemptDistributionOption>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).exemptDistributionOptionApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of ExemptDistributionOption with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exemptDistributionOptionApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExemptDistributionOption> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).exemptDistributionOptionApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of ExemptDistributionOption with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exemptDistributionOptionApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).exemptDistributionOptionApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ExemptDistributionOption that are provided
         * @param {Array<ExemptDistributionOption>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exemptDistributionOptionApiUpdate(body: Array<ExemptDistributionOption>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).exemptDistributionOptionApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of FfbaAssociation based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<FfbaAssociation>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ffbaAssociationApiCreate(body: Array<FfbaAssociation>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FfbaAssociation>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).ffbaAssociationApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of FfbaAssociation that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ffbaAssociationApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FfbaAssociation>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).ffbaAssociationApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of FfbaAssociation with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ffbaAssociationApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FfbaAssociation> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).ffbaAssociationApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of FfbaAssociation with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ffbaAssociationApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).ffbaAssociationApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of FfbaAssociation that are provided
         * @param {Array<FfbaAssociation>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ffbaAssociationApiUpdate(body: Array<FfbaAssociation>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).ffbaAssociationApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Cross check all cms cobranders with hubspot properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotContactCobrandersControllerCheckCobranders(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).hubspotContactCobrandersControllerCheckCobranders(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Cross check all cms investors with hubspot contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotContactControllerCheckInvestors(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).hubspotContactControllerCheckInvestors(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Synchronize a single cms investor with a corresponding hubspot contact
         * @param {number} id The id of the investor to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotContactControllerSyncInvestor(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).hubspotContactControllerSyncInvestor(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Cross check all cms orders with hubspot deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotDealControllerCheckAllDeals(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).hubspotDealControllerCheckAllDeals(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Cross check all cms orders with hubspot deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotDealControllerCheckOrders(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).hubspotDealControllerCheckOrders(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a new order based on the details of a deal whoose id is provided
         * @param {string} dealId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotDealControllerCreate(dealId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvestmentOrder> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).hubspotDealControllerCreate(dealId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Synchronize a single cms order with a corresponding hubspot deal
         * @param {number} id The id of the order to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotDealControllerSyncOrder(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).hubspotDealControllerSyncOrder(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Ensure a single project is reflected in hubspot custom objects correctly
         * @param {number} id The id of the project to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotProjectControllerCheckProject(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).hubspotProjectControllerCheckProject(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Cross check all cms projects with hubspot properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotProjectControllerCheckProjects(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).hubspotProjectControllerCheckProjects(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of ImportedContact based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ImportedContact>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedContactApiCreate(body: Array<ImportedContact>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ImportedContact>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).importedContactApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of ImportedContact that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedContactApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ImportedContact>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).importedContactApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of ImportedContact with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedContactApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ImportedContact> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).importedContactApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of ImportedContact with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedContactApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).importedContactApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ImportedContact that are provided
         * @param {Array<ImportedContact>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedContactApiUpdate(body: Array<ImportedContact>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).importedContactApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of InvestmentOrder based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<InvestmentOrder>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentOrderApiCreate(body: Array<InvestmentOrder>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InvestmentOrder>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investmentOrderApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of InvestmentOrder that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentOrderApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InvestmentOrder>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investmentOrderApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of InvestmentOrder with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentOrderApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvestmentOrder> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investmentOrderApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of InvestmentOrder with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentOrderApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investmentOrderApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of InvestmentOrder that are provided
         * @param {Array<InvestmentOrder>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentOrderApiUpdate(body: Array<InvestmentOrder>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investmentOrderApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of InvestmentTransaction based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<InvestmentTransaction>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentTransactionApiCreate(body: Array<InvestmentTransaction>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InvestmentTransaction>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investmentTransactionApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of InvestmentTransaction that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentTransactionApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InvestmentTransaction>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investmentTransactionApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of InvestmentTransaction with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentTransactionApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvestmentTransaction> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investmentTransactionApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of InvestmentTransaction with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentTransactionApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investmentTransactionApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of InvestmentTransaction that are provided
         * @param {Array<InvestmentTransaction>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentTransactionApiUpdate(body: Array<InvestmentTransaction>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investmentTransactionApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of InvestmentWatchlist based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<InvestmentWatchlist>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWatchlistApiCreate(body: Array<InvestmentWatchlist>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InvestmentWatchlist>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investmentWatchlistApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of InvestmentWatchlist that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWatchlistApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InvestmentWatchlist>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investmentWatchlistApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of InvestmentWatchlist with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWatchlistApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvestmentWatchlist> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investmentWatchlistApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of InvestmentWatchlist with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWatchlistApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investmentWatchlistApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of InvestmentWatchlist that are provided
         * @param {Array<InvestmentWatchlist>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWatchlistApiUpdate(body: Array<InvestmentWatchlist>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investmentWatchlistApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of InvestmentWithdrawal based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<InvestmentWithdrawal>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWithdrawalApiCreate(body: Array<InvestmentWithdrawal>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InvestmentWithdrawal>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investmentWithdrawalApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of InvestmentWithdrawal that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWithdrawalApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InvestmentWithdrawal>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investmentWithdrawalApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of InvestmentWithdrawal with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWithdrawalApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvestmentWithdrawal> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investmentWithdrawalApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of InvestmentWithdrawal with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWithdrawalApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investmentWithdrawalApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of InvestmentWithdrawal that are provided
         * @param {Array<InvestmentWithdrawal>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWithdrawalApiUpdate(body: Array<InvestmentWithdrawal>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investmentWithdrawalApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of Investor based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<Investor>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiCreate(body: Array<Investor>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Investor>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investorApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of Investor that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Investor>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investorApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of Investor with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Investor> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investorApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all non-deleted orders for a specific investor
         * @param {number} id The id of the investor to get all non-deleted orders for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiGetAllNonDeletedOrders(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InvestmentOrder>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investorApiGetAllNonDeletedOrders(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the annual investment limits for the given investor
         * @param {number} id The id of the investor to get the annual investment limits for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiGetAnnualInvestmentLimits(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Number> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investorApiGetAnnualInvestmentLimits(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary get the oldest non-deleted order in the last year for a given investor
         * @param {number} id the id of the investor to get the oldest non-deleted order in the last year for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiGetOldestNonDeletedOrderLastYear(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvestmentOrder> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investorApiGetOldestNonDeletedOrderLastYear(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary get the total amount of all orders in the last year for a given investor
         * @param {number} id the id of the investor to get the total amount of all orders in the last year for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiGetTotalAmountInvestedInLastYear(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Number> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investorApiGetTotalAmountInvestedInLastYear(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of Investor with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investorApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of Investor that are provided
         * @param {Array<Investor>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiUpdate(body: Array<Investor>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investorApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of InvestorCobranding that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorCobrandingApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InvestorCobranding>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investorCobrandingApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of InvestorEarning based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<InvestorEarning>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorEarningApiCreate(body: Array<InvestorEarning>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InvestorEarning>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investorEarningApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of InvestorEarning that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorEarningApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InvestorEarning>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investorEarningApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of InvestorEarning with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorEarningApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvestorEarning> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investorEarningApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of InvestorEarning with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorEarningApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investorEarningApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of InvestorEarning that are provided
         * @param {Array<InvestorEarning>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorEarningApiUpdate(body: Array<InvestorEarning>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investorEarningApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of InvestorIntendedTrades based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<InvestorIntendedTrades>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorIntendedTradesApiCreate(body: Array<InvestorIntendedTrades>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InvestorIntendedTrades>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investorIntendedTradesApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of InvestorIntendedTrades that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorIntendedTradesApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InvestorIntendedTrades>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investorIntendedTradesApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of InvestorIntendedTrades with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorIntendedTradesApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvestorIntendedTrades> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investorIntendedTradesApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of InvestorIntendedTrades with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorIntendedTradesApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investorIntendedTradesApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of InvestorIntendedTrades that are provided
         * @param {Array<InvestorIntendedTrades>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorIntendedTradesApiUpdate(body: Array<InvestorIntendedTrades>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investorIntendedTradesApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of InvestorSocialProfile based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<InvestorSocialProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorSocialProfileApiCreate(body: Array<InvestorSocialProfile>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InvestorSocialProfile>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investorSocialProfileApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of InvestorSocialProfile that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorSocialProfileApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InvestorSocialProfile>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investorSocialProfileApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of InvestorSocialProfile with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorSocialProfileApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvestorSocialProfile> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investorSocialProfileApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of InvestorSocialProfile with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorSocialProfileApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investorSocialProfileApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of InvestorSocialProfile that are provided
         * @param {Array<InvestorSocialProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorSocialProfileApiUpdate(body: Array<InvestorSocialProfile>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).investorSocialProfileApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of IssuerAdmin based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<IssuerAdmin>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuerAdminApiCreate(body: Array<IssuerAdmin>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<IssuerAdmin>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).issuerAdminApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of IssuerAdmin that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuerAdminApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<IssuerAdmin>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).issuerAdminApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of IssuerAdmin with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuerAdminApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IssuerAdmin> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).issuerAdminApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of IssuerAdmin with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuerAdminApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).issuerAdminApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of IssuerAdmin that are provided
         * @param {Array<IssuerAdmin>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuerAdminApiUpdate(body: Array<IssuerAdmin>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).issuerAdminApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of Mail based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<Mail>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mailApiCreate(body: Array<Mail>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Mail>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).mailApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of Mail that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mailApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Mail>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).mailApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of Mail with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mailApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Mail> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).mailApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of Mail with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mailApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).mailApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of Mail that are provided
         * @param {Array<Mail>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mailApiUpdate(body: Array<Mail>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).mailApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of Menu based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<Menu>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menuApiCreate(body: Array<Menu>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Menu>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).menuApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of Menu that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menuApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Menu>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).menuApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of Menu with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menuApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Menu> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).menuApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of Menu with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menuApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).menuApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of Menu that are provided
         * @param {Array<Menu>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menuApiUpdate(body: Array<Menu>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).menuApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a metrics based on a request saved in the current users specified preference
         * @param {string} preference The name of the preference to get the request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsApiFindByPreference(preference: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelString> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metricsApiFindByPreference(preference, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the data associated with the specified metric
         * @param {MetricsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsApiFindOneById(body: MetricsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MetricResult>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metricsApiFindOneById(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Save the given request as a preference and then get the mtrics
         * @param {MetricsRequest} body 
         * @param {string} preference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsApiSavePreferenceAnGet(body: MetricsRequest, preference: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MetricResult>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metricsApiSavePreferenceAnGet(body, preference, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of ModuleAccess based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ModuleAccess>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleAccessApiCreate(body: Array<ModuleAccess>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ModuleAccess>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).moduleAccessApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of ModuleAccess that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleAccessApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ModuleAccess>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).moduleAccessApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of ModuleAccess with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleAccessApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModuleAccess> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).moduleAccessApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of ModuleAccess with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleAccessApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).moduleAccessApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ModuleAccess that are provided
         * @param {Array<ModuleAccess>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleAccessApiUpdate(body: Array<ModuleAccess>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).moduleAccessApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of NotableInvestorProfile based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<NotableInvestorProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notableInvestorProfileApiCreate(body: Array<NotableInvestorProfile>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NotableInvestorProfile>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).notableInvestorProfileApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of NotableInvestorProfile that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notableInvestorProfileApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NotableInvestorProfile>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).notableInvestorProfileApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of NotableInvestorProfile with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notableInvestorProfileApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NotableInvestorProfile> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).notableInvestorProfileApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of NotableInvestorProfile with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notableInvestorProfileApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).notableInvestorProfileApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of NotableInvestorProfile that are provided
         * @param {Array<NotableInvestorProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notableInvestorProfileApiUpdate(body: Array<NotableInvestorProfile>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).notableInvestorProfileApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of OrderAcknowledgement based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<OrderAcknowledgement>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementApiCreate(body: Array<OrderAcknowledgement>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OrderAcknowledgement>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).orderAcknowledgementApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of OrderAcknowledgement that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OrderAcknowledgement>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).orderAcknowledgementApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of OrderAcknowledgement with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderAcknowledgement> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).orderAcknowledgementApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of OrderAcknowledgement with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).orderAcknowledgementApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of OrderAcknowledgement that are provided
         * @param {Array<OrderAcknowledgement>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementApiUpdate(body: Array<OrderAcknowledgement>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).orderAcknowledgementApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of OrderAcknowledgementQuestion based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<OrderAcknowledgementQuestion>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementQuestionApiCreate(body: Array<OrderAcknowledgementQuestion>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OrderAcknowledgementQuestion>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).orderAcknowledgementQuestionApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of OrderAcknowledgementQuestion that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementQuestionApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OrderAcknowledgementQuestion>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).orderAcknowledgementQuestionApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of OrderAcknowledgementQuestion with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementQuestionApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderAcknowledgementQuestion> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).orderAcknowledgementQuestionApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of OrderAcknowledgementQuestion with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementQuestionApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).orderAcknowledgementQuestionApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of OrderAcknowledgementQuestion that are provided
         * @param {Array<OrderAcknowledgementQuestion>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementQuestionApiUpdate(body: Array<OrderAcknowledgementQuestion>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).orderAcknowledgementQuestionApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of ProfileBackground based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProfileBackground>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileBackgroundApiCreate(body: Array<ProfileBackground>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProfileBackground>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).profileBackgroundApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of ProfileBackground that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileBackgroundApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProfileBackground>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).profileBackgroundApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of ProfileBackground with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileBackgroundApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProfileBackground> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).profileBackgroundApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProfileBackground with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileBackgroundApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).profileBackgroundApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProfileBackground that are provided
         * @param {Array<ProfileBackground>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileBackgroundApiUpdate(body: Array<ProfileBackground>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).profileBackgroundApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of ProjectAccount based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectAccount>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectAccountApiCreate(body: Array<ProjectAccount>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectAccount>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectAccountApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of ProjectAccount that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectAccountApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectAccount>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectAccountApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of ProjectAccount with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectAccountApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectAccount> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectAccountApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProjectAccount with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectAccountApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectAccountApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectAccount that are provided
         * @param {Array<ProjectAccount>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectAccountApiUpdate(body: Array<ProjectAccount>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectAccountApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of Project based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<Project>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectApiCreate(body: Array<Project>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Project>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of Project that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Project>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of Project with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Project> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of Project with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of Project that are provided
         * @param {Array<Project>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectApiUpdate(body: Array<Project>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of ProjectBalanceAdjustment based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectBalanceAdjustment>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectBalanceAdjustmentApiCreate(body: Array<ProjectBalanceAdjustment>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectBalanceAdjustment>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectBalanceAdjustmentApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of ProjectBalanceAdjustment that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectBalanceAdjustmentApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectBalanceAdjustment>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectBalanceAdjustmentApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of ProjectBalanceAdjustment with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectBalanceAdjustmentApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectBalanceAdjustment> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectBalanceAdjustmentApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProjectBalanceAdjustment with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectBalanceAdjustmentApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectBalanceAdjustmentApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectBalanceAdjustment that are provided
         * @param {Array<ProjectBalanceAdjustment>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectBalanceAdjustmentApiUpdate(body: Array<ProjectBalanceAdjustment>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectBalanceAdjustmentApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of ProjectDocusignMapping based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectDocusignMapping>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDocusignMappingApiCreate(body: Array<ProjectDocusignMapping>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectDocusignMapping>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectDocusignMappingApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of ProjectDocusignMapping that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDocusignMappingApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectDocusignMapping>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectDocusignMappingApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of ProjectDocusignMapping with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDocusignMappingApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectDocusignMapping> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectDocusignMappingApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProjectDocusignMapping with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDocusignMappingApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectDocusignMappingApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectDocusignMapping that are provided
         * @param {Array<ProjectDocusignMapping>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDocusignMappingApiUpdate(body: Array<ProjectDocusignMapping>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectDocusignMappingApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of ProjectEntity based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectEntity>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityApiCreate(body: Array<ProjectEntity>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectEntity>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectEntityApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of ProjectEntity that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectEntity>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectEntityApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of ProjectEntity with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectEntity> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectEntityApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProjectEntity with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectEntityApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectEntity that are provided
         * @param {Array<ProjectEntity>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityApiUpdate(body: Array<ProjectEntity>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectEntityApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of ProjectEntityDetail based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectEntityDetail>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityDetailApiCreate(body: Array<ProjectEntityDetail>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectEntityDetail>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectEntityDetailApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of ProjectEntityDetail that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityDetailApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectEntityDetail>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectEntityDetailApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of ProjectEntityDetail with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityDetailApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectEntityDetail> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectEntityDetailApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProjectEntityDetail with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityDetailApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectEntityDetailApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectEntityDetail that are provided
         * @param {Array<ProjectEntityDetail>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityDetailApiUpdate(body: Array<ProjectEntityDetail>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectEntityDetailApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of ProjectImage based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectImage>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectImageApiCreate(body: Array<ProjectImage>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectImage>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectImageApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of ProjectImage that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectImageApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectImage>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectImageApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of ProjectImage with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectImageApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectImage> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectImageApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProjectImage with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectImageApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectImageApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectImage that are provided
         * @param {Array<ProjectImage>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectImageApiUpdate(body: Array<ProjectImage>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectImageApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of ProjectInterest based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectInterest>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectInterestApiCreate(body: Array<ProjectInterest>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectInterest>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectInterestApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of ProjectInterest that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectInterestApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectInterest>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectInterestApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of ProjectInterest with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectInterestApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectInterest> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectInterestApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProjectInterest with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectInterestApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectInterestApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectInterest that are provided
         * @param {Array<ProjectInterest>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectInterestApiUpdate(body: Array<ProjectInterest>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectInterestApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of ProjectKeybacker based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectKeybacker>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectKeybackerApiCreate(body: Array<ProjectKeybacker>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectKeybacker>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectKeybackerApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of ProjectKeybacker that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectKeybackerApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectKeybacker>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectKeybackerApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of ProjectKeybacker with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectKeybackerApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectKeybacker> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectKeybackerApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProjectKeybacker with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectKeybackerApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectKeybackerApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectKeybacker that are provided
         * @param {Array<ProjectKeybacker>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectKeybackerApiUpdate(body: Array<ProjectKeybacker>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectKeybackerApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of ProjectPdf based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectPdf>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectPdfApiCreate(body: Array<ProjectPdf>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectPdf>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectPdfApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of ProjectPdf that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectPdfApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectPdf>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectPdfApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of ProjectPdf with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectPdfApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectPdf> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectPdfApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProjectPdf with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectPdfApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectPdfApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectPdf that are provided
         * @param {Array<ProjectPdf>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectPdfApiUpdate(body: Array<ProjectPdf>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectPdfApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of ProjectStatusReport based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectStatusReport>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectStatusReportApiCreate(body: Array<ProjectStatusReport>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectStatusReport>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectStatusReportApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of ProjectStatusReport that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectStatusReportApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectStatusReport>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectStatusReportApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of ProjectStatusReport with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectStatusReportApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectStatusReport> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectStatusReportApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProjectStatusReport with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectStatusReportApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectStatusReportApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectStatusReport that are provided
         * @param {Array<ProjectStatusReport>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectStatusReportApiUpdate(body: Array<ProjectStatusReport>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectStatusReportApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of ProjectTaxReport based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectTaxReport>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxReportApiCreate(body: Array<ProjectTaxReport>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectTaxReport>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectTaxReportApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of ProjectTaxReport that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxReportApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectTaxReport>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectTaxReportApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of ProjectTaxReport with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxReportApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectTaxReport> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectTaxReportApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProjectTaxReport with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxReportApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectTaxReportApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectTaxReport that are provided
         * @param {Array<ProjectTaxReport>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxReportApiUpdate(body: Array<ProjectTaxReport>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectTaxReportApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of ProjectTaxSummary based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectTaxSummary>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxSummaryApiCreate(body: Array<ProjectTaxSummary>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectTaxSummary>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectTaxSummaryApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of ProjectTaxSummary that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxSummaryApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectTaxSummary>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectTaxSummaryApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of ProjectTaxSummary with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxSummaryApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectTaxSummary> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectTaxSummaryApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of ProjectTaxSummary with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxSummaryApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectTaxSummaryApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectTaxSummary that are provided
         * @param {Array<ProjectTaxSummary>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxSummaryApiUpdate(body: Array<ProjectTaxSummary>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).projectTaxSummaryApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of PropertySocialProfile based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<PropertySocialProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propertySocialProfileApiCreate(body: Array<PropertySocialProfile>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PropertySocialProfile>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).propertySocialProfileApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of PropertySocialProfile that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propertySocialProfileApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PropertySocialProfile>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).propertySocialProfileApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of PropertySocialProfile with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propertySocialProfileApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PropertySocialProfile> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).propertySocialProfileApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of PropertySocialProfile with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propertySocialProfileApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).propertySocialProfileApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of PropertySocialProfile that are provided
         * @param {Array<PropertySocialProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propertySocialProfileApiUpdate(body: Array<PropertySocialProfile>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).propertySocialProfileApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of Province based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<Province>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceApiCreate(body: Array<Province>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Province>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).provinceApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of Province that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Province>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).provinceApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of Province with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Province> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).provinceApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of Province with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).provinceApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of Province that are provided
         * @param {Array<Province>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceApiUpdate(body: Array<Province>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).provinceApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of RegistrationQuestion based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<RegistrationQuestion>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registrationQuestionApiCreate(body: Array<RegistrationQuestion>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RegistrationQuestion>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).registrationQuestionApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of RegistrationQuestion that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registrationQuestionApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RegistrationQuestion>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).registrationQuestionApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of RegistrationQuestion with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registrationQuestionApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RegistrationQuestion> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).registrationQuestionApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of RegistrationQuestion with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registrationQuestionApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).registrationQuestionApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of RegistrationQuestion that are provided
         * @param {Array<RegistrationQuestion>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registrationQuestionApiUpdate(body: Array<RegistrationQuestion>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).registrationQuestionApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Confirm escrow and trade dates for orders on a roed
         * @param {RoedSchedule1} body 
         * @param {number} id The id of the roed to confirm
         * @param {string} date The date to fill escrow and trade dates if they are empty
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roedSchedule1ApiConfirmReconciliation(body: RoedSchedule1, id: number, date: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).roedSchedule1ApiConfirmReconciliation(body, id, date, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of RoedSchedule1 based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<RoedSchedule1>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roedSchedule1ApiCreate(body: Array<RoedSchedule1>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RoedSchedule1>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).roedSchedule1ApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of RoedSchedule1 that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roedSchedule1ApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RoedSchedule1>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).roedSchedule1ApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of RoedSchedule1 with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roedSchedule1ApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoedSchedule1> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).roedSchedule1ApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of RoedSchedule1 with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roedSchedule1ApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).roedSchedule1ApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of RoedSchedule1 that are provided
         * @param {Array<RoedSchedule1>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roedSchedule1ApiUpdate(body: Array<RoedSchedule1>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).roedSchedule1ApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of Setting based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<Setting>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingApiCreate(body: Array<Setting>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Setting>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).settingApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of Setting that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Setting>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).settingApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of Setting with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Setting> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).settingApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of Setting with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).settingApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of Setting that are provided
         * @param {Array<Setting>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingApiUpdate(body: Array<Setting>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).settingApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of SocialProfileFollowing based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<SocialProfileFollowing>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        socialProfileFollowingApiCreate(body: Array<SocialProfileFollowing>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SocialProfileFollowing>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).socialProfileFollowingApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of SocialProfileFollowing that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        socialProfileFollowingApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SocialProfileFollowing>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).socialProfileFollowingApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of SocialProfileFollowing with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        socialProfileFollowingApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SocialProfileFollowing> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).socialProfileFollowingApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of SocialProfileFollowing with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        socialProfileFollowingApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).socialProfileFollowingApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of SocialProfileFollowing that are provided
         * @param {Array<SocialProfileFollowing>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        socialProfileFollowingApiUpdate(body: Array<SocialProfileFollowing>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).socialProfileFollowingApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of SponsorSocialProfile based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<SponsorSocialProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sponsorSocialProfileApiCreate(body: Array<SponsorSocialProfile>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SponsorSocialProfile>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).sponsorSocialProfileApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of SponsorSocialProfile that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sponsorSocialProfileApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SponsorSocialProfile>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).sponsorSocialProfileApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of SponsorSocialProfile with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sponsorSocialProfileApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SponsorSocialProfile> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).sponsorSocialProfileApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of SponsorSocialProfile with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sponsorSocialProfileApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).sponsorSocialProfileApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of SponsorSocialProfile that are provided
         * @param {Array<SponsorSocialProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sponsorSocialProfileApiUpdate(body: Array<SponsorSocialProfile>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).sponsorSocialProfileApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of SupportEngineer based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<SupportEngineer>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportEngineerApiCreate(body: Array<SupportEngineer>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SupportEngineer>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).supportEngineerApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of SupportEngineer that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportEngineerApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SupportEngineer>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).supportEngineerApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of SupportEngineer with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportEngineerApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SupportEngineer> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).supportEngineerApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of SupportEngineer with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportEngineerApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).supportEngineerApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of SupportEngineer that are provided
         * @param {Array<SupportEngineer>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportEngineerApiUpdate(body: Array<SupportEngineer>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).supportEngineerApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of UserAnswer based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserAnswer>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAnswerApiCreate(body: Array<UserAnswer>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserAnswer>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userAnswerApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of UserAnswer that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAnswerApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserAnswer>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userAnswerApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of UserAnswer with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAnswerApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserAnswer> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userAnswerApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserAnswer with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAnswerApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userAnswerApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserAnswer that are provided
         * @param {Array<UserAnswer>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAnswerApiUpdate(body: Array<UserAnswer>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userAnswerApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of UserBankingDetails based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserBankingDetails>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBankingDetailsApiCreate(body: Array<UserBankingDetails>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserBankingDetails>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userBankingDetailsApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of UserBankingDetails that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBankingDetailsApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserBankingDetails>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userBankingDetailsApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of UserBankingDetails with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBankingDetailsApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserBankingDetails> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userBankingDetailsApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserBankingDetails with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBankingDetailsApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userBankingDetailsApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserBankingDetails that are provided
         * @param {Array<UserBankingDetails>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBankingDetailsApiUpdate(body: Array<UserBankingDetails>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userBankingDetailsApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of UserBasic based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserBasic>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBasicApiCreate(body: Array<UserBasic>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserBasic>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userBasicApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of UserBasic that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBasicApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserBasic>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userBasicApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of UserBasic with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBasicApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserBasic> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userBasicApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserBasic with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBasicApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userBasicApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserBasic that are provided
         * @param {Array<UserBasic>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBasicApiUpdate(body: Array<UserBasic>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userBasicApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of UserBeneficiary based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserBeneficiary>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBeneficiaryApiCreate(body: Array<UserBeneficiary>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserBeneficiary>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userBeneficiaryApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of UserBeneficiary that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBeneficiaryApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserBeneficiary>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userBeneficiaryApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of UserBeneficiary with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBeneficiaryApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserBeneficiary> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userBeneficiaryApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserBeneficiary with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBeneficiaryApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userBeneficiaryApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserBeneficiary that are provided
         * @param {Array<UserBeneficiary>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBeneficiaryApiUpdate(body: Array<UserBeneficiary>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userBeneficiaryApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of UserCorporation based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserCorporation>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCorporationApiCreate(body: Array<UserCorporation>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserCorporation>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userCorporationApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of UserCorporation that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCorporationApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserCorporation>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userCorporationApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of UserCorporation with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCorporationApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserCorporation> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userCorporationApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserCorporation with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCorporationApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userCorporationApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserCorporation that are provided
         * @param {Array<UserCorporation>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCorporationApiUpdate(body: Array<UserCorporation>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userCorporationApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of UserEntity based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserEntity>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEntityApiCreate(body: Array<UserEntity>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserEntity>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userEntityApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of UserEntity that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEntityApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserEntity>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userEntityApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of UserEntity with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEntityApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserEntity> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userEntityApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserEntity with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEntityApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userEntityApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserEntity that are provided
         * @param {Array<UserEntity>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEntityApiUpdate(body: Array<UserEntity>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userEntityApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of UserFinancialKyc based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserFinancialKyc>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFinancialKycApiCreate(body: Array<UserFinancialKyc>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserFinancialKyc>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userFinancialKycApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of UserFinancialKyc that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFinancialKycApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserFinancialKyc>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userFinancialKycApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of UserFinancialKyc with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFinancialKycApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserFinancialKyc> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userFinancialKycApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserFinancialKyc with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFinancialKycApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userFinancialKycApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserFinancialKyc that are provided
         * @param {Array<UserFinancialKyc>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFinancialKycApiUpdate(body: Array<UserFinancialKyc>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userFinancialKycApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of UserInvitation based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserInvitation>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationApiCreate(body: Array<UserInvitation>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserInvitation>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userInvitationApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of UserInvitation that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserInvitation>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userInvitationApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of UserInvitation with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserInvitation> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userInvitationApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserInvitation with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userInvitationApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserInvitation that are provided
         * @param {Array<UserInvitation>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationApiUpdate(body: Array<UserInvitation>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userInvitationApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of UserIssuerAssociation based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserIssuerAssociation>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIssuerAssociationApiCreate(body: Array<UserIssuerAssociation>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserIssuerAssociation>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userIssuerAssociationApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of UserIssuerAssociation that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIssuerAssociationApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserIssuerAssociation>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userIssuerAssociationApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of UserIssuerAssociation with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIssuerAssociationApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserIssuerAssociation> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userIssuerAssociationApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserIssuerAssociation with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIssuerAssociationApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userIssuerAssociationApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserIssuerAssociation that are provided
         * @param {Array<UserIssuerAssociation>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIssuerAssociationApiUpdate(body: Array<UserIssuerAssociation>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userIssuerAssociationApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a new instance of UserPdf base on the value passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the id of the newly created object
         * @param {UserPdf} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPdfApiCreate(body: UserPdf, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserPdf> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userPdfApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Download the file
         * @param {number} id The id of the pdf to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPdfApiDownload(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserPdf> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userPdfApiDownload(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all UserPdf of AdminLog that match the given filter, and structure the associated pdf files and download zipped bundle file
         * @param {string} filter the odata like filter expression use to match which instances are returned. pdf_type, pdf_name, fullName(user.first_name + user.last_name) are mandatory
         * @param {string} pattern a comma separated list of naming pattern that specfiy how the pdf files are structured and named. There are three naming patterns. First and second patterns are for directory and third naming pattern is for pdf file name. If pattern is \&quot;order.project.name,user.client_number,pdf_name\&quot;, you would create a root directory from the property users_pdf.order.project.name, inside of that create a directory from the property users_pdf.user.client_number and in that create a file name users_pdf.pdf_name with a \&quot;.pdf\&quot; suffix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPdfApiDownloadBundle(filter: string, pattern: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userPdfApiDownloadBundle(filter, pattern, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.blob();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all UserPdf of AdminLog that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPdfApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserPdf>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userPdfApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all UserPdf of AdminLog that match the given filter. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPdfApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserPdf> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userPdfApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserPdf with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPdfApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserPdf> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userPdfApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instance of UserPdf that is provided
         * @param {UserPdf} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPdfApiUpdate(body: UserPdf, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserPdf> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userPdfApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of UserRelationship based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserRelationship>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRelationshipApiCreate(body: Array<UserRelationship>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserRelationship>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userRelationshipApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of UserRelationship that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRelationshipApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserRelationship>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userRelationshipApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of UserRelationship with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRelationshipApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserRelationship> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userRelationshipApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserRelationship with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRelationshipApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userRelationshipApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserRelationship that are provided
         * @param {Array<UserRelationship>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRelationshipApiUpdate(body: Array<UserRelationship>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userRelationshipApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of UserRequest based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserRequest>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRequestApiCreate(body: Array<UserRequest>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserRequest>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userRequestApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of UserRequest that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRequestApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserRequest>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userRequestApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of UserRequest with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRequestApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserRequest> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userRequestApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserRequest with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRequestApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userRequestApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserRequest that are provided
         * @param {Array<UserRequest>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRequestApiUpdate(body: Array<UserRequest>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userRequestApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of UserSignupEvent that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSignupEventApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserSignupEvent>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userSignupEventApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of UserSocialPost based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserSocialPost>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialPostApiCreate(body: Array<UserSocialPost>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserSocialPost>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userSocialPostApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of UserSocialPost that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialPostApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserSocialPost>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userSocialPostApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of UserSocialPost with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialPostApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserSocialPost> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userSocialPostApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserSocialPost with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialPostApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userSocialPostApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserSocialPost that are provided
         * @param {Array<UserSocialPost>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialPostApiUpdate(body: Array<UserSocialPost>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userSocialPostApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of UserSocialProfile based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserSocialProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialProfileApiCreate(body: Array<UserSocialProfile>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserSocialProfile>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userSocialProfileApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of UserSocialProfile that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialProfileApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserSocialProfile>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userSocialProfileApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of UserSocialProfile with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialProfileApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserSocialProfile> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userSocialProfileApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserSocialProfile with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialProfileApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userSocialProfileApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserSocialProfile that are provided
         * @param {Array<UserSocialProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialProfileApiUpdate(body: Array<UserSocialProfile>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userSocialProfileApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of UserSubscription based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserSubscription>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSubscriptionApiCreate(body: Array<UserSubscription>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserSubscription>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userSubscriptionApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of UserSubscription that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSubscriptionApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserSubscription>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userSubscriptionApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of UserSubscription with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSubscriptionApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserSubscription> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userSubscriptionApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserSubscription with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSubscriptionApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userSubscriptionApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserSubscription that are provided
         * @param {Array<UserSubscription>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSubscriptionApiUpdate(body: Array<UserSubscription>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userSubscriptionApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of UserTrust based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserTrust>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTrustApiCreate(body: Array<UserTrust>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserTrust>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userTrustApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of UserTrust that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTrustApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserTrust>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userTrustApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of UserTrust with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTrustApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserTrust> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userTrustApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of UserTrust with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTrustApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userTrustApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of UserTrust that are provided
         * @param {Array<UserTrust>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTrustApiUpdate(body: Array<UserTrust>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).userTrustApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new instances of WebHook based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<WebHook>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webHookApiCreate(body: Array<WebHook>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<WebHook>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).webHookApiCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find all instances of WebHook that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webHookApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<WebHook>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).webHookApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find a single instance of WebHook with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webHookApiFindOneById(id: number, expand?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebHook> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).webHookApiFindOneById(id, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the single instance of WebHook with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webHookApiRemove(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).webHookApiRemove(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the values for the instances of WebHook that are provided
         * @param {Array<WebHook>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webHookApiUpdate(body: Array<WebHook>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).webHookApiUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Creates new instances of AdminModule based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<AdminModule>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminModuleApiCreate(body: Array<AdminModule>, options?: any) {
            return DefaultApiFp(configuration).adminModuleApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of AdminModule that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminModuleApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).adminModuleApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of AdminModule with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminModuleApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).adminModuleApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of AdminModule with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminModuleApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).adminModuleApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of AdminModule that are provided
         * @param {Array<AdminModule>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminModuleApiUpdate(body: Array<AdminModule>, options?: any) {
            return DefaultApiFp(configuration).adminModuleApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of AdminUser based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<AdminUser>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserApiCreate(body: Array<AdminUser>, options?: any) {
            return DefaultApiFp(configuration).adminUserApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of AdminUser that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).adminUserApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of AdminUser with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).adminUserApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of AdminUser with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).adminUserApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of AdminUser that are provided
         * @param {Array<AdminUser>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserApiUpdate(body: Array<AdminUser>, options?: any) {
            return DefaultApiFp(configuration).adminUserApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of AllUserAnswer based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<AllUserAnswer>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserAnswerApiCreate(body: Array<AllUserAnswer>, options?: any) {
            return DefaultApiFp(configuration).allUserAnswerApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of AllUserAnswer that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserAnswerApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).allUserAnswerApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of AllUserAnswer with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserAnswerApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).allUserAnswerApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of AllUserAnswer with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserAnswerApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).allUserAnswerApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of AllUserAnswer that are provided
         * @param {Array<AllUserAnswer>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserAnswerApiUpdate(body: Array<AllUserAnswer>, options?: any) {
            return DefaultApiFp(configuration).allUserAnswerApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of AllUser based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<AllUser>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserApiCreate(body: Array<AllUser>, options?: any) {
            return DefaultApiFp(configuration).allUserApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of AllUser that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).allUserApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of AllUser with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).allUserApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a preference setting for a specific user
         * @param {string} preference The name of the preference to get the value of
         * @param {number} id The id of the user to get the preference of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserApiGetPreference(preference: string, id: number, options?: any) {
            return DefaultApiFp(configuration).allUserApiGetPreference(preference, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of AllUser with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).allUserApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set a single preference for a given user
         * @param {Preference} body 
         * @param {number} id The id of the user to set the preference for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserApiSetPreference(body: Preference, id: number, options?: any) {
            return DefaultApiFp(configuration).allUserApiSetPreference(body, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of AllUser that are provided
         * @param {Array<AllUser>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUserApiUpdate(body: Array<AllUser>, options?: any) {
            return DefaultApiFp(configuration).allUserApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of BackgroundProcess based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<BackgroundProcess>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backgroundProcessApiCreate(body: Array<BackgroundProcess>, options?: any) {
            return DefaultApiFp(configuration).backgroundProcessApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of BackgroundProcess that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backgroundProcessApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).backgroundProcessApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of BackgroundProcess with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backgroundProcessApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).backgroundProcessApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of BackgroundProcess with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backgroundProcessApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).backgroundProcessApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of BackgroundProcess that are provided
         * @param {Array<BackgroundProcess>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backgroundProcessApiUpdate(body: Array<BackgroundProcess>, options?: any) {
            return DefaultApiFp(configuration).backgroundProcessApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of ComputedAccount that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedAccountApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).computedAccountApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of ComputedAccountIncome based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ComputedAccountIncome>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedAccountIncomeApiCreate(body: Array<ComputedAccountIncome>, options?: any) {
            return DefaultApiFp(configuration).computedAccountIncomeApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of ComputedAccountIncome that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedAccountIncomeApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).computedAccountIncomeApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of ComputedAccountIncome with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedAccountIncomeApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).computedAccountIncomeApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of ComputedAccountIncome with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedAccountIncomeApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).computedAccountIncomeApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of ComputedAccountIncome that are provided
         * @param {Array<ComputedAccountIncome>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedAccountIncomeApiUpdate(body: Array<ComputedAccountIncome>, options?: any) {
            return DefaultApiFp(configuration).computedAccountIncomeApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of ComputedAccountPosition that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedAccountPositionApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).computedAccountPositionApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of ComputedAccountTotalIncome that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedAccountTotalIncomeApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).computedAccountTotalIncomeApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of ComputedProjectIncome based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ComputedProjectIncome>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedProjectIncomeApiCreate(body: Array<ComputedProjectIncome>, options?: any) {
            return DefaultApiFp(configuration).computedProjectIncomeApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of ComputedProjectIncome that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedProjectIncomeApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).computedProjectIncomeApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of ComputedProjectIncome with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedProjectIncomeApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).computedProjectIncomeApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of ComputedProjectIncome with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedProjectIncomeApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).computedProjectIncomeApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of ComputedProjectIncome that are provided
         * @param {Array<ComputedProjectIncome>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedProjectIncomeApiUpdate(body: Array<ComputedProjectIncome>, options?: any) {
            return DefaultApiFp(configuration).computedProjectIncomeApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of ComputedProjectTotalIncome that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computedProjectTotalIncomeApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).computedProjectTotalIncomeApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of Country based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<Country>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryApiCreate(body: Array<Country>, options?: any) {
            return DefaultApiFp(configuration).countryApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of Country that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).countryApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of Country with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).countryApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of Country with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).countryApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of Country that are provided
         * @param {Array<Country>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryApiUpdate(body: Array<Country>, options?: any) {
            return DefaultApiFp(configuration).countryApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of Event based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<Event>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventApiCreate(body: Array<Event>, options?: any) {
            return DefaultApiFp(configuration).eventApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of Event that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).eventApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of Event with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).eventApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of Event with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).eventApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of Event that are provided
         * @param {Array<Event>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventApiUpdate(body: Array<Event>, options?: any) {
            return DefaultApiFp(configuration).eventApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of ExemptDistributionOption based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ExemptDistributionOption>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exemptDistributionOptionApiCreate(body: Array<ExemptDistributionOption>, options?: any) {
            return DefaultApiFp(configuration).exemptDistributionOptionApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of ExemptDistributionOption that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exemptDistributionOptionApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).exemptDistributionOptionApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of ExemptDistributionOption with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exemptDistributionOptionApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).exemptDistributionOptionApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of ExemptDistributionOption with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exemptDistributionOptionApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).exemptDistributionOptionApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of ExemptDistributionOption that are provided
         * @param {Array<ExemptDistributionOption>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exemptDistributionOptionApiUpdate(body: Array<ExemptDistributionOption>, options?: any) {
            return DefaultApiFp(configuration).exemptDistributionOptionApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of FfbaAssociation based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<FfbaAssociation>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ffbaAssociationApiCreate(body: Array<FfbaAssociation>, options?: any) {
            return DefaultApiFp(configuration).ffbaAssociationApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of FfbaAssociation that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ffbaAssociationApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).ffbaAssociationApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of FfbaAssociation with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ffbaAssociationApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).ffbaAssociationApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of FfbaAssociation with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ffbaAssociationApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).ffbaAssociationApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of FfbaAssociation that are provided
         * @param {Array<FfbaAssociation>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ffbaAssociationApiUpdate(body: Array<FfbaAssociation>, options?: any) {
            return DefaultApiFp(configuration).ffbaAssociationApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Cross check all cms cobranders with hubspot properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotContactCobrandersControllerCheckCobranders(options?: any) {
            return DefaultApiFp(configuration).hubspotContactCobrandersControllerCheckCobranders(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Cross check all cms investors with hubspot contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotContactControllerCheckInvestors(options?: any) {
            return DefaultApiFp(configuration).hubspotContactControllerCheckInvestors(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Synchronize a single cms investor with a corresponding hubspot contact
         * @param {number} id The id of the investor to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotContactControllerSyncInvestor(id: number, options?: any) {
            return DefaultApiFp(configuration).hubspotContactControllerSyncInvestor(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Cross check all cms orders with hubspot deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotDealControllerCheckAllDeals(options?: any) {
            return DefaultApiFp(configuration).hubspotDealControllerCheckAllDeals(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Cross check all cms orders with hubspot deal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotDealControllerCheckOrders(options?: any) {
            return DefaultApiFp(configuration).hubspotDealControllerCheckOrders(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new order based on the details of a deal whoose id is provided
         * @param {string} dealId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotDealControllerCreate(dealId: string, options?: any) {
            return DefaultApiFp(configuration).hubspotDealControllerCreate(dealId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Synchronize a single cms order with a corresponding hubspot deal
         * @param {number} id The id of the order to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotDealControllerSyncOrder(id: number, options?: any) {
            return DefaultApiFp(configuration).hubspotDealControllerSyncOrder(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Ensure a single project is reflected in hubspot custom objects correctly
         * @param {number} id The id of the project to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotProjectControllerCheckProject(id: number, options?: any) {
            return DefaultApiFp(configuration).hubspotProjectControllerCheckProject(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Cross check all cms projects with hubspot properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hubspotProjectControllerCheckProjects(options?: any) {
            return DefaultApiFp(configuration).hubspotProjectControllerCheckProjects(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of ImportedContact based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ImportedContact>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedContactApiCreate(body: Array<ImportedContact>, options?: any) {
            return DefaultApiFp(configuration).importedContactApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of ImportedContact that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedContactApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).importedContactApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of ImportedContact with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedContactApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).importedContactApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of ImportedContact with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedContactApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).importedContactApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of ImportedContact that are provided
         * @param {Array<ImportedContact>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedContactApiUpdate(body: Array<ImportedContact>, options?: any) {
            return DefaultApiFp(configuration).importedContactApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of InvestmentOrder based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<InvestmentOrder>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentOrderApiCreate(body: Array<InvestmentOrder>, options?: any) {
            return DefaultApiFp(configuration).investmentOrderApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of InvestmentOrder that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentOrderApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).investmentOrderApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of InvestmentOrder with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentOrderApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).investmentOrderApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of InvestmentOrder with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentOrderApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).investmentOrderApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of InvestmentOrder that are provided
         * @param {Array<InvestmentOrder>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentOrderApiUpdate(body: Array<InvestmentOrder>, options?: any) {
            return DefaultApiFp(configuration).investmentOrderApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of InvestmentTransaction based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<InvestmentTransaction>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentTransactionApiCreate(body: Array<InvestmentTransaction>, options?: any) {
            return DefaultApiFp(configuration).investmentTransactionApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of InvestmentTransaction that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentTransactionApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).investmentTransactionApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of InvestmentTransaction with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentTransactionApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).investmentTransactionApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of InvestmentTransaction with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentTransactionApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).investmentTransactionApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of InvestmentTransaction that are provided
         * @param {Array<InvestmentTransaction>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentTransactionApiUpdate(body: Array<InvestmentTransaction>, options?: any) {
            return DefaultApiFp(configuration).investmentTransactionApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of InvestmentWatchlist based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<InvestmentWatchlist>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWatchlistApiCreate(body: Array<InvestmentWatchlist>, options?: any) {
            return DefaultApiFp(configuration).investmentWatchlistApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of InvestmentWatchlist that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWatchlistApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).investmentWatchlistApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of InvestmentWatchlist with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWatchlistApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).investmentWatchlistApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of InvestmentWatchlist with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWatchlistApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).investmentWatchlistApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of InvestmentWatchlist that are provided
         * @param {Array<InvestmentWatchlist>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWatchlistApiUpdate(body: Array<InvestmentWatchlist>, options?: any) {
            return DefaultApiFp(configuration).investmentWatchlistApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of InvestmentWithdrawal based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<InvestmentWithdrawal>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWithdrawalApiCreate(body: Array<InvestmentWithdrawal>, options?: any) {
            return DefaultApiFp(configuration).investmentWithdrawalApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of InvestmentWithdrawal that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWithdrawalApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).investmentWithdrawalApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of InvestmentWithdrawal with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWithdrawalApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).investmentWithdrawalApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of InvestmentWithdrawal with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWithdrawalApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).investmentWithdrawalApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of InvestmentWithdrawal that are provided
         * @param {Array<InvestmentWithdrawal>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investmentWithdrawalApiUpdate(body: Array<InvestmentWithdrawal>, options?: any) {
            return DefaultApiFp(configuration).investmentWithdrawalApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of Investor based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<Investor>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiCreate(body: Array<Investor>, options?: any) {
            return DefaultApiFp(configuration).investorApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of Investor that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).investorApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of Investor with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).investorApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all non-deleted orders for a specific investor
         * @param {number} id The id of the investor to get all non-deleted orders for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiGetAllNonDeletedOrders(id: number, options?: any) {
            return DefaultApiFp(configuration).investorApiGetAllNonDeletedOrders(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the annual investment limits for the given investor
         * @param {number} id The id of the investor to get the annual investment limits for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiGetAnnualInvestmentLimits(id: number, options?: any) {
            return DefaultApiFp(configuration).investorApiGetAnnualInvestmentLimits(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary get the oldest non-deleted order in the last year for a given investor
         * @param {number} id the id of the investor to get the oldest non-deleted order in the last year for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiGetOldestNonDeletedOrderLastYear(id: number, options?: any) {
            return DefaultApiFp(configuration).investorApiGetOldestNonDeletedOrderLastYear(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary get the total amount of all orders in the last year for a given investor
         * @param {number} id the id of the investor to get the total amount of all orders in the last year for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiGetTotalAmountInvestedInLastYear(id: number, options?: any) {
            return DefaultApiFp(configuration).investorApiGetTotalAmountInvestedInLastYear(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of Investor with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).investorApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of Investor that are provided
         * @param {Array<Investor>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorApiUpdate(body: Array<Investor>, options?: any) {
            return DefaultApiFp(configuration).investorApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of InvestorCobranding that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorCobrandingApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).investorCobrandingApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of InvestorEarning based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<InvestorEarning>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorEarningApiCreate(body: Array<InvestorEarning>, options?: any) {
            return DefaultApiFp(configuration).investorEarningApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of InvestorEarning that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorEarningApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).investorEarningApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of InvestorEarning with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorEarningApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).investorEarningApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of InvestorEarning with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorEarningApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).investorEarningApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of InvestorEarning that are provided
         * @param {Array<InvestorEarning>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorEarningApiUpdate(body: Array<InvestorEarning>, options?: any) {
            return DefaultApiFp(configuration).investorEarningApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of InvestorIntendedTrades based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<InvestorIntendedTrades>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorIntendedTradesApiCreate(body: Array<InvestorIntendedTrades>, options?: any) {
            return DefaultApiFp(configuration).investorIntendedTradesApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of InvestorIntendedTrades that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorIntendedTradesApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).investorIntendedTradesApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of InvestorIntendedTrades with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorIntendedTradesApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).investorIntendedTradesApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of InvestorIntendedTrades with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorIntendedTradesApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).investorIntendedTradesApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of InvestorIntendedTrades that are provided
         * @param {Array<InvestorIntendedTrades>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorIntendedTradesApiUpdate(body: Array<InvestorIntendedTrades>, options?: any) {
            return DefaultApiFp(configuration).investorIntendedTradesApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of InvestorSocialProfile based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<InvestorSocialProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorSocialProfileApiCreate(body: Array<InvestorSocialProfile>, options?: any) {
            return DefaultApiFp(configuration).investorSocialProfileApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of InvestorSocialProfile that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorSocialProfileApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).investorSocialProfileApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of InvestorSocialProfile with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorSocialProfileApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).investorSocialProfileApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of InvestorSocialProfile with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorSocialProfileApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).investorSocialProfileApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of InvestorSocialProfile that are provided
         * @param {Array<InvestorSocialProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        investorSocialProfileApiUpdate(body: Array<InvestorSocialProfile>, options?: any) {
            return DefaultApiFp(configuration).investorSocialProfileApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of IssuerAdmin based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<IssuerAdmin>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuerAdminApiCreate(body: Array<IssuerAdmin>, options?: any) {
            return DefaultApiFp(configuration).issuerAdminApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of IssuerAdmin that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuerAdminApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).issuerAdminApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of IssuerAdmin with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuerAdminApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).issuerAdminApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of IssuerAdmin with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuerAdminApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).issuerAdminApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of IssuerAdmin that are provided
         * @param {Array<IssuerAdmin>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuerAdminApiUpdate(body: Array<IssuerAdmin>, options?: any) {
            return DefaultApiFp(configuration).issuerAdminApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of Mail based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<Mail>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mailApiCreate(body: Array<Mail>, options?: any) {
            return DefaultApiFp(configuration).mailApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of Mail that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mailApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).mailApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of Mail with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mailApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).mailApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of Mail with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mailApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).mailApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of Mail that are provided
         * @param {Array<Mail>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mailApiUpdate(body: Array<Mail>, options?: any) {
            return DefaultApiFp(configuration).mailApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of Menu based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<Menu>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menuApiCreate(body: Array<Menu>, options?: any) {
            return DefaultApiFp(configuration).menuApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of Menu that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menuApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).menuApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of Menu with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menuApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).menuApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of Menu with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menuApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).menuApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of Menu that are provided
         * @param {Array<Menu>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menuApiUpdate(body: Array<Menu>, options?: any) {
            return DefaultApiFp(configuration).menuApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a metrics based on a request saved in the current users specified preference
         * @param {string} preference The name of the preference to get the request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsApiFindByPreference(preference: string, options?: any) {
            return DefaultApiFp(configuration).metricsApiFindByPreference(preference, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the data associated with the specified metric
         * @param {MetricsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsApiFindOneById(body: MetricsRequest, options?: any) {
            return DefaultApiFp(configuration).metricsApiFindOneById(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Save the given request as a preference and then get the mtrics
         * @param {MetricsRequest} body 
         * @param {string} preference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsApiSavePreferenceAnGet(body: MetricsRequest, preference: string, options?: any) {
            return DefaultApiFp(configuration).metricsApiSavePreferenceAnGet(body, preference, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of ModuleAccess based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ModuleAccess>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleAccessApiCreate(body: Array<ModuleAccess>, options?: any) {
            return DefaultApiFp(configuration).moduleAccessApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of ModuleAccess that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleAccessApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).moduleAccessApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of ModuleAccess with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleAccessApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).moduleAccessApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of ModuleAccess with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleAccessApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).moduleAccessApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of ModuleAccess that are provided
         * @param {Array<ModuleAccess>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleAccessApiUpdate(body: Array<ModuleAccess>, options?: any) {
            return DefaultApiFp(configuration).moduleAccessApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of NotableInvestorProfile based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<NotableInvestorProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notableInvestorProfileApiCreate(body: Array<NotableInvestorProfile>, options?: any) {
            return DefaultApiFp(configuration).notableInvestorProfileApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of NotableInvestorProfile that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notableInvestorProfileApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).notableInvestorProfileApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of NotableInvestorProfile with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notableInvestorProfileApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).notableInvestorProfileApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of NotableInvestorProfile with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notableInvestorProfileApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).notableInvestorProfileApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of NotableInvestorProfile that are provided
         * @param {Array<NotableInvestorProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notableInvestorProfileApiUpdate(body: Array<NotableInvestorProfile>, options?: any) {
            return DefaultApiFp(configuration).notableInvestorProfileApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of OrderAcknowledgement based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<OrderAcknowledgement>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementApiCreate(body: Array<OrderAcknowledgement>, options?: any) {
            return DefaultApiFp(configuration).orderAcknowledgementApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of OrderAcknowledgement that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).orderAcknowledgementApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of OrderAcknowledgement with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).orderAcknowledgementApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of OrderAcknowledgement with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).orderAcknowledgementApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of OrderAcknowledgement that are provided
         * @param {Array<OrderAcknowledgement>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementApiUpdate(body: Array<OrderAcknowledgement>, options?: any) {
            return DefaultApiFp(configuration).orderAcknowledgementApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of OrderAcknowledgementQuestion based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<OrderAcknowledgementQuestion>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementQuestionApiCreate(body: Array<OrderAcknowledgementQuestion>, options?: any) {
            return DefaultApiFp(configuration).orderAcknowledgementQuestionApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of OrderAcknowledgementQuestion that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementQuestionApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).orderAcknowledgementQuestionApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of OrderAcknowledgementQuestion with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementQuestionApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).orderAcknowledgementQuestionApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of OrderAcknowledgementQuestion with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementQuestionApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).orderAcknowledgementQuestionApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of OrderAcknowledgementQuestion that are provided
         * @param {Array<OrderAcknowledgementQuestion>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAcknowledgementQuestionApiUpdate(body: Array<OrderAcknowledgementQuestion>, options?: any) {
            return DefaultApiFp(configuration).orderAcknowledgementQuestionApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of ProfileBackground based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProfileBackground>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileBackgroundApiCreate(body: Array<ProfileBackground>, options?: any) {
            return DefaultApiFp(configuration).profileBackgroundApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of ProfileBackground that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileBackgroundApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).profileBackgroundApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of ProfileBackground with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileBackgroundApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).profileBackgroundApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of ProfileBackground with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileBackgroundApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).profileBackgroundApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of ProfileBackground that are provided
         * @param {Array<ProfileBackground>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileBackgroundApiUpdate(body: Array<ProfileBackground>, options?: any) {
            return DefaultApiFp(configuration).profileBackgroundApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of ProjectAccount based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectAccount>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectAccountApiCreate(body: Array<ProjectAccount>, options?: any) {
            return DefaultApiFp(configuration).projectAccountApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of ProjectAccount that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectAccountApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).projectAccountApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of ProjectAccount with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectAccountApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).projectAccountApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of ProjectAccount with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectAccountApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).projectAccountApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectAccount that are provided
         * @param {Array<ProjectAccount>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectAccountApiUpdate(body: Array<ProjectAccount>, options?: any) {
            return DefaultApiFp(configuration).projectAccountApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of Project based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<Project>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectApiCreate(body: Array<Project>, options?: any) {
            return DefaultApiFp(configuration).projectApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of Project that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).projectApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of Project with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).projectApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of Project with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).projectApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of Project that are provided
         * @param {Array<Project>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectApiUpdate(body: Array<Project>, options?: any) {
            return DefaultApiFp(configuration).projectApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of ProjectBalanceAdjustment based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectBalanceAdjustment>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectBalanceAdjustmentApiCreate(body: Array<ProjectBalanceAdjustment>, options?: any) {
            return DefaultApiFp(configuration).projectBalanceAdjustmentApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of ProjectBalanceAdjustment that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectBalanceAdjustmentApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).projectBalanceAdjustmentApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of ProjectBalanceAdjustment with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectBalanceAdjustmentApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).projectBalanceAdjustmentApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of ProjectBalanceAdjustment with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectBalanceAdjustmentApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).projectBalanceAdjustmentApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectBalanceAdjustment that are provided
         * @param {Array<ProjectBalanceAdjustment>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectBalanceAdjustmentApiUpdate(body: Array<ProjectBalanceAdjustment>, options?: any) {
            return DefaultApiFp(configuration).projectBalanceAdjustmentApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of ProjectDocusignMapping based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectDocusignMapping>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDocusignMappingApiCreate(body: Array<ProjectDocusignMapping>, options?: any) {
            return DefaultApiFp(configuration).projectDocusignMappingApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of ProjectDocusignMapping that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDocusignMappingApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).projectDocusignMappingApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of ProjectDocusignMapping with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDocusignMappingApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).projectDocusignMappingApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of ProjectDocusignMapping with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDocusignMappingApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).projectDocusignMappingApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectDocusignMapping that are provided
         * @param {Array<ProjectDocusignMapping>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectDocusignMappingApiUpdate(body: Array<ProjectDocusignMapping>, options?: any) {
            return DefaultApiFp(configuration).projectDocusignMappingApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of ProjectEntity based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectEntity>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityApiCreate(body: Array<ProjectEntity>, options?: any) {
            return DefaultApiFp(configuration).projectEntityApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of ProjectEntity that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).projectEntityApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of ProjectEntity with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).projectEntityApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of ProjectEntity with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).projectEntityApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectEntity that are provided
         * @param {Array<ProjectEntity>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityApiUpdate(body: Array<ProjectEntity>, options?: any) {
            return DefaultApiFp(configuration).projectEntityApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of ProjectEntityDetail based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectEntityDetail>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityDetailApiCreate(body: Array<ProjectEntityDetail>, options?: any) {
            return DefaultApiFp(configuration).projectEntityDetailApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of ProjectEntityDetail that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityDetailApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).projectEntityDetailApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of ProjectEntityDetail with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityDetailApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).projectEntityDetailApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of ProjectEntityDetail with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityDetailApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).projectEntityDetailApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectEntityDetail that are provided
         * @param {Array<ProjectEntityDetail>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectEntityDetailApiUpdate(body: Array<ProjectEntityDetail>, options?: any) {
            return DefaultApiFp(configuration).projectEntityDetailApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of ProjectImage based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectImage>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectImageApiCreate(body: Array<ProjectImage>, options?: any) {
            return DefaultApiFp(configuration).projectImageApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of ProjectImage that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectImageApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).projectImageApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of ProjectImage with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectImageApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).projectImageApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of ProjectImage with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectImageApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).projectImageApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectImage that are provided
         * @param {Array<ProjectImage>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectImageApiUpdate(body: Array<ProjectImage>, options?: any) {
            return DefaultApiFp(configuration).projectImageApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of ProjectInterest based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectInterest>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectInterestApiCreate(body: Array<ProjectInterest>, options?: any) {
            return DefaultApiFp(configuration).projectInterestApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of ProjectInterest that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectInterestApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).projectInterestApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of ProjectInterest with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectInterestApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).projectInterestApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of ProjectInterest with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectInterestApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).projectInterestApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectInterest that are provided
         * @param {Array<ProjectInterest>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectInterestApiUpdate(body: Array<ProjectInterest>, options?: any) {
            return DefaultApiFp(configuration).projectInterestApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of ProjectKeybacker based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectKeybacker>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectKeybackerApiCreate(body: Array<ProjectKeybacker>, options?: any) {
            return DefaultApiFp(configuration).projectKeybackerApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of ProjectKeybacker that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectKeybackerApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).projectKeybackerApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of ProjectKeybacker with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectKeybackerApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).projectKeybackerApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of ProjectKeybacker with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectKeybackerApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).projectKeybackerApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectKeybacker that are provided
         * @param {Array<ProjectKeybacker>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectKeybackerApiUpdate(body: Array<ProjectKeybacker>, options?: any) {
            return DefaultApiFp(configuration).projectKeybackerApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of ProjectPdf based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectPdf>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectPdfApiCreate(body: Array<ProjectPdf>, options?: any) {
            return DefaultApiFp(configuration).projectPdfApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of ProjectPdf that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectPdfApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).projectPdfApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of ProjectPdf with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectPdfApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).projectPdfApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of ProjectPdf with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectPdfApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).projectPdfApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectPdf that are provided
         * @param {Array<ProjectPdf>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectPdfApiUpdate(body: Array<ProjectPdf>, options?: any) {
            return DefaultApiFp(configuration).projectPdfApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of ProjectStatusReport based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectStatusReport>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectStatusReportApiCreate(body: Array<ProjectStatusReport>, options?: any) {
            return DefaultApiFp(configuration).projectStatusReportApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of ProjectStatusReport that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectStatusReportApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).projectStatusReportApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of ProjectStatusReport with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectStatusReportApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).projectStatusReportApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of ProjectStatusReport with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectStatusReportApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).projectStatusReportApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectStatusReport that are provided
         * @param {Array<ProjectStatusReport>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectStatusReportApiUpdate(body: Array<ProjectStatusReport>, options?: any) {
            return DefaultApiFp(configuration).projectStatusReportApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of ProjectTaxReport based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectTaxReport>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxReportApiCreate(body: Array<ProjectTaxReport>, options?: any) {
            return DefaultApiFp(configuration).projectTaxReportApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of ProjectTaxReport that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxReportApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).projectTaxReportApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of ProjectTaxReport with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxReportApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).projectTaxReportApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of ProjectTaxReport with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxReportApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).projectTaxReportApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectTaxReport that are provided
         * @param {Array<ProjectTaxReport>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxReportApiUpdate(body: Array<ProjectTaxReport>, options?: any) {
            return DefaultApiFp(configuration).projectTaxReportApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of ProjectTaxSummary based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<ProjectTaxSummary>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxSummaryApiCreate(body: Array<ProjectTaxSummary>, options?: any) {
            return DefaultApiFp(configuration).projectTaxSummaryApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of ProjectTaxSummary that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxSummaryApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).projectTaxSummaryApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of ProjectTaxSummary with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxSummaryApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).projectTaxSummaryApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of ProjectTaxSummary with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxSummaryApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).projectTaxSummaryApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of ProjectTaxSummary that are provided
         * @param {Array<ProjectTaxSummary>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectTaxSummaryApiUpdate(body: Array<ProjectTaxSummary>, options?: any) {
            return DefaultApiFp(configuration).projectTaxSummaryApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of PropertySocialProfile based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<PropertySocialProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propertySocialProfileApiCreate(body: Array<PropertySocialProfile>, options?: any) {
            return DefaultApiFp(configuration).propertySocialProfileApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of PropertySocialProfile that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propertySocialProfileApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).propertySocialProfileApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of PropertySocialProfile with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propertySocialProfileApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).propertySocialProfileApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of PropertySocialProfile with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propertySocialProfileApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).propertySocialProfileApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of PropertySocialProfile that are provided
         * @param {Array<PropertySocialProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        propertySocialProfileApiUpdate(body: Array<PropertySocialProfile>, options?: any) {
            return DefaultApiFp(configuration).propertySocialProfileApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of Province based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<Province>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceApiCreate(body: Array<Province>, options?: any) {
            return DefaultApiFp(configuration).provinceApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of Province that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).provinceApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of Province with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).provinceApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of Province with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).provinceApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of Province that are provided
         * @param {Array<Province>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provinceApiUpdate(body: Array<Province>, options?: any) {
            return DefaultApiFp(configuration).provinceApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of RegistrationQuestion based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<RegistrationQuestion>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registrationQuestionApiCreate(body: Array<RegistrationQuestion>, options?: any) {
            return DefaultApiFp(configuration).registrationQuestionApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of RegistrationQuestion that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registrationQuestionApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).registrationQuestionApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of RegistrationQuestion with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registrationQuestionApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).registrationQuestionApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of RegistrationQuestion with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registrationQuestionApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).registrationQuestionApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of RegistrationQuestion that are provided
         * @param {Array<RegistrationQuestion>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registrationQuestionApiUpdate(body: Array<RegistrationQuestion>, options?: any) {
            return DefaultApiFp(configuration).registrationQuestionApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Confirm escrow and trade dates for orders on a roed
         * @param {RoedSchedule1} body 
         * @param {number} id The id of the roed to confirm
         * @param {string} date The date to fill escrow and trade dates if they are empty
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roedSchedule1ApiConfirmReconciliation(body: RoedSchedule1, id: number, date: string, options?: any) {
            return DefaultApiFp(configuration).roedSchedule1ApiConfirmReconciliation(body, id, date, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of RoedSchedule1 based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<RoedSchedule1>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roedSchedule1ApiCreate(body: Array<RoedSchedule1>, options?: any) {
            return DefaultApiFp(configuration).roedSchedule1ApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of RoedSchedule1 that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roedSchedule1ApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).roedSchedule1ApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of RoedSchedule1 with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roedSchedule1ApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).roedSchedule1ApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of RoedSchedule1 with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roedSchedule1ApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).roedSchedule1ApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of RoedSchedule1 that are provided
         * @param {Array<RoedSchedule1>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roedSchedule1ApiUpdate(body: Array<RoedSchedule1>, options?: any) {
            return DefaultApiFp(configuration).roedSchedule1ApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of Setting based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<Setting>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingApiCreate(body: Array<Setting>, options?: any) {
            return DefaultApiFp(configuration).settingApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of Setting that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).settingApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of Setting with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).settingApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of Setting with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).settingApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of Setting that are provided
         * @param {Array<Setting>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingApiUpdate(body: Array<Setting>, options?: any) {
            return DefaultApiFp(configuration).settingApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of SocialProfileFollowing based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<SocialProfileFollowing>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        socialProfileFollowingApiCreate(body: Array<SocialProfileFollowing>, options?: any) {
            return DefaultApiFp(configuration).socialProfileFollowingApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of SocialProfileFollowing that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        socialProfileFollowingApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).socialProfileFollowingApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of SocialProfileFollowing with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        socialProfileFollowingApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).socialProfileFollowingApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of SocialProfileFollowing with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        socialProfileFollowingApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).socialProfileFollowingApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of SocialProfileFollowing that are provided
         * @param {Array<SocialProfileFollowing>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        socialProfileFollowingApiUpdate(body: Array<SocialProfileFollowing>, options?: any) {
            return DefaultApiFp(configuration).socialProfileFollowingApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of SponsorSocialProfile based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<SponsorSocialProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sponsorSocialProfileApiCreate(body: Array<SponsorSocialProfile>, options?: any) {
            return DefaultApiFp(configuration).sponsorSocialProfileApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of SponsorSocialProfile that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sponsorSocialProfileApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).sponsorSocialProfileApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of SponsorSocialProfile with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sponsorSocialProfileApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).sponsorSocialProfileApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of SponsorSocialProfile with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sponsorSocialProfileApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).sponsorSocialProfileApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of SponsorSocialProfile that are provided
         * @param {Array<SponsorSocialProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sponsorSocialProfileApiUpdate(body: Array<SponsorSocialProfile>, options?: any) {
            return DefaultApiFp(configuration).sponsorSocialProfileApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of SupportEngineer based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<SupportEngineer>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportEngineerApiCreate(body: Array<SupportEngineer>, options?: any) {
            return DefaultApiFp(configuration).supportEngineerApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of SupportEngineer that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportEngineerApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).supportEngineerApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of SupportEngineer with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportEngineerApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).supportEngineerApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of SupportEngineer with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportEngineerApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).supportEngineerApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of SupportEngineer that are provided
         * @param {Array<SupportEngineer>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportEngineerApiUpdate(body: Array<SupportEngineer>, options?: any) {
            return DefaultApiFp(configuration).supportEngineerApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of UserAnswer based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserAnswer>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAnswerApiCreate(body: Array<UserAnswer>, options?: any) {
            return DefaultApiFp(configuration).userAnswerApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of UserAnswer that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAnswerApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).userAnswerApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of UserAnswer with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAnswerApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).userAnswerApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of UserAnswer with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAnswerApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).userAnswerApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of UserAnswer that are provided
         * @param {Array<UserAnswer>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAnswerApiUpdate(body: Array<UserAnswer>, options?: any) {
            return DefaultApiFp(configuration).userAnswerApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of UserBankingDetails based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserBankingDetails>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBankingDetailsApiCreate(body: Array<UserBankingDetails>, options?: any) {
            return DefaultApiFp(configuration).userBankingDetailsApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of UserBankingDetails that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBankingDetailsApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).userBankingDetailsApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of UserBankingDetails with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBankingDetailsApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).userBankingDetailsApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of UserBankingDetails with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBankingDetailsApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).userBankingDetailsApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of UserBankingDetails that are provided
         * @param {Array<UserBankingDetails>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBankingDetailsApiUpdate(body: Array<UserBankingDetails>, options?: any) {
            return DefaultApiFp(configuration).userBankingDetailsApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of UserBasic based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserBasic>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBasicApiCreate(body: Array<UserBasic>, options?: any) {
            return DefaultApiFp(configuration).userBasicApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of UserBasic that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBasicApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).userBasicApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of UserBasic with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBasicApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).userBasicApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of UserBasic with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBasicApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).userBasicApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of UserBasic that are provided
         * @param {Array<UserBasic>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBasicApiUpdate(body: Array<UserBasic>, options?: any) {
            return DefaultApiFp(configuration).userBasicApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of UserBeneficiary based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserBeneficiary>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBeneficiaryApiCreate(body: Array<UserBeneficiary>, options?: any) {
            return DefaultApiFp(configuration).userBeneficiaryApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of UserBeneficiary that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBeneficiaryApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).userBeneficiaryApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of UserBeneficiary with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBeneficiaryApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).userBeneficiaryApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of UserBeneficiary with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBeneficiaryApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).userBeneficiaryApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of UserBeneficiary that are provided
         * @param {Array<UserBeneficiary>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBeneficiaryApiUpdate(body: Array<UserBeneficiary>, options?: any) {
            return DefaultApiFp(configuration).userBeneficiaryApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of UserCorporation based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserCorporation>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCorporationApiCreate(body: Array<UserCorporation>, options?: any) {
            return DefaultApiFp(configuration).userCorporationApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of UserCorporation that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCorporationApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).userCorporationApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of UserCorporation with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCorporationApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).userCorporationApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of UserCorporation with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCorporationApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).userCorporationApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of UserCorporation that are provided
         * @param {Array<UserCorporation>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCorporationApiUpdate(body: Array<UserCorporation>, options?: any) {
            return DefaultApiFp(configuration).userCorporationApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of UserEntity based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserEntity>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEntityApiCreate(body: Array<UserEntity>, options?: any) {
            return DefaultApiFp(configuration).userEntityApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of UserEntity that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEntityApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).userEntityApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of UserEntity with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEntityApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).userEntityApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of UserEntity with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEntityApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).userEntityApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of UserEntity that are provided
         * @param {Array<UserEntity>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEntityApiUpdate(body: Array<UserEntity>, options?: any) {
            return DefaultApiFp(configuration).userEntityApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of UserFinancialKyc based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserFinancialKyc>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFinancialKycApiCreate(body: Array<UserFinancialKyc>, options?: any) {
            return DefaultApiFp(configuration).userFinancialKycApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of UserFinancialKyc that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFinancialKycApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).userFinancialKycApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of UserFinancialKyc with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFinancialKycApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).userFinancialKycApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of UserFinancialKyc with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFinancialKycApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).userFinancialKycApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of UserFinancialKyc that are provided
         * @param {Array<UserFinancialKyc>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFinancialKycApiUpdate(body: Array<UserFinancialKyc>, options?: any) {
            return DefaultApiFp(configuration).userFinancialKycApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of UserInvitation based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserInvitation>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationApiCreate(body: Array<UserInvitation>, options?: any) {
            return DefaultApiFp(configuration).userInvitationApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of UserInvitation that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).userInvitationApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of UserInvitation with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).userInvitationApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of UserInvitation with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).userInvitationApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of UserInvitation that are provided
         * @param {Array<UserInvitation>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationApiUpdate(body: Array<UserInvitation>, options?: any) {
            return DefaultApiFp(configuration).userInvitationApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of UserIssuerAssociation based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserIssuerAssociation>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIssuerAssociationApiCreate(body: Array<UserIssuerAssociation>, options?: any) {
            return DefaultApiFp(configuration).userIssuerAssociationApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of UserIssuerAssociation that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIssuerAssociationApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).userIssuerAssociationApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of UserIssuerAssociation with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIssuerAssociationApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).userIssuerAssociationApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of UserIssuerAssociation with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIssuerAssociationApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).userIssuerAssociationApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of UserIssuerAssociation that are provided
         * @param {Array<UserIssuerAssociation>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIssuerAssociationApiUpdate(body: Array<UserIssuerAssociation>, options?: any) {
            return DefaultApiFp(configuration).userIssuerAssociationApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of UserPdf base on the value passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the id of the newly created object
         * @param {UserPdf} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPdfApiCreate(body: UserPdf, options?: any) {
            return DefaultApiFp(configuration).userPdfApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Download the file
         * @param {number} id The id of the pdf to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPdfApiDownload(id: number, options?: any) {
            return DefaultApiFp(configuration).userPdfApiDownload(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all UserPdf of AdminLog that match the given filter, and structure the associated pdf files and download zipped bundle file
         * @param {string} filter the odata like filter expression use to match which instances are returned. pdf_type, pdf_name, fullName(user.first_name + user.last_name) are mandatory
         * @param {string} pattern a comma separated list of naming pattern that specfiy how the pdf files are structured and named. There are three naming patterns. First and second patterns are for directory and third naming pattern is for pdf file name. If pattern is \&quot;order.project.name,user.client_number,pdf_name\&quot;, you would create a root directory from the property users_pdf.order.project.name, inside of that create a directory from the property users_pdf.user.client_number and in that create a file name users_pdf.pdf_name with a \&quot;.pdf\&quot; suffix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPdfApiDownloadBundle(filter: string, pattern: string, options?: any) {
            return DefaultApiFp(configuration).userPdfApiDownloadBundle(filter, pattern, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all UserPdf of AdminLog that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPdfApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).userPdfApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all UserPdf of AdminLog that match the given filter. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPdfApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).userPdfApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of UserPdf with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPdfApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).userPdfApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instance of UserPdf that is provided
         * @param {UserPdf} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPdfApiUpdate(body: UserPdf, options?: any) {
            return DefaultApiFp(configuration).userPdfApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of UserRelationship based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserRelationship>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRelationshipApiCreate(body: Array<UserRelationship>, options?: any) {
            return DefaultApiFp(configuration).userRelationshipApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of UserRelationship that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRelationshipApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).userRelationshipApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of UserRelationship with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRelationshipApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).userRelationshipApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of UserRelationship with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRelationshipApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).userRelationshipApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of UserRelationship that are provided
         * @param {Array<UserRelationship>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRelationshipApiUpdate(body: Array<UserRelationship>, options?: any) {
            return DefaultApiFp(configuration).userRelationshipApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of UserRequest based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserRequest>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRequestApiCreate(body: Array<UserRequest>, options?: any) {
            return DefaultApiFp(configuration).userRequestApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of UserRequest that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRequestApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).userRequestApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of UserRequest with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRequestApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).userRequestApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of UserRequest with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRequestApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).userRequestApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of UserRequest that are provided
         * @param {Array<UserRequest>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRequestApiUpdate(body: Array<UserRequest>, options?: any) {
            return DefaultApiFp(configuration).userRequestApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of UserSignupEvent that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSignupEventApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).userSignupEventApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of UserSocialPost based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserSocialPost>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialPostApiCreate(body: Array<UserSocialPost>, options?: any) {
            return DefaultApiFp(configuration).userSocialPostApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of UserSocialPost that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialPostApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).userSocialPostApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of UserSocialPost with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialPostApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).userSocialPostApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of UserSocialPost with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialPostApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).userSocialPostApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of UserSocialPost that are provided
         * @param {Array<UserSocialPost>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialPostApiUpdate(body: Array<UserSocialPost>, options?: any) {
            return DefaultApiFp(configuration).userSocialPostApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of UserSocialProfile based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserSocialProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialProfileApiCreate(body: Array<UserSocialProfile>, options?: any) {
            return DefaultApiFp(configuration).userSocialProfileApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of UserSocialProfile that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialProfileApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).userSocialProfileApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of UserSocialProfile with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialProfileApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).userSocialProfileApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of UserSocialProfile with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialProfileApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).userSocialProfileApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of UserSocialProfile that are provided
         * @param {Array<UserSocialProfile>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSocialProfileApiUpdate(body: Array<UserSocialProfile>, options?: any) {
            return DefaultApiFp(configuration).userSocialProfileApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of UserSubscription based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserSubscription>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSubscriptionApiCreate(body: Array<UserSubscription>, options?: any) {
            return DefaultApiFp(configuration).userSubscriptionApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of UserSubscription that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSubscriptionApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).userSubscriptionApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of UserSubscription with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSubscriptionApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).userSubscriptionApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of UserSubscription with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSubscriptionApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).userSubscriptionApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of UserSubscription that are provided
         * @param {Array<UserSubscription>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSubscriptionApiUpdate(body: Array<UserSubscription>, options?: any) {
            return DefaultApiFp(configuration).userSubscriptionApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of UserTrust based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<UserTrust>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTrustApiCreate(body: Array<UserTrust>, options?: any) {
            return DefaultApiFp(configuration).userTrustApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of UserTrust that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTrustApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).userTrustApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of UserTrust with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTrustApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).userTrustApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of UserTrust with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTrustApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).userTrustApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of UserTrust that are provided
         * @param {Array<UserTrust>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTrustApiUpdate(body: Array<UserTrust>, options?: any) {
            return DefaultApiFp(configuration).userTrustApiUpdate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new instances of WebHook based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
         * @param {Array<WebHook>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webHookApiCreate(body: Array<WebHook>, options?: any) {
            return DefaultApiFp(configuration).webHookApiCreate(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of WebHook that match the given filter. If none are found, an empty result is returned
         * @param {string} [filter] the odata like filter expression use to match which instances are returned
         * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
         * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
         * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webHookApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
            return DefaultApiFp(configuration).webHookApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a single instance of WebHook with the given id. If none are found, an empty result is returned
         * @param {number} id The id of the instance to retrieve
         * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webHookApiFindOneById(id: number, expand?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).webHookApiFindOneById(id, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the single instance of WebHook with the specified id
         * @param {number} id The id of the instance to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webHookApiRemove(id: number, options?: any) {
            return DefaultApiFp(configuration).webHookApiRemove(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the values for the instances of WebHook that are provided
         * @param {Array<WebHook>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webHookApiUpdate(body: Array<WebHook>, options?: any) {
            return DefaultApiFp(configuration).webHookApiUpdate(body, options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Creates new instances of AdminModule based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<AdminModule>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public adminModuleApiCreate(body: Array<AdminModule>, options?: any) {
        return DefaultApiFp(this.configuration).adminModuleApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of AdminModule that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public adminModuleApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).adminModuleApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of AdminModule with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public adminModuleApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).adminModuleApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of AdminModule with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public adminModuleApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).adminModuleApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of AdminModule that are provided
     * @param {Array<AdminModule>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public adminModuleApiUpdate(body: Array<AdminModule>, options?: any) {
        return DefaultApiFp(this.configuration).adminModuleApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of AdminUser based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<AdminUser>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public adminUserApiCreate(body: Array<AdminUser>, options?: any) {
        return DefaultApiFp(this.configuration).adminUserApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of AdminUser that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public adminUserApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).adminUserApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of AdminUser with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public adminUserApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).adminUserApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of AdminUser with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public adminUserApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).adminUserApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of AdminUser that are provided
     * @param {Array<AdminUser>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public adminUserApiUpdate(body: Array<AdminUser>, options?: any) {
        return DefaultApiFp(this.configuration).adminUserApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of AllUserAnswer based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<AllUserAnswer>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public allUserAnswerApiCreate(body: Array<AllUserAnswer>, options?: any) {
        return DefaultApiFp(this.configuration).allUserAnswerApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of AllUserAnswer that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public allUserAnswerApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).allUserAnswerApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of AllUserAnswer with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public allUserAnswerApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).allUserAnswerApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of AllUserAnswer with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public allUserAnswerApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).allUserAnswerApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of AllUserAnswer that are provided
     * @param {Array<AllUserAnswer>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public allUserAnswerApiUpdate(body: Array<AllUserAnswer>, options?: any) {
        return DefaultApiFp(this.configuration).allUserAnswerApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of AllUser based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<AllUser>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public allUserApiCreate(body: Array<AllUser>, options?: any) {
        return DefaultApiFp(this.configuration).allUserApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of AllUser that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public allUserApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).allUserApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of AllUser with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public allUserApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).allUserApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a preference setting for a specific user
     * @param {string} preference The name of the preference to get the value of
     * @param {number} id The id of the user to get the preference of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public allUserApiGetPreference(preference: string, id: number, options?: any) {
        return DefaultApiFp(this.configuration).allUserApiGetPreference(preference, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of AllUser with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public allUserApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).allUserApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set a single preference for a given user
     * @param {Preference} body 
     * @param {number} id The id of the user to set the preference for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public allUserApiSetPreference(body: Preference, id: number, options?: any) {
        return DefaultApiFp(this.configuration).allUserApiSetPreference(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of AllUser that are provided
     * @param {Array<AllUser>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public allUserApiUpdate(body: Array<AllUser>, options?: any) {
        return DefaultApiFp(this.configuration).allUserApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of BackgroundProcess based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<BackgroundProcess>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public backgroundProcessApiCreate(body: Array<BackgroundProcess>, options?: any) {
        return DefaultApiFp(this.configuration).backgroundProcessApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of BackgroundProcess that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public backgroundProcessApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).backgroundProcessApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of BackgroundProcess with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public backgroundProcessApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).backgroundProcessApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of BackgroundProcess with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public backgroundProcessApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).backgroundProcessApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of BackgroundProcess that are provided
     * @param {Array<BackgroundProcess>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public backgroundProcessApiUpdate(body: Array<BackgroundProcess>, options?: any) {
        return DefaultApiFp(this.configuration).backgroundProcessApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of ComputedAccount that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public computedAccountApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).computedAccountApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of ComputedAccountIncome based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<ComputedAccountIncome>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public computedAccountIncomeApiCreate(body: Array<ComputedAccountIncome>, options?: any) {
        return DefaultApiFp(this.configuration).computedAccountIncomeApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of ComputedAccountIncome that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public computedAccountIncomeApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).computedAccountIncomeApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of ComputedAccountIncome with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public computedAccountIncomeApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).computedAccountIncomeApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of ComputedAccountIncome with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public computedAccountIncomeApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).computedAccountIncomeApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of ComputedAccountIncome that are provided
     * @param {Array<ComputedAccountIncome>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public computedAccountIncomeApiUpdate(body: Array<ComputedAccountIncome>, options?: any) {
        return DefaultApiFp(this.configuration).computedAccountIncomeApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of ComputedAccountPosition that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public computedAccountPositionApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).computedAccountPositionApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of ComputedAccountTotalIncome that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public computedAccountTotalIncomeApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).computedAccountTotalIncomeApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of ComputedProjectIncome based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<ComputedProjectIncome>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public computedProjectIncomeApiCreate(body: Array<ComputedProjectIncome>, options?: any) {
        return DefaultApiFp(this.configuration).computedProjectIncomeApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of ComputedProjectIncome that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public computedProjectIncomeApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).computedProjectIncomeApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of ComputedProjectIncome with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public computedProjectIncomeApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).computedProjectIncomeApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of ComputedProjectIncome with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public computedProjectIncomeApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).computedProjectIncomeApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of ComputedProjectIncome that are provided
     * @param {Array<ComputedProjectIncome>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public computedProjectIncomeApiUpdate(body: Array<ComputedProjectIncome>, options?: any) {
        return DefaultApiFp(this.configuration).computedProjectIncomeApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of ComputedProjectTotalIncome that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public computedProjectTotalIncomeApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).computedProjectTotalIncomeApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of Country based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<Country>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public countryApiCreate(body: Array<Country>, options?: any) {
        return DefaultApiFp(this.configuration).countryApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of Country that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public countryApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).countryApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of Country with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public countryApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).countryApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of Country with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public countryApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).countryApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of Country that are provided
     * @param {Array<Country>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public countryApiUpdate(body: Array<Country>, options?: any) {
        return DefaultApiFp(this.configuration).countryApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of Event based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<Event>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public eventApiCreate(body: Array<Event>, options?: any) {
        return DefaultApiFp(this.configuration).eventApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of Event that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public eventApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).eventApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of Event with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public eventApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).eventApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of Event with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public eventApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).eventApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of Event that are provided
     * @param {Array<Event>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public eventApiUpdate(body: Array<Event>, options?: any) {
        return DefaultApiFp(this.configuration).eventApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of ExemptDistributionOption based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<ExemptDistributionOption>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public exemptDistributionOptionApiCreate(body: Array<ExemptDistributionOption>, options?: any) {
        return DefaultApiFp(this.configuration).exemptDistributionOptionApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of ExemptDistributionOption that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public exemptDistributionOptionApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).exemptDistributionOptionApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of ExemptDistributionOption with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public exemptDistributionOptionApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).exemptDistributionOptionApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of ExemptDistributionOption with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public exemptDistributionOptionApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).exemptDistributionOptionApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of ExemptDistributionOption that are provided
     * @param {Array<ExemptDistributionOption>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public exemptDistributionOptionApiUpdate(body: Array<ExemptDistributionOption>, options?: any) {
        return DefaultApiFp(this.configuration).exemptDistributionOptionApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of FfbaAssociation based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<FfbaAssociation>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public ffbaAssociationApiCreate(body: Array<FfbaAssociation>, options?: any) {
        return DefaultApiFp(this.configuration).ffbaAssociationApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of FfbaAssociation that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public ffbaAssociationApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).ffbaAssociationApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of FfbaAssociation with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public ffbaAssociationApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).ffbaAssociationApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of FfbaAssociation with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public ffbaAssociationApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).ffbaAssociationApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of FfbaAssociation that are provided
     * @param {Array<FfbaAssociation>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public ffbaAssociationApiUpdate(body: Array<FfbaAssociation>, options?: any) {
        return DefaultApiFp(this.configuration).ffbaAssociationApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Cross check all cms cobranders with hubspot properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public hubspotContactCobrandersControllerCheckCobranders(options?: any) {
        return DefaultApiFp(this.configuration).hubspotContactCobrandersControllerCheckCobranders(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Cross check all cms investors with hubspot contacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public hubspotContactControllerCheckInvestors(options?: any) {
        return DefaultApiFp(this.configuration).hubspotContactControllerCheckInvestors(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Synchronize a single cms investor with a corresponding hubspot contact
     * @param {number} id The id of the investor to sync
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public hubspotContactControllerSyncInvestor(id: number, options?: any) {
        return DefaultApiFp(this.configuration).hubspotContactControllerSyncInvestor(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Cross check all cms orders with hubspot deal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public hubspotDealControllerCheckAllDeals(options?: any) {
        return DefaultApiFp(this.configuration).hubspotDealControllerCheckAllDeals(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Cross check all cms orders with hubspot deal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public hubspotDealControllerCheckOrders(options?: any) {
        return DefaultApiFp(this.configuration).hubspotDealControllerCheckOrders(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a new order based on the details of a deal whoose id is provided
     * @param {string} dealId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public hubspotDealControllerCreate(dealId: string, options?: any) {
        return DefaultApiFp(this.configuration).hubspotDealControllerCreate(dealId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Synchronize a single cms order with a corresponding hubspot deal
     * @param {number} id The id of the order to sync
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public hubspotDealControllerSyncOrder(id: number, options?: any) {
        return DefaultApiFp(this.configuration).hubspotDealControllerSyncOrder(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Ensure a single project is reflected in hubspot custom objects correctly
     * @param {number} id The id of the project to sync
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public hubspotProjectControllerCheckProject(id: number, options?: any) {
        return DefaultApiFp(this.configuration).hubspotProjectControllerCheckProject(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Cross check all cms projects with hubspot properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public hubspotProjectControllerCheckProjects(options?: any) {
        return DefaultApiFp(this.configuration).hubspotProjectControllerCheckProjects(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of ImportedContact based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<ImportedContact>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public importedContactApiCreate(body: Array<ImportedContact>, options?: any) {
        return DefaultApiFp(this.configuration).importedContactApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of ImportedContact that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public importedContactApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).importedContactApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of ImportedContact with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public importedContactApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).importedContactApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of ImportedContact with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public importedContactApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).importedContactApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of ImportedContact that are provided
     * @param {Array<ImportedContact>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public importedContactApiUpdate(body: Array<ImportedContact>, options?: any) {
        return DefaultApiFp(this.configuration).importedContactApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of InvestmentOrder based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<InvestmentOrder>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investmentOrderApiCreate(body: Array<InvestmentOrder>, options?: any) {
        return DefaultApiFp(this.configuration).investmentOrderApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of InvestmentOrder that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investmentOrderApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).investmentOrderApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of InvestmentOrder with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investmentOrderApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).investmentOrderApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of InvestmentOrder with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investmentOrderApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).investmentOrderApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of InvestmentOrder that are provided
     * @param {Array<InvestmentOrder>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investmentOrderApiUpdate(body: Array<InvestmentOrder>, options?: any) {
        return DefaultApiFp(this.configuration).investmentOrderApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of InvestmentTransaction based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<InvestmentTransaction>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investmentTransactionApiCreate(body: Array<InvestmentTransaction>, options?: any) {
        return DefaultApiFp(this.configuration).investmentTransactionApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of InvestmentTransaction that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investmentTransactionApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).investmentTransactionApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of InvestmentTransaction with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investmentTransactionApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).investmentTransactionApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of InvestmentTransaction with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investmentTransactionApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).investmentTransactionApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of InvestmentTransaction that are provided
     * @param {Array<InvestmentTransaction>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investmentTransactionApiUpdate(body: Array<InvestmentTransaction>, options?: any) {
        return DefaultApiFp(this.configuration).investmentTransactionApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of InvestmentWatchlist based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<InvestmentWatchlist>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investmentWatchlistApiCreate(body: Array<InvestmentWatchlist>, options?: any) {
        return DefaultApiFp(this.configuration).investmentWatchlistApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of InvestmentWatchlist that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investmentWatchlistApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).investmentWatchlistApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of InvestmentWatchlist with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investmentWatchlistApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).investmentWatchlistApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of InvestmentWatchlist with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investmentWatchlistApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).investmentWatchlistApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of InvestmentWatchlist that are provided
     * @param {Array<InvestmentWatchlist>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investmentWatchlistApiUpdate(body: Array<InvestmentWatchlist>, options?: any) {
        return DefaultApiFp(this.configuration).investmentWatchlistApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of InvestmentWithdrawal based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<InvestmentWithdrawal>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investmentWithdrawalApiCreate(body: Array<InvestmentWithdrawal>, options?: any) {
        return DefaultApiFp(this.configuration).investmentWithdrawalApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of InvestmentWithdrawal that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investmentWithdrawalApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).investmentWithdrawalApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of InvestmentWithdrawal with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investmentWithdrawalApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).investmentWithdrawalApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of InvestmentWithdrawal with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investmentWithdrawalApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).investmentWithdrawalApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of InvestmentWithdrawal that are provided
     * @param {Array<InvestmentWithdrawal>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investmentWithdrawalApiUpdate(body: Array<InvestmentWithdrawal>, options?: any) {
        return DefaultApiFp(this.configuration).investmentWithdrawalApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of Investor based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<Investor>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investorApiCreate(body: Array<Investor>, options?: any) {
        return DefaultApiFp(this.configuration).investorApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of Investor that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investorApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).investorApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of Investor with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investorApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).investorApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all non-deleted orders for a specific investor
     * @param {number} id The id of the investor to get all non-deleted orders for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investorApiGetAllNonDeletedOrders(id: number, options?: any) {
        return DefaultApiFp(this.configuration).investorApiGetAllNonDeletedOrders(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the annual investment limits for the given investor
     * @param {number} id The id of the investor to get the annual investment limits for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investorApiGetAnnualInvestmentLimits(id: number, options?: any) {
        return DefaultApiFp(this.configuration).investorApiGetAnnualInvestmentLimits(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary get the oldest non-deleted order in the last year for a given investor
     * @param {number} id the id of the investor to get the oldest non-deleted order in the last year for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investorApiGetOldestNonDeletedOrderLastYear(id: number, options?: any) {
        return DefaultApiFp(this.configuration).investorApiGetOldestNonDeletedOrderLastYear(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary get the total amount of all orders in the last year for a given investor
     * @param {number} id the id of the investor to get the total amount of all orders in the last year for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investorApiGetTotalAmountInvestedInLastYear(id: number, options?: any) {
        return DefaultApiFp(this.configuration).investorApiGetTotalAmountInvestedInLastYear(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of Investor with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investorApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).investorApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of Investor that are provided
     * @param {Array<Investor>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investorApiUpdate(body: Array<Investor>, options?: any) {
        return DefaultApiFp(this.configuration).investorApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of InvestorCobranding that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investorCobrandingApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).investorCobrandingApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of InvestorEarning based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<InvestorEarning>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investorEarningApiCreate(body: Array<InvestorEarning>, options?: any) {
        return DefaultApiFp(this.configuration).investorEarningApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of InvestorEarning that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investorEarningApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).investorEarningApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of InvestorEarning with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investorEarningApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).investorEarningApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of InvestorEarning with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investorEarningApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).investorEarningApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of InvestorEarning that are provided
     * @param {Array<InvestorEarning>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investorEarningApiUpdate(body: Array<InvestorEarning>, options?: any) {
        return DefaultApiFp(this.configuration).investorEarningApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of InvestorIntendedTrades based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<InvestorIntendedTrades>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investorIntendedTradesApiCreate(body: Array<InvestorIntendedTrades>, options?: any) {
        return DefaultApiFp(this.configuration).investorIntendedTradesApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of InvestorIntendedTrades that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investorIntendedTradesApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).investorIntendedTradesApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of InvestorIntendedTrades with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investorIntendedTradesApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).investorIntendedTradesApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of InvestorIntendedTrades with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investorIntendedTradesApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).investorIntendedTradesApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of InvestorIntendedTrades that are provided
     * @param {Array<InvestorIntendedTrades>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investorIntendedTradesApiUpdate(body: Array<InvestorIntendedTrades>, options?: any) {
        return DefaultApiFp(this.configuration).investorIntendedTradesApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of InvestorSocialProfile based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<InvestorSocialProfile>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investorSocialProfileApiCreate(body: Array<InvestorSocialProfile>, options?: any) {
        return DefaultApiFp(this.configuration).investorSocialProfileApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of InvestorSocialProfile that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investorSocialProfileApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).investorSocialProfileApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of InvestorSocialProfile with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investorSocialProfileApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).investorSocialProfileApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of InvestorSocialProfile with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investorSocialProfileApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).investorSocialProfileApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of InvestorSocialProfile that are provided
     * @param {Array<InvestorSocialProfile>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public investorSocialProfileApiUpdate(body: Array<InvestorSocialProfile>, options?: any) {
        return DefaultApiFp(this.configuration).investorSocialProfileApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of IssuerAdmin based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<IssuerAdmin>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public issuerAdminApiCreate(body: Array<IssuerAdmin>, options?: any) {
        return DefaultApiFp(this.configuration).issuerAdminApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of IssuerAdmin that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public issuerAdminApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).issuerAdminApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of IssuerAdmin with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public issuerAdminApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).issuerAdminApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of IssuerAdmin with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public issuerAdminApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).issuerAdminApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of IssuerAdmin that are provided
     * @param {Array<IssuerAdmin>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public issuerAdminApiUpdate(body: Array<IssuerAdmin>, options?: any) {
        return DefaultApiFp(this.configuration).issuerAdminApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of Mail based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<Mail>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public mailApiCreate(body: Array<Mail>, options?: any) {
        return DefaultApiFp(this.configuration).mailApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of Mail that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public mailApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).mailApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of Mail with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public mailApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).mailApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of Mail with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public mailApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).mailApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of Mail that are provided
     * @param {Array<Mail>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public mailApiUpdate(body: Array<Mail>, options?: any) {
        return DefaultApiFp(this.configuration).mailApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of Menu based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<Menu>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public menuApiCreate(body: Array<Menu>, options?: any) {
        return DefaultApiFp(this.configuration).menuApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of Menu that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public menuApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).menuApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of Menu with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public menuApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).menuApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of Menu with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public menuApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).menuApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of Menu that are provided
     * @param {Array<Menu>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public menuApiUpdate(body: Array<Menu>, options?: any) {
        return DefaultApiFp(this.configuration).menuApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a metrics based on a request saved in the current users specified preference
     * @param {string} preference The name of the preference to get the request from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public metricsApiFindByPreference(preference: string, options?: any) {
        return DefaultApiFp(this.configuration).metricsApiFindByPreference(preference, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the data associated with the specified metric
     * @param {MetricsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public metricsApiFindOneById(body: MetricsRequest, options?: any) {
        return DefaultApiFp(this.configuration).metricsApiFindOneById(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Save the given request as a preference and then get the mtrics
     * @param {MetricsRequest} body 
     * @param {string} preference 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public metricsApiSavePreferenceAnGet(body: MetricsRequest, preference: string, options?: any) {
        return DefaultApiFp(this.configuration).metricsApiSavePreferenceAnGet(body, preference, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of ModuleAccess based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<ModuleAccess>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public moduleAccessApiCreate(body: Array<ModuleAccess>, options?: any) {
        return DefaultApiFp(this.configuration).moduleAccessApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of ModuleAccess that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public moduleAccessApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).moduleAccessApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of ModuleAccess with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public moduleAccessApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).moduleAccessApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of ModuleAccess with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public moduleAccessApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).moduleAccessApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of ModuleAccess that are provided
     * @param {Array<ModuleAccess>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public moduleAccessApiUpdate(body: Array<ModuleAccess>, options?: any) {
        return DefaultApiFp(this.configuration).moduleAccessApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of NotableInvestorProfile based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<NotableInvestorProfile>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notableInvestorProfileApiCreate(body: Array<NotableInvestorProfile>, options?: any) {
        return DefaultApiFp(this.configuration).notableInvestorProfileApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of NotableInvestorProfile that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notableInvestorProfileApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).notableInvestorProfileApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of NotableInvestorProfile with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notableInvestorProfileApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).notableInvestorProfileApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of NotableInvestorProfile with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notableInvestorProfileApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).notableInvestorProfileApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of NotableInvestorProfile that are provided
     * @param {Array<NotableInvestorProfile>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notableInvestorProfileApiUpdate(body: Array<NotableInvestorProfile>, options?: any) {
        return DefaultApiFp(this.configuration).notableInvestorProfileApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of OrderAcknowledgement based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<OrderAcknowledgement>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public orderAcknowledgementApiCreate(body: Array<OrderAcknowledgement>, options?: any) {
        return DefaultApiFp(this.configuration).orderAcknowledgementApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of OrderAcknowledgement that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public orderAcknowledgementApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).orderAcknowledgementApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of OrderAcknowledgement with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public orderAcknowledgementApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).orderAcknowledgementApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of OrderAcknowledgement with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public orderAcknowledgementApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).orderAcknowledgementApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of OrderAcknowledgement that are provided
     * @param {Array<OrderAcknowledgement>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public orderAcknowledgementApiUpdate(body: Array<OrderAcknowledgement>, options?: any) {
        return DefaultApiFp(this.configuration).orderAcknowledgementApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of OrderAcknowledgementQuestion based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<OrderAcknowledgementQuestion>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public orderAcknowledgementQuestionApiCreate(body: Array<OrderAcknowledgementQuestion>, options?: any) {
        return DefaultApiFp(this.configuration).orderAcknowledgementQuestionApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of OrderAcknowledgementQuestion that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public orderAcknowledgementQuestionApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).orderAcknowledgementQuestionApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of OrderAcknowledgementQuestion with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public orderAcknowledgementQuestionApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).orderAcknowledgementQuestionApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of OrderAcknowledgementQuestion with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public orderAcknowledgementQuestionApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).orderAcknowledgementQuestionApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of OrderAcknowledgementQuestion that are provided
     * @param {Array<OrderAcknowledgementQuestion>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public orderAcknowledgementQuestionApiUpdate(body: Array<OrderAcknowledgementQuestion>, options?: any) {
        return DefaultApiFp(this.configuration).orderAcknowledgementQuestionApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of ProfileBackground based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<ProfileBackground>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public profileBackgroundApiCreate(body: Array<ProfileBackground>, options?: any) {
        return DefaultApiFp(this.configuration).profileBackgroundApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of ProfileBackground that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public profileBackgroundApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).profileBackgroundApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of ProfileBackground with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public profileBackgroundApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).profileBackgroundApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of ProfileBackground with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public profileBackgroundApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).profileBackgroundApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of ProfileBackground that are provided
     * @param {Array<ProfileBackground>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public profileBackgroundApiUpdate(body: Array<ProfileBackground>, options?: any) {
        return DefaultApiFp(this.configuration).profileBackgroundApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of ProjectAccount based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<ProjectAccount>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectAccountApiCreate(body: Array<ProjectAccount>, options?: any) {
        return DefaultApiFp(this.configuration).projectAccountApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of ProjectAccount that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectAccountApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).projectAccountApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of ProjectAccount with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectAccountApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).projectAccountApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of ProjectAccount with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectAccountApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).projectAccountApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of ProjectAccount that are provided
     * @param {Array<ProjectAccount>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectAccountApiUpdate(body: Array<ProjectAccount>, options?: any) {
        return DefaultApiFp(this.configuration).projectAccountApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of Project based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<Project>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectApiCreate(body: Array<Project>, options?: any) {
        return DefaultApiFp(this.configuration).projectApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of Project that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).projectApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of Project with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).projectApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of Project with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).projectApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of Project that are provided
     * @param {Array<Project>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectApiUpdate(body: Array<Project>, options?: any) {
        return DefaultApiFp(this.configuration).projectApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of ProjectBalanceAdjustment based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<ProjectBalanceAdjustment>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectBalanceAdjustmentApiCreate(body: Array<ProjectBalanceAdjustment>, options?: any) {
        return DefaultApiFp(this.configuration).projectBalanceAdjustmentApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of ProjectBalanceAdjustment that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectBalanceAdjustmentApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).projectBalanceAdjustmentApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of ProjectBalanceAdjustment with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectBalanceAdjustmentApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).projectBalanceAdjustmentApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of ProjectBalanceAdjustment with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectBalanceAdjustmentApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).projectBalanceAdjustmentApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of ProjectBalanceAdjustment that are provided
     * @param {Array<ProjectBalanceAdjustment>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectBalanceAdjustmentApiUpdate(body: Array<ProjectBalanceAdjustment>, options?: any) {
        return DefaultApiFp(this.configuration).projectBalanceAdjustmentApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of ProjectDocusignMapping based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<ProjectDocusignMapping>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectDocusignMappingApiCreate(body: Array<ProjectDocusignMapping>, options?: any) {
        return DefaultApiFp(this.configuration).projectDocusignMappingApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of ProjectDocusignMapping that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectDocusignMappingApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).projectDocusignMappingApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of ProjectDocusignMapping with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectDocusignMappingApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).projectDocusignMappingApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of ProjectDocusignMapping with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectDocusignMappingApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).projectDocusignMappingApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of ProjectDocusignMapping that are provided
     * @param {Array<ProjectDocusignMapping>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectDocusignMappingApiUpdate(body: Array<ProjectDocusignMapping>, options?: any) {
        return DefaultApiFp(this.configuration).projectDocusignMappingApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of ProjectEntity based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<ProjectEntity>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectEntityApiCreate(body: Array<ProjectEntity>, options?: any) {
        return DefaultApiFp(this.configuration).projectEntityApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of ProjectEntity that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectEntityApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).projectEntityApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of ProjectEntity with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectEntityApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).projectEntityApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of ProjectEntity with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectEntityApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).projectEntityApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of ProjectEntity that are provided
     * @param {Array<ProjectEntity>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectEntityApiUpdate(body: Array<ProjectEntity>, options?: any) {
        return DefaultApiFp(this.configuration).projectEntityApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of ProjectEntityDetail based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<ProjectEntityDetail>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectEntityDetailApiCreate(body: Array<ProjectEntityDetail>, options?: any) {
        return DefaultApiFp(this.configuration).projectEntityDetailApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of ProjectEntityDetail that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectEntityDetailApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).projectEntityDetailApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of ProjectEntityDetail with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectEntityDetailApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).projectEntityDetailApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of ProjectEntityDetail with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectEntityDetailApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).projectEntityDetailApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of ProjectEntityDetail that are provided
     * @param {Array<ProjectEntityDetail>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectEntityDetailApiUpdate(body: Array<ProjectEntityDetail>, options?: any) {
        return DefaultApiFp(this.configuration).projectEntityDetailApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of ProjectImage based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<ProjectImage>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectImageApiCreate(body: Array<ProjectImage>, options?: any) {
        return DefaultApiFp(this.configuration).projectImageApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of ProjectImage that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectImageApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).projectImageApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of ProjectImage with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectImageApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).projectImageApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of ProjectImage with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectImageApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).projectImageApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of ProjectImage that are provided
     * @param {Array<ProjectImage>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectImageApiUpdate(body: Array<ProjectImage>, options?: any) {
        return DefaultApiFp(this.configuration).projectImageApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of ProjectInterest based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<ProjectInterest>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectInterestApiCreate(body: Array<ProjectInterest>, options?: any) {
        return DefaultApiFp(this.configuration).projectInterestApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of ProjectInterest that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectInterestApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).projectInterestApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of ProjectInterest with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectInterestApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).projectInterestApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of ProjectInterest with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectInterestApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).projectInterestApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of ProjectInterest that are provided
     * @param {Array<ProjectInterest>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectInterestApiUpdate(body: Array<ProjectInterest>, options?: any) {
        return DefaultApiFp(this.configuration).projectInterestApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of ProjectKeybacker based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<ProjectKeybacker>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectKeybackerApiCreate(body: Array<ProjectKeybacker>, options?: any) {
        return DefaultApiFp(this.configuration).projectKeybackerApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of ProjectKeybacker that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectKeybackerApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).projectKeybackerApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of ProjectKeybacker with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectKeybackerApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).projectKeybackerApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of ProjectKeybacker with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectKeybackerApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).projectKeybackerApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of ProjectKeybacker that are provided
     * @param {Array<ProjectKeybacker>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectKeybackerApiUpdate(body: Array<ProjectKeybacker>, options?: any) {
        return DefaultApiFp(this.configuration).projectKeybackerApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of ProjectPdf based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<ProjectPdf>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectPdfApiCreate(body: Array<ProjectPdf>, options?: any) {
        return DefaultApiFp(this.configuration).projectPdfApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of ProjectPdf that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectPdfApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).projectPdfApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of ProjectPdf with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectPdfApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).projectPdfApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of ProjectPdf with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectPdfApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).projectPdfApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of ProjectPdf that are provided
     * @param {Array<ProjectPdf>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectPdfApiUpdate(body: Array<ProjectPdf>, options?: any) {
        return DefaultApiFp(this.configuration).projectPdfApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of ProjectStatusReport based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<ProjectStatusReport>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectStatusReportApiCreate(body: Array<ProjectStatusReport>, options?: any) {
        return DefaultApiFp(this.configuration).projectStatusReportApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of ProjectStatusReport that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectStatusReportApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).projectStatusReportApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of ProjectStatusReport with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectStatusReportApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).projectStatusReportApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of ProjectStatusReport with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectStatusReportApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).projectStatusReportApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of ProjectStatusReport that are provided
     * @param {Array<ProjectStatusReport>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectStatusReportApiUpdate(body: Array<ProjectStatusReport>, options?: any) {
        return DefaultApiFp(this.configuration).projectStatusReportApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of ProjectTaxReport based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<ProjectTaxReport>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectTaxReportApiCreate(body: Array<ProjectTaxReport>, options?: any) {
        return DefaultApiFp(this.configuration).projectTaxReportApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of ProjectTaxReport that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectTaxReportApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).projectTaxReportApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of ProjectTaxReport with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectTaxReportApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).projectTaxReportApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of ProjectTaxReport with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectTaxReportApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).projectTaxReportApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of ProjectTaxReport that are provided
     * @param {Array<ProjectTaxReport>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectTaxReportApiUpdate(body: Array<ProjectTaxReport>, options?: any) {
        return DefaultApiFp(this.configuration).projectTaxReportApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of ProjectTaxSummary based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<ProjectTaxSummary>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectTaxSummaryApiCreate(body: Array<ProjectTaxSummary>, options?: any) {
        return DefaultApiFp(this.configuration).projectTaxSummaryApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of ProjectTaxSummary that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectTaxSummaryApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).projectTaxSummaryApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of ProjectTaxSummary with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectTaxSummaryApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).projectTaxSummaryApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of ProjectTaxSummary with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectTaxSummaryApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).projectTaxSummaryApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of ProjectTaxSummary that are provided
     * @param {Array<ProjectTaxSummary>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public projectTaxSummaryApiUpdate(body: Array<ProjectTaxSummary>, options?: any) {
        return DefaultApiFp(this.configuration).projectTaxSummaryApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of PropertySocialProfile based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<PropertySocialProfile>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public propertySocialProfileApiCreate(body: Array<PropertySocialProfile>, options?: any) {
        return DefaultApiFp(this.configuration).propertySocialProfileApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of PropertySocialProfile that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public propertySocialProfileApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).propertySocialProfileApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of PropertySocialProfile with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public propertySocialProfileApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).propertySocialProfileApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of PropertySocialProfile with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public propertySocialProfileApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).propertySocialProfileApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of PropertySocialProfile that are provided
     * @param {Array<PropertySocialProfile>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public propertySocialProfileApiUpdate(body: Array<PropertySocialProfile>, options?: any) {
        return DefaultApiFp(this.configuration).propertySocialProfileApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of Province based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<Province>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public provinceApiCreate(body: Array<Province>, options?: any) {
        return DefaultApiFp(this.configuration).provinceApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of Province that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public provinceApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).provinceApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of Province with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public provinceApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).provinceApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of Province with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public provinceApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).provinceApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of Province that are provided
     * @param {Array<Province>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public provinceApiUpdate(body: Array<Province>, options?: any) {
        return DefaultApiFp(this.configuration).provinceApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of RegistrationQuestion based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<RegistrationQuestion>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public registrationQuestionApiCreate(body: Array<RegistrationQuestion>, options?: any) {
        return DefaultApiFp(this.configuration).registrationQuestionApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of RegistrationQuestion that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public registrationQuestionApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).registrationQuestionApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of RegistrationQuestion with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public registrationQuestionApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).registrationQuestionApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of RegistrationQuestion with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public registrationQuestionApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).registrationQuestionApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of RegistrationQuestion that are provided
     * @param {Array<RegistrationQuestion>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public registrationQuestionApiUpdate(body: Array<RegistrationQuestion>, options?: any) {
        return DefaultApiFp(this.configuration).registrationQuestionApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Confirm escrow and trade dates for orders on a roed
     * @param {RoedSchedule1} body 
     * @param {number} id The id of the roed to confirm
     * @param {string} date The date to fill escrow and trade dates if they are empty
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public roedSchedule1ApiConfirmReconciliation(body: RoedSchedule1, id: number, date: string, options?: any) {
        return DefaultApiFp(this.configuration).roedSchedule1ApiConfirmReconciliation(body, id, date, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of RoedSchedule1 based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<RoedSchedule1>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public roedSchedule1ApiCreate(body: Array<RoedSchedule1>, options?: any) {
        return DefaultApiFp(this.configuration).roedSchedule1ApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of RoedSchedule1 that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public roedSchedule1ApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).roedSchedule1ApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of RoedSchedule1 with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public roedSchedule1ApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).roedSchedule1ApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of RoedSchedule1 with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public roedSchedule1ApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).roedSchedule1ApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of RoedSchedule1 that are provided
     * @param {Array<RoedSchedule1>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public roedSchedule1ApiUpdate(body: Array<RoedSchedule1>, options?: any) {
        return DefaultApiFp(this.configuration).roedSchedule1ApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of Setting based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<Setting>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public settingApiCreate(body: Array<Setting>, options?: any) {
        return DefaultApiFp(this.configuration).settingApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of Setting that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public settingApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).settingApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of Setting with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public settingApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).settingApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of Setting with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public settingApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).settingApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of Setting that are provided
     * @param {Array<Setting>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public settingApiUpdate(body: Array<Setting>, options?: any) {
        return DefaultApiFp(this.configuration).settingApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of SocialProfileFollowing based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<SocialProfileFollowing>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public socialProfileFollowingApiCreate(body: Array<SocialProfileFollowing>, options?: any) {
        return DefaultApiFp(this.configuration).socialProfileFollowingApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of SocialProfileFollowing that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public socialProfileFollowingApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).socialProfileFollowingApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of SocialProfileFollowing with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public socialProfileFollowingApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).socialProfileFollowingApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of SocialProfileFollowing with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public socialProfileFollowingApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).socialProfileFollowingApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of SocialProfileFollowing that are provided
     * @param {Array<SocialProfileFollowing>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public socialProfileFollowingApiUpdate(body: Array<SocialProfileFollowing>, options?: any) {
        return DefaultApiFp(this.configuration).socialProfileFollowingApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of SponsorSocialProfile based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<SponsorSocialProfile>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public sponsorSocialProfileApiCreate(body: Array<SponsorSocialProfile>, options?: any) {
        return DefaultApiFp(this.configuration).sponsorSocialProfileApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of SponsorSocialProfile that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public sponsorSocialProfileApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).sponsorSocialProfileApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of SponsorSocialProfile with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public sponsorSocialProfileApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).sponsorSocialProfileApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of SponsorSocialProfile with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public sponsorSocialProfileApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).sponsorSocialProfileApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of SponsorSocialProfile that are provided
     * @param {Array<SponsorSocialProfile>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public sponsorSocialProfileApiUpdate(body: Array<SponsorSocialProfile>, options?: any) {
        return DefaultApiFp(this.configuration).sponsorSocialProfileApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of SupportEngineer based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<SupportEngineer>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public supportEngineerApiCreate(body: Array<SupportEngineer>, options?: any) {
        return DefaultApiFp(this.configuration).supportEngineerApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of SupportEngineer that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public supportEngineerApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).supportEngineerApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of SupportEngineer with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public supportEngineerApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).supportEngineerApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of SupportEngineer with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public supportEngineerApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).supportEngineerApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of SupportEngineer that are provided
     * @param {Array<SupportEngineer>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public supportEngineerApiUpdate(body: Array<SupportEngineer>, options?: any) {
        return DefaultApiFp(this.configuration).supportEngineerApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of UserAnswer based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<UserAnswer>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userAnswerApiCreate(body: Array<UserAnswer>, options?: any) {
        return DefaultApiFp(this.configuration).userAnswerApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of UserAnswer that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userAnswerApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).userAnswerApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of UserAnswer with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userAnswerApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).userAnswerApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of UserAnswer with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userAnswerApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).userAnswerApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of UserAnswer that are provided
     * @param {Array<UserAnswer>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userAnswerApiUpdate(body: Array<UserAnswer>, options?: any) {
        return DefaultApiFp(this.configuration).userAnswerApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of UserBankingDetails based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<UserBankingDetails>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userBankingDetailsApiCreate(body: Array<UserBankingDetails>, options?: any) {
        return DefaultApiFp(this.configuration).userBankingDetailsApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of UserBankingDetails that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userBankingDetailsApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).userBankingDetailsApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of UserBankingDetails with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userBankingDetailsApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).userBankingDetailsApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of UserBankingDetails with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userBankingDetailsApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).userBankingDetailsApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of UserBankingDetails that are provided
     * @param {Array<UserBankingDetails>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userBankingDetailsApiUpdate(body: Array<UserBankingDetails>, options?: any) {
        return DefaultApiFp(this.configuration).userBankingDetailsApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of UserBasic based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<UserBasic>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userBasicApiCreate(body: Array<UserBasic>, options?: any) {
        return DefaultApiFp(this.configuration).userBasicApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of UserBasic that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userBasicApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).userBasicApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of UserBasic with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userBasicApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).userBasicApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of UserBasic with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userBasicApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).userBasicApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of UserBasic that are provided
     * @param {Array<UserBasic>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userBasicApiUpdate(body: Array<UserBasic>, options?: any) {
        return DefaultApiFp(this.configuration).userBasicApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of UserBeneficiary based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<UserBeneficiary>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userBeneficiaryApiCreate(body: Array<UserBeneficiary>, options?: any) {
        return DefaultApiFp(this.configuration).userBeneficiaryApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of UserBeneficiary that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userBeneficiaryApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).userBeneficiaryApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of UserBeneficiary with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userBeneficiaryApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).userBeneficiaryApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of UserBeneficiary with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userBeneficiaryApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).userBeneficiaryApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of UserBeneficiary that are provided
     * @param {Array<UserBeneficiary>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userBeneficiaryApiUpdate(body: Array<UserBeneficiary>, options?: any) {
        return DefaultApiFp(this.configuration).userBeneficiaryApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of UserCorporation based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<UserCorporation>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userCorporationApiCreate(body: Array<UserCorporation>, options?: any) {
        return DefaultApiFp(this.configuration).userCorporationApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of UserCorporation that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userCorporationApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).userCorporationApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of UserCorporation with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userCorporationApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).userCorporationApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of UserCorporation with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userCorporationApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).userCorporationApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of UserCorporation that are provided
     * @param {Array<UserCorporation>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userCorporationApiUpdate(body: Array<UserCorporation>, options?: any) {
        return DefaultApiFp(this.configuration).userCorporationApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of UserEntity based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<UserEntity>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userEntityApiCreate(body: Array<UserEntity>, options?: any) {
        return DefaultApiFp(this.configuration).userEntityApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of UserEntity that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userEntityApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).userEntityApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of UserEntity with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userEntityApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).userEntityApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of UserEntity with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userEntityApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).userEntityApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of UserEntity that are provided
     * @param {Array<UserEntity>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userEntityApiUpdate(body: Array<UserEntity>, options?: any) {
        return DefaultApiFp(this.configuration).userEntityApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of UserFinancialKyc based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<UserFinancialKyc>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userFinancialKycApiCreate(body: Array<UserFinancialKyc>, options?: any) {
        return DefaultApiFp(this.configuration).userFinancialKycApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of UserFinancialKyc that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userFinancialKycApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).userFinancialKycApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of UserFinancialKyc with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userFinancialKycApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).userFinancialKycApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of UserFinancialKyc with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userFinancialKycApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).userFinancialKycApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of UserFinancialKyc that are provided
     * @param {Array<UserFinancialKyc>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userFinancialKycApiUpdate(body: Array<UserFinancialKyc>, options?: any) {
        return DefaultApiFp(this.configuration).userFinancialKycApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of UserInvitation based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<UserInvitation>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userInvitationApiCreate(body: Array<UserInvitation>, options?: any) {
        return DefaultApiFp(this.configuration).userInvitationApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of UserInvitation that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userInvitationApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).userInvitationApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of UserInvitation with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userInvitationApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).userInvitationApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of UserInvitation with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userInvitationApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).userInvitationApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of UserInvitation that are provided
     * @param {Array<UserInvitation>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userInvitationApiUpdate(body: Array<UserInvitation>, options?: any) {
        return DefaultApiFp(this.configuration).userInvitationApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of UserIssuerAssociation based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<UserIssuerAssociation>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userIssuerAssociationApiCreate(body: Array<UserIssuerAssociation>, options?: any) {
        return DefaultApiFp(this.configuration).userIssuerAssociationApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of UserIssuerAssociation that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userIssuerAssociationApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).userIssuerAssociationApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of UserIssuerAssociation with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userIssuerAssociationApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).userIssuerAssociationApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of UserIssuerAssociation with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userIssuerAssociationApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).userIssuerAssociationApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of UserIssuerAssociation that are provided
     * @param {Array<UserIssuerAssociation>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userIssuerAssociationApiUpdate(body: Array<UserIssuerAssociation>, options?: any) {
        return DefaultApiFp(this.configuration).userIssuerAssociationApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a new instance of UserPdf base on the value passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the id of the newly created object
     * @param {UserPdf} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userPdfApiCreate(body: UserPdf, options?: any) {
        return DefaultApiFp(this.configuration).userPdfApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Download the file
     * @param {number} id The id of the pdf to download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userPdfApiDownload(id: number, options?: any) {
        return DefaultApiFp(this.configuration).userPdfApiDownload(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all UserPdf of AdminLog that match the given filter, and structure the associated pdf files and download zipped bundle file
     * @param {string} filter the odata like filter expression use to match which instances are returned. pdf_type, pdf_name, fullName(user.first_name + user.last_name) are mandatory
     * @param {string} pattern a comma separated list of naming pattern that specfiy how the pdf files are structured and named. There are three naming patterns. First and second patterns are for directory and third naming pattern is for pdf file name. If pattern is \&quot;order.project.name,user.client_number,pdf_name\&quot;, you would create a root directory from the property users_pdf.order.project.name, inside of that create a directory from the property users_pdf.user.client_number and in that create a file name users_pdf.pdf_name with a \&quot;.pdf\&quot; suffix.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userPdfApiDownloadBundle(filter: string, pattern: string, options?: any) {
        return DefaultApiFp(this.configuration).userPdfApiDownloadBundle(filter, pattern, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all UserPdf of AdminLog that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userPdfApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).userPdfApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all UserPdf of AdminLog that match the given filter. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userPdfApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).userPdfApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of UserPdf with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userPdfApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).userPdfApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instance of UserPdf that is provided
     * @param {UserPdf} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userPdfApiUpdate(body: UserPdf, options?: any) {
        return DefaultApiFp(this.configuration).userPdfApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of UserRelationship based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<UserRelationship>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userRelationshipApiCreate(body: Array<UserRelationship>, options?: any) {
        return DefaultApiFp(this.configuration).userRelationshipApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of UserRelationship that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userRelationshipApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).userRelationshipApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of UserRelationship with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userRelationshipApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).userRelationshipApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of UserRelationship with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userRelationshipApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).userRelationshipApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of UserRelationship that are provided
     * @param {Array<UserRelationship>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userRelationshipApiUpdate(body: Array<UserRelationship>, options?: any) {
        return DefaultApiFp(this.configuration).userRelationshipApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of UserRequest based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<UserRequest>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userRequestApiCreate(body: Array<UserRequest>, options?: any) {
        return DefaultApiFp(this.configuration).userRequestApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of UserRequest that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userRequestApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).userRequestApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of UserRequest with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userRequestApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).userRequestApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of UserRequest with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userRequestApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).userRequestApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of UserRequest that are provided
     * @param {Array<UserRequest>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userRequestApiUpdate(body: Array<UserRequest>, options?: any) {
        return DefaultApiFp(this.configuration).userRequestApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of UserSignupEvent that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSignupEventApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).userSignupEventApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of UserSocialPost based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<UserSocialPost>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSocialPostApiCreate(body: Array<UserSocialPost>, options?: any) {
        return DefaultApiFp(this.configuration).userSocialPostApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of UserSocialPost that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSocialPostApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).userSocialPostApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of UserSocialPost with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSocialPostApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).userSocialPostApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of UserSocialPost with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSocialPostApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).userSocialPostApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of UserSocialPost that are provided
     * @param {Array<UserSocialPost>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSocialPostApiUpdate(body: Array<UserSocialPost>, options?: any) {
        return DefaultApiFp(this.configuration).userSocialPostApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of UserSocialProfile based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<UserSocialProfile>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSocialProfileApiCreate(body: Array<UserSocialProfile>, options?: any) {
        return DefaultApiFp(this.configuration).userSocialProfileApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of UserSocialProfile that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSocialProfileApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).userSocialProfileApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of UserSocialProfile with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSocialProfileApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).userSocialProfileApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of UserSocialProfile with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSocialProfileApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).userSocialProfileApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of UserSocialProfile that are provided
     * @param {Array<UserSocialProfile>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSocialProfileApiUpdate(body: Array<UserSocialProfile>, options?: any) {
        return DefaultApiFp(this.configuration).userSocialProfileApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of UserSubscription based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<UserSubscription>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSubscriptionApiCreate(body: Array<UserSubscription>, options?: any) {
        return DefaultApiFp(this.configuration).userSubscriptionApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of UserSubscription that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSubscriptionApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).userSubscriptionApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of UserSubscription with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSubscriptionApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).userSubscriptionApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of UserSubscription with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSubscriptionApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).userSubscriptionApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of UserSubscription that are provided
     * @param {Array<UserSubscription>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userSubscriptionApiUpdate(body: Array<UserSubscription>, options?: any) {
        return DefaultApiFp(this.configuration).userSubscriptionApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of UserTrust based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<UserTrust>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userTrustApiCreate(body: Array<UserTrust>, options?: any) {
        return DefaultApiFp(this.configuration).userTrustApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of UserTrust that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userTrustApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).userTrustApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of UserTrust with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userTrustApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).userTrustApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of UserTrust with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userTrustApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).userTrustApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of UserTrust that are provided
     * @param {Array<UserTrust>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userTrustApiUpdate(body: Array<UserTrust>, options?: any) {
        return DefaultApiFp(this.configuration).userTrustApiUpdate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new instances of WebHook based on the values passed in. If the id is filled in, it will fail to create the new instance, otherwise it returns the the newly created objects
     * @param {Array<WebHook>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public webHookApiCreate(body: Array<WebHook>, options?: any) {
        return DefaultApiFp(this.configuration).webHookApiCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find all instances of WebHook that match the given filter. If none are found, an empty result is returned
     * @param {string} [filter] the odata like filter expression use to match which instances are returned
     * @param {string} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {string} [orderBy] a comma separated list of order by directives used to determine the order in which the objects are returned. Each directive is a single property name optionally followed by desc if descending is required. For example [first_name, last_name desc]
     * @param {number} [page] if the results are paged (pageSize is specified), this is the page number to return. The first page is 1
     * @param {number} [pageSize] if specified, the results are paged and this is the size of each of those pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public webHookApiFindAllByFilter(filter?: string, expand?: string, orderBy?: string, page?: number, pageSize?: number, options?: any) {
        return DefaultApiFp(this.configuration).webHookApiFindAllByFilter(filter, expand, orderBy, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find a single instance of WebHook with the given id. If none are found, an empty result is returned
     * @param {number} id The id of the instance to retrieve
     * @param {Array<string>} [expand] a comma separated list of property path&#x27;s that specfiy which additional objects will be filled in the object (deep load). If nothing is specified only the object itself will be loaded, not of its relations will be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public webHookApiFindOneById(id: number, expand?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).webHookApiFindOneById(id, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the single instance of WebHook with the specified id
     * @param {number} id The id of the instance to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public webHookApiRemove(id: number, options?: any) {
        return DefaultApiFp(this.configuration).webHookApiRemove(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the values for the instances of WebHook that are provided
     * @param {Array<WebHook>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public webHookApiUpdate(body: Array<WebHook>, options?: any) {
        return DefaultApiFp(this.configuration).webHookApiUpdate(body, options)(this.fetch, this.basePath);
    }

}
